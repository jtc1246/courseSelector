interface AutoJs {
    /**
     * @中文
     * 
     * 用于提供Java交互的API。这些API比较原始，建议使用封装后的java模块和rhino模块。
     * 
     * @eng
     * 
     * raw APIs for Java interop. Recommended to use java and rhino modules instead.
     */
    java: Java

    androidContext: android.content.Context;

    application: android.app.Application;

    /**
     * @中文
     * 
     * 保持引擎运行，阻止Node.js事件循环退出。返回一个id用于取消它。如果有多处keepRunning调用，仅当所有都被取消后，才会取消保持事件循环运行。
     * 
     * @returns id，用于取消保持事件循环。
     * 
     * @eng
     * 
     * Keep the engine running, preventing Node.js event loop to exit. Return an id to cancel it. If there are multiple keepRunning calls, only when all of them are cancelled, the keep running will be cancelled.
     * 
     * @returns id, to cancel the keep running.
     */
    keepRunning(): number

    /**
     * @中文
     * 
     * 取消保持引擎运行。
     * 
     * @param id keepRunning()返回的id
     * 
     * @eng
     * 
     * Cancel the keep running.
     * 
     * @param id The id returned by keepRunning()
     * 
     * @see {@link keepRunning}
     */
    cancelKeepRunning(id: number)

    /**
     * @中文
     * 
     * 要求指定Auto.js Pro版本才能运行，如果当前版本低于指定版本，抛出异常。
     * 
     * @param version Auto.js Pro版本号，如"Pro 9.1.0-2"
     * 
     * @eng
     * 
     * Require the specified Auto.js Pro version to run, if the current version is lower than the specified version, throw an exception.
     * 
     * @param version Auto.js Pro version, like "Pro 9.1.0-2"
     * 
     */
    requireAutoJsVersion(version: string)

    properties: ReadonlyMap<string, any>

    /**
     * @中文
     * 
     * 是否是在打包后app环境中运行。若为false则是在Auto.js Pro本体中运行。
     * 
     * @eng
     * 
     * Whether is run in built app environment.
     */
    isReleaseMode: boolean;
}

/**
 * @中文
 * 
 * 线程模式，用于设置Java函数或对象所运行的线程。
 * 
 * * ui: UI线程
 * * io: IO线程，通常用于文件读写、网络请求等
 * * compute: 计算线程，通常用于计算密集型任务
 * * current: 当前线程
 * 
 * @eng
 * 
 * Thread mode, used to set the running thread of Java function or object.
 * 
 * * ui: UI thread
 * * io: IO thread, usually used for file reading and writing, network requests etc.
 * * compute: compute thread, usually used for compute-intensive tasks
 * * current: current thread
 * 
 * @see {@link Java.setThreadMode}
 */
type ThreadMode = 'ui' | 'current' | 'compute' | 'io';

interface DefineClassOptions {
    /**
     * @中文
     * 
     * 要实现的Java接口列表，默认为空。比如`[View.OnClickListener, View.OnLongClickListener]`。
     * 
     * @eng
     * 
     * The java interfaces to implement, defaults to empty. e.g. `[View.OnClickListener, View.OnLongClickListener]`.
     */

    implements?: Array<JavaClass>,
    /**
     * @中文
     * 
     * 生成类的包名，默认为空。
     * 
     * @eng
     * 
     * The package name of the generated class, defaults to empty.
     */
    packageName?: string,
    /**
     * @中文
     * 
     * Dex缓存文件路径。
     * 
     * @eng
     * 
     * The path of the cache dex file.
     */
    cacheDexFile?: string,
}

interface Java {
    /**
     * @中文
     * 
     * 搜索类名为name为Java类并加载它，返回该Java类。
     * 
     * 返回的Java类实际上是一个javascript的构造函数，通过他可以构造一个Java对象，也可以访问Java类的静态方法。
     * 
     * 如果要搜索内部类，需要使用'$'符号，比如`findClass('android.app.AlertDialog$Builder')`。
     * 
     * 若找不到对应的类，抛出`ClassNotFoundError`。
     * 
     * @param name 完整Java类名
     * 
     * @returns Java类
     * 
     * @eng
     * 
     * Find the Java class with the specified name and load it. Return the Java class.
     * 
     * The returned Java class is actually a javascript constructor function, which can be used to construct a Java object, or access Java class's static methods.
     * 
     * If you want to search inner classes, you need to use '$' symbol, like `findClass('android.app.AlertDialog$Builder')`.
     * 
     * If the class is not found, throw `ClassNotFoundError`.
     * 
     * @param name The full Java class name
     * 
     * @returns Java class
     * 
     * @example
     * ```javascript
     * "nodejs";
     * const $java = $autojs.java;
     * const Integer = $java.findClass('java.lang.Integer');
     * const int = new Integer(255);
     * console.log(Integer.toHexString(int));
     * ```
     */
    findClass(name: string): JavaClass
    /**
     * @中文
     * 
     * 类似于findClass，区别只在于，找不到类时返回null而不是抛出异常。
     * 
     * @param name 类名
     * @returns Java类或者null
     * 
     * @eng
     * 
     * Similar to {@link findClass}, but return null instead of throwing exception when the class is not found.
     * 
     * @param name full java class name
     * @returns Java class or null
     * 
     * @see {@link findClass}
     */
    findClassOrNull(name: string): JavaClass | null

    /**
     * @中文
     * 
     * 在指定在线程上中创建相应的Java对象并返回Promise。例如某些Android UI相关对象需要在UI线程创建。
     *  
     * @param constructor Java类构造函数，若constructor不是Java类构造函数，则抛出TypeError。
     * @param args 构造参数
     * @param threadMode 线程模式
     * 
     * @eng
     * 
     * Create a Java object on the specified thread and return a Promise. For example, some Android UI related objects need to be created on UI thread.
     * 
     * @param constructor Java class constructor, if constructor is not a Java class constructor, throw TypeError.
     * @param args Constructor arguments
     * @param threadMode Thread mode
     * 
     * @example
     * ```javascript
     * "nodejs";
     * const $java = $autojs.java;
     * const View = $java.findClass('android.view.View');
     * const context = $autojs.androidContext;
     * 
     * async function main() {
     *     const view = await $java.create(View, [context], 'ui');
     *     console.log(view);
     * }
     * main();
     */
    create(constructor: JavaClass, args: Array<any>, threadMode: ThreadMode = 'current'): Promise<JavaObject>
    /**
     * @中文
     * 
     * 类似于create，但不返回Promise，而是阻塞等待Java对象创建完成并返回该对象。因此一般不建议使用该函数，除非你清楚你在做什么。
     * 
     * @param constructor Java类构造函数，若constructor不是Java类构造函数，则抛出TypeError。
     * @param args 构造参数
     * @param threadMode 线程模式
     * 
     * @eng
     * 
     * Similar to {@link create}, but wait for the creation blocked and return the Java object instead of returning a Promise. Therefore, this function is usually not recommended to use, unless you know what you are doing.
     * 
     * @param constructor Java class constructor, if constructor is not a Java class constructor, throw TypeError.
     * @param args Constructor arguments
     * @param threadMode Thread mode
     * 
     */
    createSync(constructor: JavaClass, args: Array<any>, threadMode: ThreadMode = 'current'): JavaObject

    /**
     * @中文
     * 
     * 包装相应的JavaScript对象，让其返回的新对象的函数被Java调用时，自动切换到JavaScript所在线程。若`sync`为true，则这些函数会在调用时阻塞等待JavaScript线程返回，并将其值返回给Java。
     * 
     * 通常用于设置一些不在JavaScript线程调用的Java回调。
     * 
     * @param obj JavaScript对象
     * @param sync 是否同步阻塞调用
     * 
     * @eng
     * 
     * Wrap the specified JavaScript object, so that the returned new object's function will be called by Java when it is called. If `sync` is true, the functions will be blocked when they are called, and the return value will be returned to Java.
     * 
     * Usually used to set some Java callbacks that are not called on JavaScript thread.
     * 
     * @param obj JavaScript object
     * @param sync Whether to block the call
     * 
     * @example
     * ```javascript
     * "nodejs";
     * const $java = $autojs.java;
     * const Button = $java.findClass('android.widget.Button');
     * (async () => {
     *     const button = await $java.create(Button, [$autojs.androidContext], 'ui');
     *     $java.setThreadMode(button, 'ui');
     *     button.setOnClickListener($java.wrap(() => {
     *        console.log('click');
     *     }));
     *     button.setOnLongClickListener($java.wrap({
     *          onLongClick: () => {
     *             console.log('long click');
     *             return true;
     *          },
     *     }, true));
     * })();
     * ```
     */
    wrap<T>(obj: T, sync?: Boolean = false): T

    /**
     * @中文
     * 
     * 设置Java对象的线程模式。设置后该Java对象的所有函数调用，均会切换到执行的线程运行，若非当前线程，则这些函数调用会返回Promise。
     * 
     * @param obj Java对象
     * @param threadMode 线程模式
     * 
     * @eng
     * 
     * Set the thread mode of the Java object. After setting, all the function calls of the Java object will be executed on the thread, and if not on the current thread, the function calls will return a Promise.
     * 
     * @param obj Java object
     * @param threadMode Thread mode
     * 
     * @example
     * ```javascript
     * "nodejs";
     * const $java = $autojs.java;
     * const TextView = $java.findClass('android.widget.TextView');
     * (async () => {
     *     const textView = await $java.create(TextView, [$autojs.androidContext], 'ui');
     *     $java.setThreadMode(textView, 'ui');
     *     await textView.setText('Hello World');
     * })();
     * ```
     */
    setThreadMode(obj: JavaObject, threadMode: ThreadMode)

    /**
     * @中文
     * 
     * 设置Java类的默认线程模式。设置后创建该Java类新的Java对象时，默认使用该线程模式。对之前已经创建的Java对象无影响。
     * 
     * @param clazz Java类
     * @param threadMode 线程模式
     * 
     * @eng
     * 
     * Set the default thread mode of the Java class. After creating a new Java object of the Java class, the default thread mode will be used. No effect on the existing Java objects.
     * 
     * @param clazz Java class
     * @param threadMode Thread mode
     * 
     * @example
     * ```javascript
     * "nodejs";
     * const $java = $autojs.java;
     * const View = $java.findClass('android.view.View');
     * $java.setDefaultThreadMode(View, 'ui');
     * ```
     */
    setDefaultThreadMode(clazz: JavaClass, threadMode: ThreadMode)

    /** 
     * @中文
     * 
     * 异步加载Dex文件，加载后该Dex中的类将可以在JavaScript使用。
     * 
     * 注意，务必使用`await`等方式等待加载完成，在加载未完成时，无法访问dex中的Java类。
     * 
     * @param dexFile dex文件路径
     * 
     * @eng
     * 
     * Load the Dex file asynchronously. After loading, the classes in the Dex will be available in JavaScript.
     * 
     * @param dexFile the path of dex file
     * 
     * @example
     * ```javascript
     * "nodejs";
     * const $java = $autojs.java;
     * require('rhino').install();
     * 
     * async function main() {
     *    await $java.loadDex('/sdcard/mydex.dex');
     *    console.log(new com.example.MyClass());
     * }
     * main().catch(console.error);
     * ```
     */
    loadDex(dexFile: string): Promise<void>

    /**
     * @中文
     * 
     * 异步加载jar文件，加载后该jar中的类将可以在JavaScript使用。
     * 
     * 注意，务必使用`await`等方式等待加载完成，在加载未完成时，无法访问jar中的Java类。
     * 
     * 加载jar实际上是通过将jar转为dex后再加载dex实现的，若jar中出现当前运行的Android环境不支持的指令等情况，则会加载失败，因此在有条件的情况下建议事先转换为dex再加载，提高加载效率和成功率。
     * 
     * @param jarFile jar文件路径
     * 
     * @eng
     * 
     * Load the jar file asynchronously. After loading, the classes in the jar will be available in JavaScript.
     * 
     * @param jarFile the path of dex file
     * 
     * @example
     * ```javascript
     * "nodejs";
     * const $java = $autojs.java;
     * require('rhino').install();
     * 
     * async function main() {
     *    await $java.loadJar('/sdcard/myjar.jar');
     *    console.log(new com.example.MyClass());
     * }
     * main().catch(console.error);
     * ```
     */
    loadJar(jarFile: string): Promise<void>

    /**
     * 
     * @中文
     * 
     * 动态从给定的JavaScript类生成一个Java类。可在JavaScript类中覆写父类的方法，实现一些Java接口的方法。通常用于继承抽象类或重写某些类的方法。
     * 
     * 比如可继承`android.webkit.MyWebViewClient`并重写`shouldOverrideUrlLoading`方法拦截请求。
     * 
     * 本方法是动态生成dex实现的，有一定耗时，需要异步等待，第二次调用时可复用上次生成的dex。默认生成的dex文件位于当前目录下的.codecache目录中，可以通过cacheDexFile指定其他路径。
     * 
     * 注意，若只是为了实现Java接口，则无需使用本方法，直接使用类似`new View.OnClickListener({onClick: () => {}})`的方式即可。
     * 
     * @eng
     * 
     * Dynamically generate a Java class from the given JavaScript class. The methods of the parent class can be overridden in the JavaScript class, and implement methods of the Java interface. Usually used to inherit abstract classes or override methods of some classes.
     *
     * For example, you can inherit `android.webkit.MyWebViewClient` and override the `shouldOverrideUrlLoading` method to intercept requests.
     *
     * This method is implemented by dynamically generating dex, which takes a certain amount of time and requires asynchronous waiting. The dex generated last time can be reused in the second call. The dex file generated by default is located in the .codecache directory of the current directory. You can be specified through cacheDexFile option.
     *
     * Note that if you just want to implement Java interfaces, you don't need to use this method, you can directly use something like `new View.OnClickListener({onClick: () => {}})`.
     * 
     * @example
     * ```javascript
     * "nodejs";
     * require('rhino').install();
     * const $java = $autojs.java;
     * 
     * async function main() {
     *   const MyWebViewClient = await $java.defineClass(
     *      class MyWebViewClient extends android.webkit.WebViewClient {
     *          
     *          shouldOverrideUrlLoading(webview, url) {
     *               if (typeof(url) === 'string') {
     *                   console.log(url);
     *               }
     *               return false;
     *          }
     *     }
     *   );
     *   const client = new MyWebViewClient();
     *   // ...
     * }
     * main().catch(console.error);
     * ```
     *
     * 
     * 给定一个JavaScript类，让它继承自某个Java类，并实现给定的Java接口。将生成一个相应的类，从而可在给定的JavaScript类中覆写Java类的相应方法。
     * 
     * @param jsClass JavaScript类
     * @param options 选项，用于指定生成类的包名、要实现的Java接口等。
     */
    defineClass(jsClass: C, options?: DefineClassOptions): Promise<C>

    /**
     * @中文
     * 
     * 包装为java.lang.Boolean的包装类，在调用有重载的Java方法时可以避免混淆，从而确定地调用参数类型为boolean或java.lang.Boolean的方法。
     * 
     * @eng
     * 
     * Wrap value as a wrapper of java.lang.Boolean, which can avoid ambiguous when calling overloaded Java methods, so that method of argument type boolean or java.lang.Boolean can be called certainty.
     * 
     * 
     * @example
     * ```javascript
     * "nodejs";
     * require('rhino').install();
     * const $java = $autojs.java;
     * 
     * const values = new android.content.ContentValues();
     * // public void put(String key, Boolean value)
     * values.put("key", $java.boxBoolean(true));
     * ```
     */
    boxBoolean(value: number): JavaObject

    /**
     * @中文
     * 
     * 包装为java.lang.Byte的包装类，在调用有重载的Java方法时可以避免混淆，从而确定地调用参数类型为byte或java.lang.Byte的方法。
     * 
     * @eng
     * 
     * Wrap value as a wrapper of java.lang.Byte, which can avoid ambiguous when calling overloaded Java methods, so that method of argument type byte or java.lang.Byte can be called certainty.
     * 
     * 
     * @example
     * ```javascript
     * "nodejs";
     * require('rhino').install();
     * const $java = $autojs.java;
     * 
     * const values = new android.content.ContentValues();
     * // public void put(String key, Byte value)
     * values.put("key", $java.boxByte(1));
     * ```
     */
    boxByte(value: number): JavaObject

    /**
     * @中文
     * 
     * 包装为java.lang.Char的包装类，在调用有重载的Java方法时可以避免混淆，从而确定地调用参数类型为char或java.lang.Char的方法。
     * 
     * @eng
     * 
     * Wrap value as a wrapper of java.lang.Char, which can avoid ambiguous when calling overloaded Java methods, so that method of argument type char or java.lang.Char can be called certainty.
     * 
     * 
     * @example
     * ```javascript
     * "nodejs";
     * require('rhino').install();
     * const $java = $autojs.java;
     * 
     * const values = new android.content.ContentValues();
     * // public void put(String key, Char value)
     * values.put("key", $java.boxChar(1));
     * ```
     */
    boxChar(value: number): JavaObject

    /**
     * @中文
     * 
     * 包装为java.lang.Double的包装类，在调用有重载的Java方法时可以避免混淆，从而确定地调用参数类型为double或java.lang.Double的方法。
     * 
     * @eng
     * 
     * Wrap value as a wrapper of java.lang.Double, which can avoid ambiguous when calling overloaded Java methods, so that method of argument type double or java.lang.Double can be called certainty.
     * 
     * @example
     * ```javascript
     * "nodejs";
     * require('rhino').install();
     * const $java = $autojs.java;
     * 
     * const values = new android.content.ContentValues();
     * // public void put(String key, Double value)
     * values.put("key", $java.boxDouble(1));
     * ```
     */
    boxDouble(value: number): JavaObject

    /**
     * @中文
     * 
     * 包装为java.lang.Float的包装类，在调用有重载的Java方法时可以避免混淆，从而确定地调用参数类型为float或java.lang.Float的方法。
     * 
     * @eng
     * 
     * Wrap value as a wrapper of java.lang.Float, which can avoid ambiguous when calling overloaded Java methods, so that method of argument type float or java.lang.Float can be called certainty.
     * 
     * 
     * @example
     * ```javascript
     * "nodejs";
     * require('rhino').install();
     * const $java = $autojs.java;
     * 
     * const values = new android.content.ContentValues();
     * // public void put(String key, Float value)
     * values.put("key", $java.boxFloat(1));
     * ```
     */
    boxFloat(value: number): JavaObject

    /**
     * @中文
     * 
     * 包装为java.lang.Integer的包装类，在调用有重载的Java方法时可以避免混淆，从而确定地调用参数类型为int或java.lang.Integer的方法。
     * 
     * @eng
     * 
     * Wrap value as a wrapper of java.lang.Integer, which can avoid ambiguous when calling overloaded Java methods, so that method of argument type int or java.lang.Integer can be called certainty.
     * 
     * 
     * @example
     * ```javascript
     * "nodejs";
     * require('rhino').install();
     * const $java = $autojs.java;
     * 
     * const values = new android.content.ContentValues();
     * // public void put(String key, Integer value)
     * values.put("key", $java.boxInt(1));
     * ```
     */
    boxInt(value: number): JavaObject

    /**
     * @中文
     * 
     * 包装为java.lang.Long的包装类，在调用有重载的Java方法时可以避免混淆，从而确定地调用参数类型为long或java.lang.Long的方法。
     * 
     * @eng
     * 
     * Wrap value as a wrapper of java.lang.Long, which can avoid ambiguous when calling overloaded Java methods, so that method of argument type long or java.lang.Long can be called certainty.
     *
     * 
     * @example
     * ```javascript
     * "nodejs";
     * require('rhino').install();
     * const $java = $autojs.java;
     * 
     * const values = new android.content.ContentValues();
     * // public void put(String key, Long value)
     * values.put("key", $java.boxLong(1));
     * ``` 
     */
    boxLong(value: number): JavaObject

    /**
     * @中文
     * 
     * 包装为java.lang.Short的包装类，在调用有重载的Java方法时可以避免混淆，从而确定地调用参数类型为short或java.lang.Short的方法。
     * 
     * @eng
     * 
     * Wrap value as a wrapper of java.lang.Short, which can avoid ambiguous when calling overloaded Java methods, so that method of argument type short or java.lang.Short can be called certainty.
     * 
     * 
     * @example
     * ```javascript
     * "nodejs";
     * require('rhino').install();
     * const $java = $autojs.java;
     * 
     * const values = new android.content.ContentValues();
     * // public void put(String key, Short value)
     * values.put("key", $java.boxShort(1));
     * ```
     */
    boxShort(value: number): JavaObject
}

/**
 * @中文
 * 
 * 全局变量$autojs，用于提供autojs环境的特殊API。比如是否是Auto.js打包后环境。
 * 
 * @eng
 * 
 * $autojs, a global variable to provide special API for autojs environment. For example, check if is release mode.
 */
declare const $autojs: AutoJs;


/**
 * @中文
 * 
 * 全局变量，想当于`$autojs.java`。用于提供Java交互的API。这些API比较原始，建议使用封装后的java模块和rhino模块。
 * 
 * @eng
 * 
 * raw APIs for Java interop. Recommended to use java and rhino modules instead.
 */
declare const $java: Java;

declare type JavaClass = any;
declare type JavaObject = any;

declare namespace NodeJS {
    interface ProcessVersions {
        autojspro: string;
    }
}


/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
declare module "ui_object" {
    /**
     * @中文
     *
     * UI控件对象。可通过该对象对控件做出操作，或获取控件的信息，或者获取到其相邻的其它控件对象。
     *
     * @eng
     *
     * UI control object. Can operate the control by this object, or get the information of the control, or get the adjacent control object.
     *
     */
    export abstract class UiObject {
        /**
         * @中文
         *
         * Java中的控件对象。
         *
         * @eng
         *
         * Java ui object instance.
         */
        protected javaObject: any;
        /**
         * @中文
         *
         * 获取控件所在布局的根布局控件。
         *
         * @eng
         *
         * The root widget of the layout that the widget is in.
         */
        readonly root: UiObject;
        /**
         * @中文
         *
         * 获取控件的父控件。最外层控件的父控件为null。
         *
         * @eng
         *
         * Get the parent widget of the widget. The parent of the outermost widget is null.
         */
        readonly parent?: UiObject;
        /**
         * @中文
         *
         * 获取控件的深度。
         *
         * @eng
         *
         * Get the depth of the widget.
         */
        readonly depth: number;
        /**
         * @中文
         *
         * 获取控件在父控件中的索引。从0开始。
         *
         * @eng
         *
         * Get the index of the widget in the parent widget. From 0.
         */
        readonly indexInParent: number;
        /**
         * @中文
         *
         * 构造UI控件。
         *
         * @param javaObject Java控件对象。
         * @param depth 控件深度。
         * @param indexInParent 控件在父控件中的索引。
         * @param root 根布局控件。
         * @param parent 父控件。
         *
         * @eng
         *
         * Construct UI Widget.
         *
         * @param javaObject Java ui object instance.
         * @param depth depth of the widget.
         * @param indexInParent index of the widget in the parent widget.
         * @param root root widget of the layout that the widget is in.
         * @param parent parent widget.
         */
        constructor(javaObject: any, depth: number, indexInParent: number, root?: UiObject, parent?: UiObject);
        /**
         * @中文
         *
         * 子控件的列表。
         *
         * @eng
         *
         * Get the list of the child widgets.
         */
        abstract get children(): Array<UiObject>;
        /**
         * @中文
         *
         * 子控件的数量
         *
         * @eng
         *
         * Get the number of the child widgets.
         */
        abstract get childCount(): number;
        /**
         * @中文
         *
         * 控件的类名
         *
         * @eng
         *
         * Get the class name of the widget.
         */
        abstract get className(): string;
        /**
         * @中文
         *
         * 控件所在应用的包名
         *
         * @eng
         *
         * Get the package name of the widget's application.
         */
        abstract get packageName(): string;
        /**
         * @中文
         *
         * 控件的文本内容
         *
         * @eng
         *
         * Get the text content of the widget.
         */
        abstract get text(): string;
        /**
         * @中文
         *
         * 控件的描述信息
         *
         * @eng
         *
         * Get the description of the widget.
         */
        abstract get desc(): string;
        /**
         * @中文
         *
         * 控件的id。
         *
         * @eng
         *
         * Get the id of the widget.
         */
        abstract get id(): string;
        /**
         * @中文
         *
         * 控件的完整id。在前方会有应用的页面信息。
         *
         * @eng
         *
         * Get the full id of the widget. The id will be prefixed with the page info.
         */
        abstract get fullId(): string;
        /**
         * @中文
         *
         * 控件所在的窗口id。
         *
         * @eng
         *
         * Get the window id of the widget.
         */
        abstract get windowId(): number;
        /**
         * @中文
         *
         * 控件在父控件中的绘制顺序。通常可用于区分同一个层次的控件。
         *
         * @eng
         *
         * Get the drawing order of the widget in the parent widget.
         */
        abstract get drawingOrder(): number;
        /**
         * @中文
         *
         * 控件在屏幕中的边框位置。
         *
         * @eng
         *
         * Get the position of the widget in the screen.
         */
        abstract get boundsInScreen(): Rect;
        /***
         * @中文
         *
         * 控件可用的额外数据。
         *
         * @eng
         *
         * Get the extra data of the widget.
         */
        abstract get availableExtraData(): Array<string>;
        /**
         * @中文
         *
         * 控件的最大文本长度。
         *
         * @eng
         *
         * Get the maximum length of the text of the widget.
         */
        abstract get maxTextLength(): number;
        /**
         * @中文
         *
         * 控件是否可被点击。
         *
         * @eng
         *
         * Get whether the widget is clickable.
         */
        abstract get clickable(): boolean;
        /**
         * @中文
         *
         * 控件是否可被勾选。
         *
         * @eng
         *
         * Get whether the widget is checkable.
         */
        abstract get checkable(): boolean;
        /**
         * @中文
         *
         * 控件是否已被勾选。
         *
         * @eng
         *
         * Get whether the widget is checked.
         */
        abstract get checked(): boolean;
        /**
         * @中文
         *
         * 控件是否可获取焦点。
         *
         * @eng
         *
         * Get whether the widget is focusable.
         */
        abstract get focusable(): boolean;
        /**
         * @中文
         *
         * 控件是否已获取焦点。
         *
         * @eng
         *
         * Get whether the widget is focused.
         */
        abstract get focused(): boolean;
        /**
         * @中文
         *
         * 控件是否可见。
         *
         * @eng
         *
         * Get whether the widget is visible.
         */
        abstract get visibleToUser(): boolean;
        /***
         * @中文
         *
         * 控件是否处于无障碍焦点。
         *
         * @eng
         *
         * Get whether the widget is in accessibility focus.
         */
        abstract get accessibilityFocused(): boolean;
        /**
         * @中文
         *
         * 控件是否选中。被选中指的是，例如QQ聊天界面点击下方的"表情按钮"时，会出现自己收藏的表情，这时"表情按钮"便处于选中状态，其selected属性为true。
         *
         * @eng
         *
         * Get whether the widget is selected. Selected means that the widget is in a selected state, such as the "Emoji button" in QQ chat.
         */
        abstract get selected(): boolean;
        /**
         * @中文
         *
         * 控件是否可被长按
         *
         * @eng
         *
         * Get whether the widget is long clickable.
         */
        abstract get longClickable(): boolean;
        /**
         * @中文
         *
         * 控件是否已启用。大多数控件都是启用的状态(enabled为true)，处于“禁用”状态通常是灰色并且不可点击。
         *
         * @eng
         *
         * Get whether the widget is enabled. Most widgets are enabled by default (enabled is true), but some widgets are disabled.
         */
        abstract get enabled(): boolean;
        /***
         * @中文
         *
         * 输入类型是否为密码。密码输入框中内容会用星号代替。
         *
         * @eng
         *
         * Get whether the input type is password. Password input boxes will display asterisks instead of the actual text.
         */
        abstract get isPassword(): boolean;
        /**
         * @中文
         *
         * 控件是否可滑动。
         *
         * @eng
         *
         * Get whether the widget is scrollable.
         */
        abstract get scrollable(): boolean;
        /**
         * @中文
         *
         * 控件是否可编辑。
         *
         * @eng
         *
         * Get whether the widget is editable.
         */
        abstract get editable(): boolean;
        /***
         * @中文
         *
         * 控件所在窗口的标题。
         *
         * @eng
         *
         * Get the title of the window that the widget is in.
         */
        abstract get paneTitle(): boolean;
        /**
         * @中文
         *
         * 控件的内容是否无效。例如，日期格式不正确。
         *
         * @eng
         *
         * Get whether the content of the widget is invalid. For example, the date format is incorrect.
         */
        abstract get contentInvalid(): boolean;
        /**
         * @中文
         *
         * 控件是否可在上下文中点击
         *
         * @eng
         *
         * Get whether the widget is clickable in the context.
         */
        abstract get contextClickable(): boolean;
        /**
         * @中文
         *
         * 控件是否为多行可编辑文本。
         *
         * @eng
         *
         * Get whether the widget is a multi-line editable text.
         */
        abstract get isMultiLine(): boolean;
        /**
         * @中文
         *
         * 控件是否可打开弹窗。
         *
         * @eng
         *
         * Get whether the widget can open a popup.
         */
        abstract get canOpenPopup(): boolean;
        /***
         * @中文
         *
         * 控件是否可以关闭。
         *
         * @eng
         *
         * Get whether the widget can close the node.
         */
        abstract get dismissable(): boolean;
        /**
         * @中文
         *
         * 控件的输入类型。
         *
         * @see https://developer.android.com/reference/android/text/InputType
         *
         * @eng
         *
         * Get the input type of the widget.
         *
         * @see https://developer.android.com/reference/android/text/InputType?hl=en
         */
        abstract get inputType(): number;
        /**
         * @中文
         *
         * 控件中选中文本的起始位置。
         *
         * @eng
         *
         * Get the start position of the selected text in the widget.
         */
        abstract get textSelectionStart(): number;
        /**
         * @中文
         *
         * 控件中选中文本的结束位置。
         *
         * @eng
         *
         * Get the end position of the selected text in the widget.
         */
        abstract get textSelectionEnd(): number;
        /**
         * @中文
         *
         * 控件的工具提示文本。
         *
         * @eng
         *
         * Get the tooltip text of the widget.
         */
        abstract get tooltipText(): string;
        /**
         * @中文
         *
         * 控件的错误信息文本。
         *
         * @eng
         *
         * Get the error text of the widget.
         */
        abstract get error(): string;
        /**
         * @中文
         *
         * 控件的提示文本。
         *
         * @eng
         *
         * Get the hint text of the widget.
         */
        abstract get hintText(): string;
        /***
         * @中文
         *
         * 控件的原始文本
         *
         * @eng
         *
         * Get the original text of the widget.
         */
        abstract get originalText(): string;
        /**
         * @中文
         *
         * 控件是否为键盘或小键盘中的文本输入键。
         *
         * @eng
         *
         * Get whether the widget is a text input key in the keyboard or the small keyboard.
         */
        abstract get isTextEntryKey(): boolean;
        /**
         * @中文
         *
         * 控件是否代表标题
         *
         * @eng
         *
         * Get whether the widget is a head title.
         */
        abstract get isHeading(): boolean;
        /**
         * @中文
         *
         * 控件是否正显示提示文本。
         *
         * @eng
         *
         * Get whether the widget is showing hint text.
         */
        abstract get showingHintText(): boolean;
        /***
         * @中文
         *
         * 屏幕阅读器是否应将该控件视为可聚焦单元。
         *
         * @eng
         *
         * Get whether the widget is a focusable unit in the screen reader.
         */
        abstract get screenReaderFocusable(): boolean;
        /**
         * @中文
         *
         * 控件自认为是否关键。
         *
         * @eng
         *
         * Get whether the widget is important.
         */
        abstract get isImportantForAccessibility(): boolean;
        /**
         * @中文
         *
         * 获取节点的活动区域模式。
         *
         * 活动区域是包含用户重要信息的区域，当它发生变化时，会通知用户。
         * 例如，在带有显示“密码错误”通知的 TextView 的登录屏幕中，控件会标记活动区域为 View#ACCESSIBILITY_LIVE_REGION_POLITE
         *
         * @eng
         *
         * Get the active region mode of the node.
         *
         * The active region is the region that contains important information, and when it changes, it will notify the user.
         * For example, in the login screen of a screen with a TextView that displays a "password error" notification, the widget will mark the active region as View#ACCESSIBILITY_LIVE_REGION_POLITE.
         */
        abstract get liveRegion(): number;
        /**
         * @中文
         *
         * 点击该控件。
         *
         * 如果该函数返回false，可能是该控件不可点击(clickable为false)，当前界面无法响应该点击等（这种情况下可以使用clickCenter()代替）。
         *
         * @returns 是否点击成功。
         *
         * @eng
         *
         * Click the widget.
         *
         * If the function returns false, it may be that the widget is not clickable (clickable is false), or the current screen cannot respond to the click such as the widget is not visible or the widget is not enabled.
         *
         * @returns Whether the click is successful.
         */
        abstract click(): boolean;
        /**
         * @中文
         *
         * 长按该控件。
         *
         * @returns 是否长按成功。
         *
         * @eng
         *
         * Long press the widget.
         *
         * @returns Whether the long press is successful.
         */
        abstract longClick(): boolean;
        /**
         * @中文
         *
         * 获取焦点。
         *
         * @returns 是否获取成功。
         *
         * @eng
         *
         * Get focus.
         *
         * @returns Whether the focus is successful.
         */
        abstract focus(): boolean;
        /**
         * @中文
         *
         * 清除焦点。
         *
         * @returns 是否清除成功。
         *
         * @eng
         *
         * Clear focus
         *
         * @returns Whether the clear is successful.
         */
        abstract clearFocus(): boolean;
        /**
         * @中文
         *
         * 选中文本
         *
         * @param start 选中的开始位置
         * @param end 选中的结束位置
         *
         * @returns 是否选中成功。
         *
         * @eng
         *
         * Select text
         *
         * @param start The start position of the selection
         * @param end The end position of the selection
         *
         * @returns Whether the selection is successful.
         */
        abstract setSelection(start: number, end: number): boolean;
        /**
         * @中文
         *
         * 选用该控件
         *
         * @returns 是否选中成功。
         *
         * @eng
         *
         * Select the widget
         *
         * @returns Whether the selection is successful.
         */
        abstract select(): boolean;
        /**
         * @中文
         *
         * 取消选用该控件
         *
         * @returns 是否取消选中成功。
         *
         * @eng
         *
         * Unselect the widget
         *
         * @returns Whether the unselection is successful.
         */
        abstract clearSelection(): boolean;
        /**
         * @中文
         *
         * 获取无障碍焦点。
         *
         * @returns 是否获取成功。
         *
         * @eng
         *
         * Get accessibility focus.
         *
         * @returns Whether the focus is successful.
         */
        abstract accessibilityFocus(): boolean;
        /**
         * @中文
         *
         * 清除无障碍焦点
         *
         * @returns 是否清除成功。
         *
         * @eng
         *
         * Clear accessibility focus
         *
         * @returns Whether the clear is successful.
         */
        abstract clearAccessibilityFocus(): boolean;
        /**
         * @中文
         *
         * 向前滚动。(一般为向下或向右)
         *
         * @returns 是否滚动成功。
         *
         * @eng
         *
         * Scroll forward. (Usually down or right)
         *
         * @returns Whether the scroll is successful.
         */
        abstract scrollForward(): boolean;
        /**
         * @中文
         *
         * 向后滚动。(一般为向上或向左)
         *
         * @returns 是否滚动成功。
         *
         * @eng
         *
         * Scroll backward. (Usually up or left)
         *
         * @returns Whether the scroll is successful.
         */
        abstract scrollBackward(): boolean;
        /***
         * @中文
         *
         * 将当选选中文本复制到剪贴板。
         *
         * @returns 是否复制成功。
         *
         * @eng
         *
         * Copy the selected text to the clipboard.
         *
         * @returns Whether the copy is successful.
         */
        abstract copy(): boolean;
        /**
         * @中文
         *
         * 粘贴内容到该控件。
         *
         * @returns 是否粘贴成功。
         *
         * @eng
         *
         * Paste the content to the widget.
         *
         * @returns Whether the paste is successful.
         */
        abstract paste(): boolean;
        /***
         * @中文
         *
         * 将当前选中文本剪切到剪贴板。
         *
         * @returns 是否剪切成功。
         *
         * @eng
         *
         * Cut the selected text to the clipboard.
         *
         * @returns Whether the cut is successful.
         */
        abstract cut(): boolean;
        /**
         * @中文
         *
         * 展开控件。
         *
         * @returns 是否展开成功。
         *
         * @eng
         *
         * Expend the widget
         *
         * @returns Whether to expend is successful.
         */
        abstract expand(): boolean;
        /***
         * @中文
         *
         * 折叠控件
         *
         * @returns 是否折叠成功。
         *
         * @eng
         *
         * Collapse the widget
         *
         * @returns Whether to collapse is successful.
         */
        abstract collapse(): boolean;
        /***
         * @中文
         *
         * 关闭控件。
         *
         * @returns 是否关闭成功。
         *
         * @eng
         *
         * Dismiss the widget
         *
         * @returns Whether to dismiss is successful.
         */
        abstract dismiss(): boolean;
        /**
         * @中文
         *
         * 输入文本。
         *
         * @param text 要输入的文本内容。
         *
         * @returns 是否输入成功。
         *
         * @eng
         *
         * Input text.
         *
         * @param text The text content to be input.
         *
         * @returns Whether the input is successful.
         */
        abstract setText(text: string): boolean;
        /**
         * @中文
         *
         * 显示到屏幕上。
         *
         * @returns 是否显示成功。
         *
         * @eng
         *
         * Show to the screen.
         *
         * @returns Whether to show is successful.
         */
        abstract showOnScreen(): boolean;
        /**
         * @中文
         *
         * 滚动到指定位置。
         *
         * @param position 需滚动到的位置
         *
         * @returns 是否滚动成功。
         *
         * @eng
         *
         * Scroll the widget to the input position.
         *
         * @param position The position to scroll to.
         *
         * @returns Whether the scroll is successful.
         */
        abstract scrollToPosition(position: number): boolean;
        /**
         * @中文
         *
         * 向上滚动
         *
         * @returns 是否滚动成功。
         *
         * @eng
         *
         * Scroll up.
         *
         * @returns Whether the scroll is successful.
         */
        abstract scrollUp(): boolean;
        /**
         * @中文
         *
         * 向下滚动
         *
         * @returns 是否滚动成功。
         *
         * @eng
         *
         * Scroll down.
         *
         * @returns Whether the scroll is successful.
         */
        abstract scrollDown(): boolean;
        /**
         * @中文
         *
         * 向左滚动
         *
         * @returns 是否滚动成功。
         *
         * @eng
         *
         * Scroll left.
         *
         * @returns Whether the scroll is successful.
         */
        abstract scrollLeft(): boolean;
        /**
         * @中文
         *
         * 向右滚动
         *
         * @returns 是否滚动成功。
         *
         * @eng
         *
         * Scroll right.
         *
         * @returns Whether the scroll is successful.
         */
        abstract scrollRight(): boolean;
        /***
         * @中文
         *
         * 向上翻页。
         *
         * @returns 是否翻页成功。
         *
         * @eng
         *
         * Page up.
         *
         * @returns Whether the page is successful.
         */
        abstract pageUp(): boolean;
        /***
         * @中文
         *
         * 向下翻页。
         *
         * @returns 是否翻页成功。
         *
         * @eng
         *
         * Page down.
         *
         * @returns Whether the page is successful.
         */
        abstract pageDown(): boolean;
        /***
         * @中文
         *
         * 向左翻页。
         *
         * @returns 是否翻页成功。
         *
         * @eng
         *
         * Page left.
         *
         * @returns Whether the page is successful.
         */
        abstract pageLeft(): boolean;
        /**
         * @中文
         *
         * 向右翻页。
         *
         * @returns 是否翻页成功。
         *
         * @eng
         *
         * Page right.
         *
         * @returns Whether the page is successful.
         */
        abstract pageRight(): boolean;
        /**
         * @中文
         *
         * 点击上下文。
         *
         * @returns 是否点击成功。
         *
         * @eng
         *
         * Click the context.
         *
         * @returns Whether the click is successful.
         */
        abstract contextClick(): boolean;
        /**
         * @中文
         *
         * 回收控件。
         *
         * @eng
         *
         * Recycle the widget.
         */
        recycle(): void;
        /**
         * @中文。
         *
         * 刷新控件
         *
         * @eng
         *
         * Refresh the widget.
         */
        refresh(): void;
        /***
         * @中文
         *
         *
         *
         * @eng
         *
         *
         *
         */
        tree(): Array<UiObject>;
    }
    /**
     * @中文
     *
     * 矩形类。表示一个矩形范围。
     *
     * @eng
     *
     * Rectangle class. Represents a rectangle range.
     *
     */
    export class Rect {
        /**
         * @中文
         *
         * 矩形左上角的X坐标。
         *
         * @eng
         *
         * The X coordinate of the top left corner of the rectangle.
         */
        left: number;
        /**
         * @中文
         *
         * 矩形左上角的Y坐标。
         *
         * @eng
         *
         * The Y coordinate of the top left corner of the rectangle.
         */
        top: number;
        /**
         * @中文
         *
         * 矩形右下角的X坐标。
         *
         * @eng
         *
         * The X coordinate of the bottom right corner of the rectangle.
         */
        right: number;
        /**
         * @中文
         *
         * 矩形右下角的Y坐标。
         *
         * @eng
         *
         * The Y coordinate of the bottom right corner of the rectangle.
         */
        bottom: number;
        /**
         * @中文
         *
         * 构造矩矩形对象。
         *
         * @param left 左上角的X坐标。
         * @param top 左上角的Y坐标。
         * @param right 右下角的X坐标。
         * @param bottom 右下角的Y坐标。
         *
         * @eng
         *
         * Construct a rectangle object.
         *
         * @param left The X coordinate of the top left corner of the rectangle.
         * @param top The Y coordinate of the top left corner of the rectangle.
         * @param right The X coordinate of the bottom right corner of the rectangle.
         * @param bottom The Y coordinate of the bottom right corner of the rectangle.
         */
        constructor(left: number, top: number, right: number, bottom: number);
        /**
         * @中文
         *
         * 从Java矩形构造矩形。
         *
         * @param javaRect Java矩形。
         *
         * @eng
         *
         * Construct a rectangle from a Java rectangle.
         *
         * @param javaRect Java rectangle.
         */
        static fromJava(javaRect: any): Rect;
        /**
         * @中文
         *
         * 获取矩形的宽度。
         *
         * @eng
         *
         * Get the width of the rectangle.
         */
        get width(): number;
        /**
         * @中文
         *
         * 获取矩形的高度。
         *
         * @eng
         *
         * Get the height of the rectangle.
         */
        get height(): number;
        /**
         * @中文
         *
         * 获取矩形的中心点X坐标。
         *
         * @eng
         *
         * Get the X coordinate of the center of the rectangle.
         */
        get centerX(): number;
        /**
         * @中文
         *
         * 获取矩形的中心点Y坐标。
         *
         * @eng
         *
         * Get the Y coordinate of the center of the rectangle.
         */
        get centerY(): number;
        /**
         * @中文
         *
         * 排序矩形属性。
         *
         * 当left值大于right值，或者top值大于bottom值时，将其交换。
         *
         * @returns 排序后的矩形。
         *
         * @eng
         *
         * Sort the rectangle properties.
         *
         * When left value is greater than right value, or top value is greater than bottom value, swap them.
         *
         * @returns Sorted rectangle.
         */
        sort(): Rect;
    }
}
declare module "toast" {
    export interface ToastOptions {
        log?: boolean | string;
        duration?: 'short' | 'long';
    }
    /**
     *
     * @中文
     *
     * 显示Toast气泡信息。在部分系统上，在后台无法显示Toast，或者需要开启通知权限才能显示Toast。
     *
     * > 注意！连续显示多个Toast时，Toast会排队显示，即使脚本已经结束，Toast可能仍然会显示。
     *
     * @param msg Toast文本
     * @param options Toast时长，默认为short。short为短时长，long为长时长（不同系统可能有不同的具体时长）
     *
     * @eng
     *
     * Show a Toast message. Some system may not show Toast in background, or need to grant notification permission to show Toast.
     *
     * > Note! Multiple Toast will be queued, even if the script is terminated, Toast may still be shown.
     *
     * @param msg Toast text
     * @param options Toast duration, default is short. Different system may have different specific duration for 'short' and 'long'.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { showToast } = require('toast');
     * showToast('Hello world!');
     * ```
     */
    export function showToast(msg: any, options?: 'short' | 'long' | ToastOptions): void;
}
declare module "java_utils" {
    export function toStringOr(javaObject?: any, def?: string): string | undefined;
    export function toStringOrEmpty(javaObject?: any): string;
    export function javaListToArray<T>(javaList?: any): Array<T> | null;
    export function javaSetToArray(javaSet?: any): Array<any> | null;
    export function javaMapToObject(obj: any, javaMap?: any, valueTransform?: ((value: any) => any)): any | null;
    export function objectToJavaMap(obj: any, valueTransform?: ((value: any) => any)): JavaObject;
    export function bufferToByteArray(buffer: Buffer): JavaObject;
}
declare module "lang" {
    /**
     * @中文
     *
     * TypeScript装饰器，在JavaScript中无法使用。
     *
     * 用于装饰类的getter属性，装饰后的属性在第一个调用时会被自动执行并保存值，以后调用时会使用之前保存的值。
     *
     * @eng
     *
     * TypeScript decorator, which cannot be used in JavaScript.
     *
     * Decorates class's getter properties, and the decorated properties will be automatically executed and saved the value on the first call, and then use the saved value on subsequent calls.
     *
     * @example
     * ```typescript
     * import { lazy } from 'lang'
     *
     * class Sum {
     *    private n: number;
     *
     *    constructor(n: number) {
     *      this.n = n;
     *    }
     *
     *    @lazy
     *    get sum() {
     *      console.log('calculating sum...');
     *      let result = 0;
     *      for (let i = 0; i < this.n; i++) {
     *           result += i;
     *      }
     *      return result;
     *    }
     * }
     *
     * const sum = new Sum(10);
     * console.log(sum.sum); // calculating sum...55
     * console.log(sum.sum); // 55
     * ```
     *
     */
    export function lazy(target: any, name: string, { get: initializer, enumerable, configurable, set: setter }?: PropertyDescriptor): any;
    export interface ReadOnlyProperty<T> {
        get(): T;
    }
    export function lazyProp<T>(evaluator: () => T): ReadOnlyProperty<T>;
    /**
     * @中文
     *
     * 创建一个Promise，与`new Promise`类似，唯一不同的是在此Promise状态在pending状态时（也即resolve/reject之前），autojs会保持引擎不退出。
     *
     * 由于nodejs并不感知Java的一些异步API的执行，此函数通常用于创建和Java API相关的Promise，在Java API返回之前保持程序运行。
     *
     * @param executor
     * @returns
     *
     * @eng
     *
     * Creates a Promise, which is similar to `new Promise`, but it will keep the engine running when the Promise is in the pending state (before resolve/reject).
     *
     * Because nodejs does not know the asynchronous behavior of Java APIs, this function is usually used to create a Promise for a Java API, and keep the engine running until the Java API returns.
     *
     * @param executor
     * @returns
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { promise } = require('lang');
     * const { android } = require('android');
     *
     * function loadAudioAsync(file) {
     *   const SoundPool = android.media.SoundPool;
     *   return promise(function (resolve) {
     *      const soundPool = new SoundPool(1, SoundPool.STREAM_MUSIC, 0);
     *      soundPool.setOnLoadCompleteListener($autojs.java.wrap(() => resolve(soundPool)));
     *      soundPool.load(file, 1);
     *   });
     * }
     *
     * ```
     */
    export function promise<T>(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;
    /**
     * @中文
     *
     * 返回一个Promise，将在timeout时间后resolve。例如`await delay(1000)`会在1秒后执行。不同于Pro 8的`sleep()`，此函数并不会真正阻塞线程/事件循环。
     *
     * @param timeout 超时时间，若小于或等于0，则此函数返回一个立即resolve的Promise。
     * @returns
     *
     * @eng
     *
     * Returns a Promise, which will resolve after timeout. For example, `await delay(1000)` will resolve after 1 second. This function does not block the thread/event loop.
     *
     * @param timeout timeout, if less than or equal to 0, then the function returns a Promise that resolves immediately.
     * @returns
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { delay } = require('lang');
     * async function main() {
     *   console.log(1);
     *   await delay(2000);
     *   console.log(2);
     * }
     * main();
     * ```
     *
     */
    export function delay(timeout: number): Promise<void>;
    /**
     * @中文
     *
     * Deferred类，用于创建Promise的延迟对象，而无需使用`new Promise`。通过resolve或reject函数可以设置Promise的状态。
     *
     * @eng
     *
     * A Deferred that can be completed via public functions resolve or reject. Unlike the Promise class, this class does not require the `new` keyword.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { Deferred } = require('lang');
     * async function main() {
     *     console.log(await add(1, 2));
     * }
     * main();
     *
     * function add(a, b) {
     *     const d = new Deferred();
     *     setTimeout(() => {
     *         d.resolve(a + b);
     *     }, 1000);
     *     return d.promise();
     * }
     */
    export class Deferred<T> {
        private resolver?;
        private rejecter?;
        private finished;
        private _value?;
        private keepRunningId?;
        private _promise;
        constructor(keepRunning?: boolean);
        /**
         * @中文
         *
         * 使用给定的值设置Promise的状态为fulfilled。若已经是fulfilled或rejected状态，则返回false。
         *
         * @eng
         *
         * Sets the state of the Promise to fulfilled using the given value. If the Promise is already fulfilled or rejected, returns false.
         *
         */
        resolve(value: T): boolean;
        /**
         * @中文
         *
         * 使用给定的reason作为原因或异常设置Promise的状态为rejected。若已经resolved或rejected状态，则返回false。
         *
         * @eng
         *
         * Sets the state of the Promise to rejected using the given reason or exception. If the Promise is already fulfilled or rejected, returns false.
         */
        reject(reason?: any): boolean;
        private finish;
        promise(): Promise<T>;
        /**
         * @中文
         *
         * 获取Deferred的值，如果为pending或rejected状态，则返回undefined。
         *
         * @eng
         *
         * Gets the value of the Deferred, if it is pending or rejected, then returns undefined.
         */
        get value(): T | undefined;
    }
    export class TimeoutError extends Error {
    }
}
declare module "lazy_ui_object" {
    import { UiObject, Rect } from "ui_object";
    import { inspect } from 'util';
    export class LazyUiObject extends UiObject {
        private _children?;
        constructor(javaObject: any, depth: number, indexInParent: number, root?: UiObject, parent?: UiObject);
        get children(): UiObject[];
        get childCount(): number;
        get className(): string;
        get packageName(): string;
        get text(): string;
        get desc(): string;
        get id(): string;
        get fullId(): string;
        get windowId(): number;
        get drawingOrder(): number;
        get boundsInScreen(): Rect;
        get availableExtraData(): string[];
        get maxTextLength(): number;
        get clickable(): boolean;
        get checkable(): boolean;
        get checked(): boolean;
        get focusable(): boolean;
        get focused(): boolean;
        get visibleToUser(): boolean;
        get accessibilityFocused(): boolean;
        get selected(): boolean;
        get longClickable(): boolean;
        get enabled(): boolean;
        get isPassword(): boolean;
        get scrollable(): boolean;
        get editable(): boolean;
        get paneTitle(): boolean;
        get contentInvalid(): boolean;
        get contextClickable(): boolean;
        get isMultiLine(): boolean;
        get canOpenPopup(): boolean;
        get dismissable(): boolean;
        get inputType(): number;
        get textSelectionStart(): number;
        get textSelectionEnd(): number;
        get tooltipText(): string;
        get error(): string;
        get hintText(): string;
        get originalText(): string;
        get isTextEntryKey(): boolean;
        get isHeading(): boolean;
        get showingHintText(): boolean;
        get screenReaderFocusable(): boolean;
        get isImportantForAccessibility(): boolean;
        get liveRegion(): number;
        click(): boolean;
        longClick(): boolean;
        focus(): boolean;
        clearFocus(): boolean;
        setSelection(start: number, end: number): boolean;
        select(): boolean;
        clearSelection(): boolean;
        accessibilityFocus(): boolean;
        clearAccessibilityFocus(): boolean;
        scrollForward(): boolean;
        scrollBackward(): boolean;
        copy(): boolean;
        paste(): boolean;
        cut(): boolean;
        expand(): boolean;
        collapse(): boolean;
        dismiss(): boolean;
        setText(text: string): boolean;
        showOnScreen(): boolean;
        scrollToPosition(position: number): boolean;
        scrollUp(): boolean;
        scrollDown(): boolean;
        scrollLeft(): boolean;
        scrollRight(): boolean;
        pageUp(): boolean;
        pageDown(): boolean;
        pageLeft(): boolean;
        pageRight(): boolean;
        contextClick(): boolean;
        toString(): string;
        [inspect.custom](): string;
        private performAction;
        private performActionWithExtras;
        static createRoot(rootJavaObject: any): LazyUiObject;
        static createRootOrNull(rootJavaObject: any | null | undefined): LazyUiObject | null;
    }
}
declare module "rhino" {
    /**
     * @中文
     *
     * 在作用域中安装兼容于[Rhino引擎](https://pro.autojs.org/docs/#/zh-cn/scriptingJava)中Java交互相关的变量和函数，当前支持：
     * * `Packages`变量，用于访问Java包或类
     * * `java`, `javax`, `org`, `com`, `edu`, `net`, `android`等包，用于访问常见的Java包和类
     * * `JavaAdapter`类，用于在JavaScript中实现Java类或接口的动态继承。**当前版本尚不不支持，使用时会抛出异常**
     *
     * 不支持`importClass`和`importPackage`函数，请直接用赋值语句代替。
     *
     *
     * @param scope 作用域，默认为global全局作用域
     *
     * @eng
     *
     * Install compatibility variables and functions for [Rhino engine](https://pro.autojs.org/docs/#/zh-cn/scriptingJava) Java interaction, currently supports:
     * * `Packages` variable, to access Java package or class
     * * `java`, `javax`, `org`, `com`, `edu`, `net`, `android` packages, to access common Java packages and classes
     * * `JavaAdapter` class, to implement Java class or interface dynamically in JavaScript. **Currently not supported, will be supported in a future version**
     *
     * Not supported `importClass` and `importPackage` functions, please use assignment statement instead.
     *
     * @example
     * ```javascript
     * "nodejs";
     * require("rhino").install();
     *
     * const View = android.view.View;
     * const StringBuilder = java.lang.StringBuilder;
     *
     * console.log(View.class.getName());
     * console.log(new StringBuilder().append("Hello").toString());
     *
     * ```
     */
    export function install(scope?: any): void;
    /**
     * @中文
     *
     * 用于访问Java包或类。比如`Packages.java`或`Packages.kotlin`。
     *
     * @eng
     *
     * Variable to access Java package or class. For example, `Packages.java` or `Packages.kotlin`.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { Packages } = require("rhino");
     *
     * const OkHttpClient = Packages.okhttp3.OkHttpClient;
     * const client = new OkHttpClient.Builder().build();
     *
     * console.log(client);
     * ```
     */
    export const Packages: JavaPackages;
}
declare module "engines" {
    /**
     * @中文
     *
     * engines模块提供了获取自身引擎、运行参数、运行配置的方法，以及获取其他引擎、启动新引擎、控制其他引擎、和其他引擎通信的功能。
     *
     * @eng
     *
     * The engines module provides methods to get the current engine, arguments, and configuration of current engine, and functions to get other engines, start new engines, control other engines, and communicate with other engines.
     *
     * @packageDocumentation
     */
    import { EventEmitter } from "events";
    export interface ReadOnlyExecutionConfig {
        readonly workingDirectory: string;
        readonly path: Array<String>;
        readonly projectConfig?: any;
    }
    /**
     * @中文
     *
     * 脚本引擎对象，表示一次脚本或项目执行的引擎示例。可以通过引擎和跨脚本通信，获取引擎的状态，停止引擎运行等。
     *
     * @eng
     *
     * Script engine object, represents an engine instance of a script or project running. It can be used to communicate with other engines and scripts, get engine status, stop engine running, etc.
     */
    export interface ScriptEngine {
        /**
         * @中文
         *
         * 引擎的唯一id，不同引擎的id必不相同。
         *
         * @eng
         *
         * Unique id of engine, different from other engine's id.
         */
        readonly id: number;
        /**
         * @中文
         *
         * 引擎运行的所在目录。一般是项目的根目录或者脚本文件的父目录。
         *
         * @eng
         *
         * Directory of engine running. Usually is the root directory of project or the parent directory of script file.
         */
        readonly workingDirectory: string;
        /**
         * @中文
         *
         * 引擎源文件的对象。
         *
         * @eng
         *
         * Source file object of engine.
         */
        readonly source: any;
        /**
         * @中文
         *
         * 引擎的源文件路径。
         *
         * @eng
         *
         * Path of engine source file.
         */
        readonly sourceFile: string;
        /**
         * @中文
         *
         * 获取本次运行指定的运行配置。
         *
         * @eng
         *
         * Get the execution config of this engine.
         */
        readonly executionConfig: ReadOnlyExecutionConfig;
        /**
         * @中文
         *
         * 强制停止引擎运行。
         *
         * @eng
         *
         * Force stop the engine.
         */
        forceStop(): void;
        /**
         * Returns the tag associated with this engine and the specified key.
         */
        getTag(key: string): any;
        /**
         * @中文
         *
         * 发送事件给引擎。对于nodejs引擎，可以用`require("engines").myEngine().on("event_name", () => {})`来监听事件；对于pro8引擎，则可以用`$events.on("event_name", () => {})`来监听事件。
         *
         * @param event 事件名称
         * @param args 事件参数，必须是可以转换为JSON的数据
         *
         * @eng
         *
         * Send event to engine. For nodejs engine, you can use `require("engines").myEngine().on("event", () => {})` to listen event; For pro8 engine, you can use `$events.on("event", () => {})` to listen event.
         *
         * @param event Event name
         * @param args Event arguments, must be a JSON-able data
         */
        emit(event: string, ...args: any[]): void;
    }
    /**
     * @中文
     *
     * {@link execScriptFile}返回的对象。表示一次代码执行，记录执行的文件路径，可以监听其开始运行、停止运行事件，也可以获取执行引擎以便和其通信或停止引擎。
     *
     * @eng
     *
     * Object returned by {@link execScriptFile}. It represents a script execution, records the path of script file executed, can listen events of start and stop, and can get engine to communicate with it or stop engine.
     */
    export interface ScriptExecution extends EventEmitter {
        /**
         * @中文
         *
         * 开始执行事件。本事件代表本次执行需要的线程和引擎对象已创建好，正准备执行代码。
         *
         * @event start
         *
         * @eng
         *
         * The event of execution start. Once this event is sent, the thread and engine of the execution are ready and about to execute script.
         *
         * @event start
         */
        on(event: 'start', listener: (execution: ScriptExecution) => void): this;
        /**
         * @中文
         *
         * 执行成功事件。本事件代表脚本已执行成功。
         * @event success
         *
         * @eng
         *
         * The event of execution success. This event indicates that the script has been executed successfully.
         * @event success
         */
        on(event: 'success', listener: (execution: ScriptExecution) => void): this;
        /**
         * @中文
         *
         * 执行异常事件。本事件代表脚本执行过程遇到了未捕获的异常。
         * @event exception
         *
         * @eng
         * The event of execution exception. This event indicates an uncaught exception encountered during script execution.
         *
         * @event exception
         */
        on(event: 'exception', listener: (execution: ScriptExecution, exception: java.lang.Throwable) => void): this;
        /**
         * @中文
         *
         * 获取本次执行的引擎对象，如果引擎还没有准备好，则返回`null`。
         *
         * @eng
         *
         * Get the engine object of this execution, if engine is not ready, return `null`.
         */
        get engineOrNull(): ScriptEngine | null;
        /**
         * @中文
         *
         * 获取本次运行指定的运行配置。
         *
         * @eng
         *
         * Get the execution config of this execution.
         */
        get executionConfig(): ReadOnlyExecutionConfig;
        /**
         * @中文
         *
         * 运行的源文件的对象。
         *
         * @eng
         *
         * Source file object of engine.
         */
        readonly source: any;
        /**
         * @中文
         *
         * 运行的源文件路径。
         *
         * @eng
         *
         * Path of execution source file.
         */
        readonly sourceFile: string;
        /**
         * @中文
         *
         * 异步获取本次执行的引擎对象。
         *
         * @eng
         *
         * Get the engine object of this execution asynchronously.
         */
        engine(): any;
    }
    export interface EngineEventTarget {
        addListener(event: string, listener: (...args: any[]) => void): this;
        on(event: string, listener: (...args: any[]) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        removeListener(event: string, listener: (...args: any[]) => void): this;
        off(event: string, listener: (...args: any[]) => void): this;
        removeAllListeners(event?: string): this;
        setMaxListeners(n: number): this;
        getMaxListeners(): number;
        listeners(event: string): Function[];
        rawListeners(event: string): Function[];
        listenerCount(event: string): number;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        eventNames(): Array<string>;
    }
    /**
     * @中文
     *
     * 当前代码的自身引擎的对象。
     *
     * @eng
     *
     * Object of the engine that current script running with.
     */
    export interface SelfScriptEngine extends ScriptEngine, EngineEventTarget {
        /**
         * @中文
         *
         * 执行参数。包括其他脚本启动本引擎时指定的参数，或者定时任务触发时的参数。比如由定时任务触发，则参数为`{intent: ...}`。
         *
         * @eng
         *
         * Execution arguments. Includes arguments specified when starting engine, or arguments specified when triggering by work manager. For example, if triggered by intent task, the `execArgv` is `{intent: ...}`.
         */
        readonly execArgv: any;
    }
    /**
     * @中文
     *
     * 获取当前运行的自身引擎的对象。
     *
     * @eng
     *
     * Get the engine object of the engine that current script running with.
     */
    export function myEngine(): SelfScriptEngine;
    /**
     * @中文
     *
     * 运行配置。用于启动新的引擎执行脚本或项目时，指定其运行目录、运行参数等。
     *
     * @eng
     *
     * Execution configuration. Used to specify the working directory, execution arguments when starting a new engine to run a script or a project.
     */
    export interface ExecutionConfig {
        /**
         * @中文
         *
         * 工作目录。默认为脚本的父目录或项目的根目录。其值会决定脚本执行时的相对路径等。
         *
         * @eng
         *
         * Working directory. Default is the parent directory of the script or the root directory of the project. The value will determine the relative path when executing the script, etc.
         */
        workingDirectory?: string;
        /**
         * @中文
         *
         * 脚本的require()时的搜索路径。类似于[module.paths](https://nodejs.org/docs/latest-v16.x/api/modules.html#modulepaths)。
         *
         * 该值暂时对Node.js引擎无效。
         *
         * @eng
         *
         * The require() search paths when executing the script. Similar to [module.paths](https://nodejs.org/docs/latest-v16.x/api/modules.html#modulepaths).
         *
         * This value is currently invalid for Node.js engine.
         *
         */
        path?: Array<string>;
        /**
         * @中文
         *
         * 执行参数。该参数可以通过`execArgv`属性获取。参数必须是可序列化（可转换为JSON）的对象。
         *
         * @eng
         *
         * Execution arguments. The value can be obtained by `execArgv` property. The arguments must be serializable (can be converted to JSON).
         */
        arguments?: any;
    }
    /**
     * @中文
     *
     * 启动新引擎执行脚本或项目。执行的脚本上下文和环境将和当前执行无关，也无法共享变量。可以通过事件或广播在脚本间通信。
     *
     * @param file 脚本或项目路径
     * @param config 运行配置
     * @returns 脚本执行对象，可以用来获取引擎状态、通信、控制引擎等
     *
     * @eng
     *
     * Start a new engine to run a script or a project. The script context and environment will be independent from the current context and environment. The script can communicate with other scripts by events or broadcasts.
     *
     * @param file Script or project path
     * @param config Execution configuration
     * @returns Script execution object. It can be used to get engine status, communicate with other scripts, and control the engine.
     */
    export function execScriptFile(file: string, config?: ExecutionConfig): ScriptExecution;
    /**
     * @中文
     *
     * 发送引擎间广播，相当于向所有引擎发送同一事件。
     *
     * @param event 事件名称
     * @param args 事件参数，必须是可序列化数据（可以转换为JSON）
     *
     * @eng
     *
     * Send a broadcast to all engines. It is equivalent to sending the same event to all engines.
     *
     * @param event Event name
     * @param args Event arguments, must be serializable (can be converted to JSON)
     */
    export function broadcast(event: string, ...args: any[]): void;
    /**
     * @中文
     *
     * 获取当前正在运行的所有引擎。
     *
     * @returns 当前运行的引擎数组
     *
     * @eng
     *
     * Get all current running engines.
     *
     * @returns Array of current running engines
     */
    export function getRunningEngines(): Array<ScriptEngine>;
    export interface StopAllOptions {
        /**
         * 停止所有引擎运行时是否显示Toast提示。默认为false。
         */
        toast?: boolean;
    }
    /**
     * @中文
     *
     * 停止所有引擎运行。
     *
     * @eng
     *
     * Stop all engines.
     *
     * @param options 停止所有引擎的选项
     */
    export function stopAll(options?: StopAllOptions): void;
}
declare module "color" {
    /**
     * @中文
     *
     * color模块包含了颜色相关的类，最常用的是Color类，表示ARGB颜色。
     *
     * @eng
     *
     * The color module contains classes for color, the most common is Color, which represents ARGB color.
     *
     * @see {@link Color}
     *
     * @packageDocumentation
     */
    import * as util from 'util';
    /**
     * @中文
     *
     * 比较颜色的选项。
     *
     * @eng
     *
     * Compare color options.
     *
     * @see {@lin Color.isSimilarTo}
     */
    export interface CompareColorOptions {
        /**
         * @中文
         *
         * 是否忽略alpha通道，默认为true。
         *
         * @eng
         *
         * Whether to ignore alpha channel, default is true.
         */
        readonly ignoreAlphaChannel?: boolean;
        /**
         * @中文
         *
         * 允许的比较误差，默认为16。比较算法是将每个颜色通道单独比较，如果每个颜色通道的差值都小于该值，则认为两个颜色相等。
         *
         * @eng
         *
         * Allowed comparison threshold, default is 16. Comparison algorithm is to compare each color channel separately, if the difference between each color channel is less than the threshold, the two colors are considered equal.
         */
        readonly threshold?: number;
    }
    /**
     * @中文
     *
     * 一个32位的颜色值，以ARGB格式表示。
     *
     * @eng
     *
     * An immutable 32 bit color value in ARGB format.
     *
     */
    export class Color {
        private _value;
        /**
         * @中文
         *
         * 从整数颜色值构造一个颜色。
         *
         * @param value 整数颜色值，格式为0xAARRGGBB
         *
         * @eng
         *
         * Constructs a color from an integer value.
         *
         * @param value An integer value, formatted as 0xAARRGGBB
         */
        constructor(value: number);
        /**
         * @eng
         *
         * A 32 bit value representing this color.
         *
         * The bits are assigned as follows:
         *
         * * Bits 24-31 are the alpha value.
         * * Bits 16-23 are the red value.
         * * Bits 8-15 are the green value.
         * * Bits 0-7 are the blue value.
         *
         * @中文
         *
         * 这个颜色的32位值。
         *
         * * 第24-31位为alpha值
         * * 第16-23位为red值
         * * 第8-15位为green值
         * * 第0-7位为blue值
         */
        get value(): number;
        /**
         * @eng
         *
         * The alpha channel of this color in an 8 bit value.
         *
         * A value of 0 means this color is fully transparent. A value of 255 means
         * this color is fully opaque.
         *
         * @中文
         *
         * 这个颜色的alpha值，以8位整数表示。
         *
         * 值为0表示这个颜色完全透明，值为255表示这个颜色完全不透明。
         *
         * @example
         * ```javascript
         * "nodejs";
         * const { Color } = require('color');
         * const color = new Color(0xFF000000); // black
         * console.log(color.alpha); // 255
         * ```
         */
        get alpha(): number;
        /**
         * @eng
         *
         * The alpha channel of this color as a floating value.
         *
         * A value of 0.0 means this color is fully transparent. A value of 1.0 means
         * this color is fully opaque.
         *
         * @中文
         *
         * 这个颜色的alpha值，以浮点数表示。
         *
         * 值为0.0表示这个颜色完全透明，值为1.0表示这个颜色完全不透明。
         *
         * @example
         * ```javascript
         * "nodejs";
         * const { Color } = require('color');
         * const color = new Color(0xFF000000); // black
         * console.log(color.opacity); // 1.0
         * ```
         */
        get opacity(): number;
        /**
         * The red channel of this color in an 8 bit value.
         */
        get red(): number;
        /**
         * @eng
         *
         * The green channel of this color in an 8 bit value.
         *
         * @中文
         *
         * 这个颜色的green值，以8位整数表示。
         */
        get green(): number;
        /**
         * @eng
         *
         * The blue channel of this color in an 8 bit value.
         *
         * @中文
         *
         * 这个颜色的blue值，以8位整数表示。
         */
        get blue(): number;
        /**
         * @eng
         *
         * Returns a new color that matches this color with the alpha channel
         * replaced with `a` (which ranges from 0 to 255).
         *
         * Out of range values will have unexpected effects.
         *
         * @param a alpha channel
         * @returns a new color
         *
         * @中文
         *
         * 返回一个新的颜色，将原来的颜色的alpha通道的值设置为`a`
         *
         * 超出范围的值会有意外问题。
         *
         * @param a alpha通道的值，范围为0-255
         * @returns 新的颜色
         *
         * @example
         * ```javascript
         * "nodejs";
         * const { Color } = require('color');
         * const color = new Color(0xFF000000); // black
         * console.log(color.withAlpha(0x77).toString()) // 0x77000000
         * ```
         */
        withAlpha(a: number): Color;
        /**
         * @eng
         *
         * Returns a new color that matches this color with the alpha channel
         * replaced with the given `opacity` (which ranges from 0.0 to 1.0).
         *
         * Out of range values will have unexpected effects.
         *
         * @param opacity opacity value
         * @returns a new color
         *
         * @中文
         *
         * 返回一个新的颜色，将原来的颜色的alpha通道的透明度值设置为`opacity`。
         *
         * 超出范围的值会有意外问题。
         *
         * @param opacity 透明度值，范围为0.0-1.0
         * @returns 新的颜色
         *
         * @example
         * ```javascript
         * "nodejs";
         * const { Color } = require('color');
         * const color = new Color(0xFF000000); // black
         * console.log(color.withOpacity(0.5).toString()) // 0x7F000000
         * ```
         */
        withOpacity(opacity: number): Color;
        /**
         * @eng
         *
         * Returns a new color that matches this color with the red channel replaced
         * with `r` (which ranges from 0 to 255).
         *
         * Out of range values will have unexpected effects.
         *
         * @param r red channel
         * @returns a new color
         *
         * @中文
         *
         * 返回一个新的颜色，将原来的颜色的red通道的值设置为`r`。
         *
         * 超出范围的值会有意外问题。
         *
         * @param r red通道的值，范围为0-255
         * @returns 新的颜色
         */
        withRed(r: number): Color;
        /**
         * @eng
         *
         * Returns a new color that matches this color with the green channel
         * replaced with `g` (which ranges from 0 to 255).
         *
         * Out of range values will have unexpected effects.
         *
         * @param g green channel
         * @returns a new color
         *
         * @中文
         *
         * 返回一个新的颜色，将原来的颜色的green通道的值设置为`g`。
         *
         * 超出范围的值会有意外问题。
         *
         * @param g green通道的值，范围为0-255
         * @returns 新的颜色
         */
        withGreen(g: number): Color;
        /**
         * @eng
         *
         * Returns a new color that matches this color with the blue channel replaced
         * with `b` (which ranges from 0 to 255).
         *
         * Out of range values will have unexpected effects.
         *
         * @param b blue channel
         * @returns a new color
         *
         * @中文
         *
         * 返回一个新的颜色，将原来的颜色的blue通道的值设置为`b`。
         *
         * 超出范围的值会有意外问题。
         *
         * @param b blue通道的值，范围为0-255
         * @returns 新的颜色
         *
         */
        withBlue(b: number): Color;
        /**
         * @中文
         *
         * 比较当前颜色是否与另一个颜色相似。
         *
         * @param other 要比较的颜色
         * @param options 比较选项
         * @returns 两个颜色是否相似
         *
         * @see {@link CompareColorOptions}
         *
         * @example
         *
         * ```javascript
         * "nodejs";
         * const { Color } = require('color');
         * const black = new Color(0xFF000000);
         * const white = Color.parse('#FFFFFF');
         * const black09 = Color.parse('#090909');
         * console.log(black.isSimilarTo(white)) // false
         * console.log(black.isSimilarTo(black09)) // true
         * console.log(black.isSimilarTo(black09, { threshold: 5 })) // false
         * ```
         */
        isSimilarTo(other: Color, options?: CompareColorOptions): boolean;
        /**
         * @中文
         *
         * 比较两个颜色是否完全相等。
         *
         * @param other 要比较的颜色
         * @returns 两个颜色是否完全相等
         *
         * @eng
         *
         * Compare two colors is equal, including alpha channel.
         *
         * @param other the color to compare
         * @returns two colors are equal
         */
        equals(obj: Color): boolean;
        toString: () => string;
        [util.inspect.custom]: () => string;
        /**
         * @eng
         *
         * Construct a color from the lower 8 bits of four integers.
         *
         * * `a` is the alpha value, with 0 being transparent and 255 being fully
         *   opaque.
         * * `r` is [red], from 0 to 255.
         * * `g` is [green], from 0 to 255.
         * * `b` is [blue], from 0 to 255.
         *
         * Out of range values are brought into range using modulo 255.
         *
         * @param a alpha value
         * @param r red value
         * @param g green value
         * @param b blue value
         * @returns a new color
         *
         * @中文
         *
         * 从四个颜色通道构造一个颜色。
         *
         * * `a`是透明度，0表示透明，255表示完全不透明。
         * * `r`是[红]，范围为0-255。
         * * `g`是[绿]，范围为0-255。
         * * `b`是[蓝]，范围为0-255。
         *
         * 超出范围的值会取255的模以保证在255范围内。
         *
         * @param a alpha通道的值，范围为0-255
         * @param r red通道的值，范围为0-255
         * @param g green通道的值，范围为0-255
         * @param b blue通道的值，范围为0-255
         * @returns 新的颜色
         *
         * @see {@link fromRGBO} which takes the alpha value as a floating point
         * value.
         *
         * @example
         * ```javascript
         * "nodejs";
         * const { Color } = require('color');
         * const red = Color.fromARGB(255, 255, 0, 0);
         * console.log(red.toString()) // Color(0xFFFF0000)
         * ```
         *
         */
        static fromARGB(a: number, r: number, g: number, b: number): Color;
        /**
         * @中文
         *
         * 从RGB颜色通道构造一个不透明颜色（alpha通道为255）。
         *
         * @param r red value
         * @param g green value
         * @param b blue value
         * @returns a new color
         *
         * @eng
         *
         * Construct a color from RGB channels. The alpha channel is set to 255.
         *
         * @param r 红色通道的值，范围为0-255
         * @param g 绿色通道的值，范围为0-255
         * @param b 蓝色通道的值，范围为0-255
         * @returns 新的颜色对象
         *
         * @example
         * ```javascript
         * "nodejs";
         * const { Color } = require('color');
         * const red = Color.fromRGBO(255, 0, 0);
         * console.log(red.toString()) // Color(0xFFFF0000)
         * ```
         */
        static fromRGB(r: number, g: number, b: number): Color;
        /**
         * @中文
         *
         * 根据灰度值构造颜色，alpha通道为255，R、G、B通道均为gray的值。
         *
         * @param gray 灰度值
         * @returns 新的颜色对象
         *
         * @eng
         *
         * Construct a color from a grayscale value. The alpha channel is set to 255, and the R, G, and B channels are set to the same value.
         *
         * @param gray the grayscale value
         * @returns a new color
         *
         * @example
         * ```javascript
         * "nodejs";
         * const { Color } = require('color');
         * const gray = Color.fromGray(128);
         * console.log(gray.toString()) // Color(0xFF808080)
         * ```
         */
        static fromGray(gray: number): Color;
        /**
         * @eng
         *
         * Create a color from red, green, blue, and opacity, similar to `rgba()` in CSS.
         *
         * * `r` is [red], from 0 to 255.
         * * `g` is [green], from 0 to 255.
         * * `b` is [blue], from 0 to 255.
         * * `opacity` is alpha channel of this color as a double, with 0.0 being
         *   transparent and 1.0 being fully opaque.
         *
         * Out of range values are brought into range using modulo 255.
         *
         * @param r red value
         * @param g green value
         * @param b blue value
         * @param opacity alpha value
         * @returns a new color
         *
         * @中文
         *
         * 从红、绿、蓝和透明度通道构造一个颜色。
         *
         * * `r`是[红]，范围为0-255。
         * * `g`是[绿]，范围为0-255。
         * * `b`是[蓝]，范围为0-255。
         * * `opacity`是透明度通道的值，0表示透明，1表示完全不透明。
         *
         * 超出范围的值会取255的模以保证在255范围内。
         *
         * @param r red通道的值，范围为0-255
         * @param g green通道的值，范围为0-255
         * @param b blue通道的值，范围为0-255
         * @param opacity alpha通道的值，范围为0-1
         * @returns 新的颜色
         *
         * @see {@link fromARGB} which takes the opacity as an integer value.
         *
         */
        static fromRGBO(r: number, g: number, b: number, opacity: number): Color;
        /**
         * @中文
         *
         * 解析十六进制字符串构造一个颜色。若解析失败，则返回null。
         *
         * @param color 颜色字符串，格式为#RRGGBB或#AARRGGBB
         * @returns 新的颜色，或者null
         *
         * @eng
         *
         * Parse a color from a hex string, such as `#RRGGBB` or `#AARRGGBB`.
         *
         * @param color 颜色字符串，格式为#RRGGBB或#AARRGGBB
         * @returns 新的颜色，或者null
         *
         * @example
         * ```javascript
         * const { Color } = require('color');
         * const color = Color.parse('#ff0000');
         * console.log(color.toString());
         * ```
         */
        static parse(color: string): Color | null;
    }
    /**
     *
     * @中文
     *
     * 转换整数number为颜色整数。该函数实际上是将大于int32最大值的数字转换为负数，例如将0xFFFFFFFF转换为-1。
     *
     * @param number 整数
     * @returns 颜色整数
     *
     * @eng
     *
     * Convert a number to a color integer. The actual implementation is to convert the number that larger than int32 max to a negative number. For example, 0xFFFFFFFF will be converted to -1.
     *
     * @param number integer
     * @returns color integer
     */
    export function toColorInt(number: number): number;
    /**
     * A color represented using [alpha], [hue], [saturation], and [value].
     * An [HSVColor] is represented in a parameter space that's based on human
     * perception of color in pigments (e.g. paint and printer's ink). The
     * representation is useful for some color computations (e.g. rotating the hue
     * through the colors), because interpolation and picking of
     * colors as red, green, and blue channels doesn't always produce intuitive
     * results.
     * The HSV color space models the way that different pigments are perceived
     * when mixed. The hue describes which pigment is used, the saturation
     * describes which shade of the pigment, and the value resembles mixing the
     * pigment with different amounts of black or white pigment.
     * See also:
     *  * [HSLColor], a color that uses a color space based on human perception of
     *    colored light.
     *  * [HSV and HSL](https://en.wikipedia.org/wiki/HSL_and_HSV) Wikipedia
     *    article, which this implementation is based upon.
     */
    export class HSVColor {
        /**
         * Creates a color.
         *
         * All the arguments must not be null and be in their respective ranges. See
         * the fields for each parameter for a description of their ranges.
         */
        static fromAHSV(alpha: number, hue: number, saturation: number, value: number): HSVColor;
        /**
         * Creates an [HSVColor] from an RGB [Color].
         *
         * This constructor does not necessarily round-trip with [toColor] because
         * of floating point imprecision.
         */
        static fromColor(color: Color): HSVColor;
        /**
         * Alpha, from 0.0 to 1.0. The describes the transparency of the color.
         * A value of 0.0 is fully transparent, and 1.0 is fully opaque.
         */
        readonly alpha: number;
        /**
         * Hue, from 0.0 to 360.0. Describes which color of the spectrum is
         * represented. A value of 0.0 represents red, as does 360.0. Values in
         * between go through all the hues representable in RGB. You can think of
         * this as selecting which pigment will be added to a color.
         */
        readonly hue: number;
        /**
         * Saturation, from 0.0 to 1.0. This describes how colorful the color is.
         * 0.0 implies a shade of grey (i.e. no pigment), and 1.0 implies a color as
         * vibrant as that hue gets. You can think of this as the equivalent of
         * how much of a pigment is added.
         */
        readonly saturation: number;
        /**
         * Value, from 0.0 to 1.0. The "value" of a color that, in this context,
         * describes how bright a color is. A value of 0.0 indicates black, and 1.0
         * indicates full intensity color. You can think of this as the equivalent of
         * removing black from the color as value increases.
         */
        readonly value: number;
        private constructor();
        /**
         * Returns a copy of this color with the [alpha] parameter replaced with the
         * given value.
         */
        withAlpha(alpha: number): HSVColor;
        /**
         * Returns a copy of this color with the [hue] parameter replaced with the
         * given value.
         */
        withHue(hue: number): HSVColor;
        /**
         * Returns a copy of this color with the [saturation] parameter replaced with
         * the given value.
         */
        withSaturation(saturation: number): HSVColor;
        /**
         * Returns a copy of this color with the [value] parameter replaced with the
         * given value.
         */
        withValue(value: number): HSVColor;
        /**
         * Returns this color in RGB.
         */
        toColor(): Color;
        _scaleAlpha(factor: number): HSVColor;
        /**
         * Linearly interpolate between two HSVColors.
         *
         * The colors are interpolated by interpolating the [alpha], [hue],
         * [saturation], and [value] channels separately, which usually leads to a
         * more pleasing effect than [Color.lerp] (which interpolates the red, green,
         * and blue channels separately).
         *
         * If either color is null, this function linearly interpolates from a
         * transparent instance of the other color. This is usually preferable to
         * interpolating from [Colors.transparent] (`const Color(0x00000000)`) since
         * that will interpolate from a transparent red and cycle through the hues to
         * match the target color, regardless of what that color's hue is.
         *
         * Values outside of the valid range for each channel will be clamped.
         */
        static lerp(a: HSVColor | null, b: HSVColor | null, t: number): HSVColor | undefined;
        equals(other: any): boolean;
        toString(): string;
    }
    /**
     * A color represented using [alpha], [hue], [saturation], and [lightness].
     *
     * An [HSLColor] is represented in a parameter space that's based up human
     * perception of colored light. The representation is useful for some color
     * computations (e.g., combining colors of light), because interpolation and
     * picking of colors as red, green, and blue channels doesn't always produce
     * intuitive results.
     *
     * HSL is a perceptual color model, placing fully saturated colors around a
     * circle (conceptually) at a lightness of ​0.5, with a lightness of 0.0 being
     * completely black, and a lightness of 1.0 being completely white. As the
     * lightness increases or decreases from 0.5, the apparent saturation decreases
     * proportionally (even though the [saturation] parameter hasn't changed).
     *
     * See also:
     *
     *  * [HSVColor], a color that uses a color space based on human perception of
     *    pigments (e.g. paint and printer's ink).
     *  * [HSV and HSL](https://en.wikipedia.org/wiki/HSL_and_HSV) Wikipedia
     *    article, which this implementation is based upon.
     */
    export class HSLColor {
        /**
         * Creates a color.
         *
         * All the arguments must not be null and be in their respective ranges. See
         * the fields for each parameter for a description of their ranges.
         */
        static fromAHSL(alpha: number, hue: number, saturation: number, lightness: number): HSLColor;
        /**
         * Creates an [HSLColor] from an RGB [Color].
         *
         * This constructor does not necessarily round-trip with [toColor] because
         * of floating point imprecision.
         */
        static fromColor(color: Color): HSLColor;
        /**
         * Alpha, from 0.0 to 1.0. The describes the transparency of the color.
         * A value of 0.0 is fully transparent, and 1.0 is fully opaque.
         */
        readonly alpha: number;
        /**
         * Hue, from 0.0 to 360.0. Describes which color of the spectrum is
         * represented. A value of 0.0 represents red, as does 360.0. Values in
         * between go through all the hues representable in RGB. You can think of
         * this as selecting which color filter is placed over a light.
         */
        readonly hue: number;
        /**
         * Saturation, from 0.0 to 1.0. This describes how colorful the color is.
         * 0.0 implies a shade of grey (i.e. no pigment), and 1.0 implies a color as
         * vibrant as that hue gets. You can think of this as the purity of the
         * color filter over the light.
         */
        readonly saturation: number;
        /**
         * Lightness, from 0.0 to 1.0. The lightness of a color describes how bright
         * a color is. A value of 0.0 indicates black, and 1.0 indicates white. You
         * can think of this as the intensity of the light behind the filter. As the
         * lightness approaches 0.5, the colors get brighter and appear more
         * saturated, and over 0.5, the colors start to become less saturated and
         * approach white at 1.0.
         */
        readonly lightness: number;
        private constructor();
        /**
         * Returns a copy of this color with the alpha parameter replaced with the
         * given value.
         */
        withAlpha(alpha: number): HSLColor;
        /**
         * Returns a copy of this color with the [hue] parameter replaced with the
         * given value.
         */
        withHue(hue: number): HSLColor;
        /**
         * Returns a copy of this color with the [saturation] parameter replaced with
         * the given value.
         */
        withSaturation(saturation: number): HSLColor;
        /**
         * Returns a copy of this color with the [lightness] parameter replaced with
         * the given value.
         */
        withLightness(lightness: number): HSLColor;
        /**
         * Returns this HSL color in RGB.
         */
        toColor(): Color;
        _scaleAlpha(factor: number): HSLColor;
        /**
         * Linearly interpolate between two HSLColors.
         *
         * The colors are interpolated by interpolating the [alpha], [hue],
         * [saturation], and [lightness] channels separately, which usually leads to
         * a more pleasing effect than [Color.lerp] (which interpolates the red,
         * green, and blue channels separately).
         *
         * If either color is null, this function linearly interpolates from a
         * transparent instance of the other color. This is usually preferable to
         * interpolating from [Colors.transparent] (`const Color(0x00000000)`) since
         * that will interpolate from a transparent red and cycle through the hues to
         * match the target color, regardless of what that color's hue is.
         *
         * The `t` argument represents position on the timeline, with 0.0 meaning
         * that the interpolation has not started, returning `a` (or something
         * equivalent to `a`), 1.0 meaning that the interpolation has finished,
         * returning `b` (or something equivalent to `b`), and values between them
         * meaning that the interpolation is at the relevant point on the timeline
         * between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
         * 1.0, so negative values and values greater than 1.0 are valid
         * (and can easily be generated by curves such as [Curves.elasticInOut]).
         *
         * Values outside of the valid range for each channel will be clamped.
         *
         * Values for `t` are usually obtained from an [Animation\<double\>], such as
         * an [AnimationController].
         */
        static lerp(a: HSLColor | null, b: HSLColor | null, t: number): HSLColor | null;
        equals(other: any): boolean;
        toString(): String;
    }
}
declare module "image" {
    /**
     * @中文
     *
     * image模块主要提供图片读写、灰度化、剪切、缩放、模板匹配等图像处理函数，其主要API在本页展示的函数以及{@link Image}类。
     *
     * 类似Pro 8中截图函数已迁移到{@link media_projection}模块。另外，要直接使用opencv相关函数和功能，参见{@link @autojs/opencv}模块。
     *
     * @eng
     *
     * image module provides image reading, grayscale, cropping, scaling, template matching, etc. functions. The main APIs are functions of this page and the {@link Image} class.
     *
     * The functions of screen capture have been moved to the {@link media_projection} module. Also, the functions of opencv are directly available in the {@link @autojs/opencv} module.
     *
     * @packageDocumentation
     */
    import * as cv from '@autojs/opencv';
    import { Mat } from '@autojs/opencv';
    import { Color, CompareColorOptions } from "color";
    export type ImageFormat = 'jpg' | 'jpeg' | 'png' | 'webp';
    export enum FeatureDetectMethod {
        SIFT = 1,
        ORB = 2
    }
    export enum FeatureMatcher {
        FLANNBASED = 1,
        BRUTEFORCE = 2,
        BRUTEFORCE_L1 = 3,
        BRUTEFORCE_HAMMING = 4,
        BRUTEFORCE_HAMMINGLUT = 5,
        BRUTEFORCE_SL2 = 6
    }
    export interface DetectAndComputeFeaturesOptions {
        readonly grayscale?: boolean;
        readonly scale?: number;
        readonly method?: FeatureDetectMethod;
        readonly region?: Region;
    }
    export abstract class ImageFeatures {
        abstract recycle(): void;
    }
    export class ImageFeaturesImpl {
        readonly javaObject: JavaObject;
        readonly scale: number;
        readonly region?: cv.Rect;
        private recycled;
        onRecycled?: () => void;
        constructor(javaObject: JavaObject, scale: number, region?: cv.Rect);
        recycle(): void;
    }
    /**
     * @中文
     *
     * 代表图像对象的类，通过opencv的{@link Mat}构造。或者通过{@link readImage}, {@link decodeImage}等函数从图片文件、链接、Base64中解析。
     *
     * @eng
     *
     * The class of image object, constructed by the {@link Mat}, or by {@link readImage}, {@link decodeImage} etc. functions.
     */
    export class Image {
        private _mat;
        private _c4mat?;
        private _onRecycledCallbacks;
        constructor(mat: Mat);
        get mat(): Mat;
        /**
         * @中文
         *
         * 获取四通道（BGRA格式）的Mat对象。
         *
         * @eng
         *
         * Get the Mat object of the 4-channel (BGRA) format.
         */
        get c4mat(): Mat;
        /**
         * @中文
         *
         * 获取图像的宽度。
         *
         * @eng
         *
         * Get the width of the image.
         */
        get width(): number;
        /**
         * @中文
         *
         * 获取图像的高度。
         *
         * @eng
         *
         * Get the height of the image.
         */
        get height(): number;
        /**
         * @中文
         *
         * 获取图像在位置(x, y)处的颜色。若为三通道图像，则假设其为BGR格式；若为四通道图像，则假设其为BGRA格式；若为单通道图像，则假设其为灰度图。
         *
         * @eng
         *
         * Get the color at the position (x, y) of the image. If the image is a 3-channel image, then assume it is in BGR format; if it is a 4-channel image, then assume it is in BGRA format; if it is a single-channel image, then assume it is in gray-scale.
         *
         * @example
         * ```javascript
         * "nodejs";
         * const { loadImage } = require("image");
         *
         * async function main() {
         *     const img = await loadImage("https://picsum.photos/200/300");
         *     console.log(img.pixel(0, 0));
         * }
         * main();
         * ```
         */
        pixel(x: number, y: number): Color;
        /**
         * @中文
         *
         * 用给定的区域剪切图像，异步返回剪切后的图像。
         *
         * @param rect 指定剪切区域
         *
         * @eng
         *
         * Clip the image with the given region, return the clipped image asynchronously.
         *
         * @param rect The region to clip
         *
         * @example
         * ```javascript
         * "nodejs";
         * const cv = require("@autojs/opencv");
         * const { loadImage } = require("image");
         *
         * async function main() {
         *     const img = await loadImage("https://picsum.photos/200/300");
         *     console.log(await img.clip(new cv.Rect(0, 0, 100, 100)));
         * }
         * main();
         * ```
         */
        clip(rect: cv.Rect): Promise<Image>;
        /**
         * @中文
         *
         * 用给定的区域剪切图像，同步返回剪切后的图像。
         *
         * @param rect 指定剪切区域
         *
         * @eng
         *
         * Clip the image with the given region, return the clipped image synchronously.
         *
         * @param rect The region to clip
         *
         * @example
         * ```javascript
         * "nodejs";
         * const cv = require("@autojs/opencv");
         * const { loadImage } = require("image");
         *
         * async function main() {
         *     const img = await loadImage("https://picsum.photos/200/300");
         *     console.log(img.clipSync(new cv.Rect(0, 0, 100, 100)));
         * }
         * main();
         * ```
         */
        clipSync(rect: cv.Rect): Image;
        /**
         * @中文
         *
         * 缩放图像，异步返回缩放后的新图像。
         *
         * @param width 缩放后的宽度
         * @param height 缩放后的高度
         * @param interpolation 插值方式，默认为{@link cv.INTER_LINEAR}。可以为{@link cv.INTER_AREA}, {@link cv.INTER_CUBIC}, {@link cv.INTER_LANCZOS4}, {@link cv.INTER_LINEAR}, {@link cv.INTER_NEAREST}等。
         * @returns
         *
         * @eng
         *
         * Scale the image, return a new image asynchronously.
         *
         * @param width The width of the scaled image.
         * @param height The height of the scaled image.
         * @param interpolation Interpolation method, default is {@link cv.INTER_LINEAR}. Can be {@link cv.INTER_AREA}, {@link cv.INTER_CUBIC}, {@link cv.INTER_LANCZOS4}, {@link cv.INTER_LINEAR}, {@link cv.INTER_NEAREST}.
         */
        resize(width: number, height: number, interpolation?: number): Promise<Image>;
        /**
         * @中文
         *
         * 缩放图像，同步返回缩放后的新图像。
         *
         * @param width 缩放后的宽度
         * @param height 缩放后的高度
         * @param interpolation 插值方式，默认为{@link cv.INTER_LINEAR}。可以为{@link cv.INTER_AREA}, {@link cv.INTER_CUBIC}, {@link cv.INTER_LANCZOS4}, {@link cv.INTER_LINEAR}, {@link cv.INTER_NEAREST}等。
         * @returns
         *
         * @eng
         *
         * Scale the image, return a new image synchronously.
         *
         * @param width The width of the scaled image.
         * @param height The height of the scaled image.
         * @param interpolation Interpolation method, default is {@link cv.INTER_LINEAR}. Can be {@link cv.INTER_AREA}, {@link cv.INTER_CUBIC}, {@link cv.INTER_LANCZOS4}, {@link cv.INTER_LINEAR}, {@link cv.INTER_NEAREST}.
         */
        resizeSync(width: number, height: number, interpolation?: number): Image;
        /**
         * @中文
         *
         * 缩放图像，异步返回缩放后的新图像。
         *
         * @param fx x方向的缩放比例（宽度）
         * @param fy y方向的缩放比例（高度）
         * @param interpolation 插值方式，默认为{@link cv.INTER_LINEAR}。可以为{@link cv.INTER_AREA}, {@link cv.INTER_CUBIC}, {@link cv.INTER_LANCZOS4}, {@link cv.INTER_LINEAR}, {@link cv.INTER_NEAREST}等。
         * @returns
         *
         * @eng
         *
         * Scale the image, return a new image asynchronously.
         *
         * @param fx x-axis scaling ratio (width)
         * @param fy y-axis scaling ratio (height)
         * @param interpolation Interpolation method, default is {@link cv.INTER_LINEAR}. Can be {@link cv.INTER_AREA}, {@link cv.INTER_CUBIC}, {@link cv.INTER_LANCZOS4}, {@link cv.INTER_LINEAR}, {@link cv.INTER_NEAREST}.
         */
        scale(fx: number, fy?: number, interpolation?: number): Promise<Image>;
        /**
         * @中文
         *
         * 缩放图像，同步返回缩放后的新图像。
         *
         * @param fx x方向的缩放比例（宽度）
         * @param fy y方向的缩放比例（高度）
         * @param interpolation 插值方式，默认为{@link cv.INTER_LINEAR}。可以为{@link cv.INTER_AREA}, {@link cv.INTER_CUBIC}, {@link cv.INTER_LANCZOS4}, {@link cv.INTER_LINEAR}, {@link cv.INTER_NEAREST}等。
         * @returns
         *
         * @eng
         *
         * Scale the image, return a new image synchronously.
         *
         * @param fx x-axis scaling ratio (width)
         * @param fy y-axis scaling ratio (height)
         * @param interpolation Interpolation method, default is {@link cv.INTER_LINEAR}. Can be {@link cv.INTER_AREA}, {@link cv.INTER_CUBIC}, {@link cv.INTER_LANCZOS4}, {@link cv.INTER_LINEAR}, {@link cv.INTER_NEAREST}.
         */
        scaleSync(fx: number, fy?: number, interpolation?: number): Image;
        /**
         * @中文
         *
         * 将图像旋转以指定的center中心旋转degree角度。若不指定center，则默认为图像中心。异步返回旋转后的图像。
         *
         * @eng
         *
         * Rotate the image by the specified degree. If the center is not specified, then the center of the image is used. Asynchronously return the rotated image.
         */
        rotate(degree: number, center?: cv.Point2): Promise<Image>;
        /**
         * @中文
         *
         * 将图像旋转以指定的center中心旋转degree角度。若不指定center，则默认为图像中心。同步返回旋转后的图像。
         *
         * @eng
         *
         * Rotate the image by the specified degree. If the center is not specified, then the center of the image is used. Synchronously return the rotated image.
         */
        rotateSync(degree: number, center?: cv.Point2): Image;
        /**
         * @中文
         *
         * 将对象灰度化，异步返回灰度化后的新图片对象。
         *
         * @eng
         *
         * Grayscale the image, and return a new image object of the gray image asynchronously.
         *
         * @returns
         */
        grayscale(): Promise<Image>;
        /**
         * @中文
         *
         * 将对象灰度化，同步返回灰度化后的新图片对象。
         *
         * @eng
         *
         * Grayscale the image, and return a new image object of the gray image synchronously.
         */
        grayscaleSync(): Image;
        /**
         * @中文
         *
         * 将图像拷贝一份，返回新的Image对象的Promise。
         *
         * @eng
         *
         * Copy the image and return the promise of the new image instance.
         *
         */
        copy(): Promise<Image>;
        /**
         * @中文
         *
         * 将图像拷贝一份，并同步返回新的Image对象。
         *
         * @eng
         *
         * Copy the image and return the new image instance synchronously.
         *
         */
        copySync(): Image;
        /**
         * @中文
         *
         * 将图像转换为android的Bitmap对象。
         *
         * @eng
         *
         * Convert the image to an android Bitmap object.
         *
         * @see [Bitmap](https://developer.android.com/reference/android/graphics/Bitmap)
         */
        toBitmap(): android.graphics.Bitmap;
        detectAndComputeFeatures(options?: DetectAndComputeFeaturesOptions): Promise<ImageFeatures>;
        /**
         * @中文
         *
         * 回收图像对象。回收后不应对本对象进行任何操作。
         *
         * @eng
         *
         * Release the image object. After release, the object should not be used.
         *
         */
        recycle(): void;
        /**
         * @中文
         *
         * 将android Bitmap对象转为Image对象。若Bitmap为空或非Bitmap对象，则抛出异常。
         *
         * @eng
         *
         * Convert an android Bitmap object to an Image object. If the Bitmap is null or not a Bitmap object, then throw an exception.
         *
         * @see [Bitmap](https://developer.android.com/reference/android/graphics/Bitmap)
         */
        static ofBitmap(bitmap: android.graphics.Bitmap): Image;
        private convertToTargetColor;
        private static of_ARGB_8888_Bitmap;
    }
    /**
     * @中文
     *
     * 读取指定路径的文件，同步返回Image对象。若文件不存在或无法解析，则抛出异常。
     *
     * @param file 文件路径，支持相对路径
     *
     * @eng
     *
     * Read the file at the specified path, and return the image object synchronously. If the file does not exist or cannot be decoded, then throw an exception.
     *
     * @param file the file path, support relative path
     */
    export function readImageSync(file: string): Image;
    /**
     * @中文
     *
     * 读取指定路径的文件，异步返回Image对象。若文件不存在或无法解析，则抛出异常。
     *
     * @param file 文件路径，支持相对路径
     *
     * @eng
     *
     * Read the file at the specified path, and return the image object asynchronously. If the file does not exist or cannot be decoded, then throw an exception.
     *
     * @param file the file path, support relative path
     */
    export function readImage(file: string): Promise<Image>;
    /**
     * @中文
     *
     * 加载指定url地址的图片，异步返回Image对象。若url无法访问或图片无法解析，则抛出异常。
     *
     * @param url 图片地址，需要以https或http开头
     *
     * @eng
     *
     * Load the file at the specified url, and return the image object asynchronously. If the url cannot be accessed or the image cannot be decoded, then throw an exception.
     *
     * @param url the url address, must start with https or http
     */
    export function loadImage(url: string): Promise<Image>;
    /**
     * @中文
     *
     * 将图片异步写入到指定的路径。
     *
     * @param file 文件路径，支持相对路径。文件路径需要以特定后缀名结束，目前支持的后缀名有：.jpg、.jpeg、.png、.webp。
     * @param quality 图片质量，范围0-100。默认值为100。
     *
     * @eng
     *
     * Write the image asynchronously to the specified path.
     *
     * @param file the file path, support relative path. The file path must end with one of the following extensions: .jpg, .jpeg, .png, .webp.
     * @param quality the image quality, range 0-100. The default value is 100.
     *
     * @example
     * ```javascript
     * "nodejs";
     *
     * const {loadImage, writeImage} = require("image");
     * async function main() {
     *    const img = await loadImage("https://picsum.photos/200/300");
     *    await writeImage(img, "./output-200x300.png");
     * }
     * main();
     * ```
     *
     */
    export function writeImage(img: Image, file: string, quality?: number): Promise<void>;
    /**
     * @中文
     *
     * 将图片同步写入到指定的路径。
     *
     * @param file 文件路径，支持相对路径。文件路径需要以特定后缀名结束，目前支持的后缀名有：.jpg、.jpeg、.png、.webp。
     * @param quality 图片质量，范围0-100。默认值为100。
     *
     * @eng
     *
     * Write the image synchronously to the specified path.
     *
     * @param file the file path, support relative path. The file path must end with one of the following extensions: .jpg, .jpeg, .png, .webp.
     * @param quality the image quality, range 0-100. The default value is 100.
     *
     */
    export function writeImageSync(img: Image, file: string, quality?: number): void;
    /**
     * @中文
     *
     * 将字符串解码为图片对象，并异步返回该图片对象。若无法解码，则抛出异常。
     *
     * @param str 字符串，根据encoding参数决定格式，默认为base64
     * @param encoding 编码格式，默认为base64
     *
     * @eng
     *
     * Decode the string to image object, and return the image object asynchronously. If the string cannot be decoded, throw an exception.
     *
     * @param str the string, based on encoding parameter, default is base64
     * @param encoding the encoding format, default is base64
     */
    export function decodeImage(str: string, encoding?: BufferEncoding): Promise<Image>;
    /**
     * @中文
     *
     * 将字符串解码为图片对象，并同步返回该图片对象。若无法解码，则抛出异常。
     *
     * @param str 字符串，根据encoding参数决定格式，默认为base64
     * @param encoding 编码格式，默认为base64
     *
     * @eng
     *
     * Decode the string to image object, and return the image object synchronously. If the string cannot be decoded, throw an exception.
     *
     * @param str the string, based on encoding parameter, default is base64
     * @param encoding the encoding format, default is base64
     */
    export function decodeImageSync(str: string, encoding?: BufferEncoding): Image;
    /**
     * @中文
     *
     * 将图片编码为字符串，并异步返回编码后的字符串。
     *
     * @param encoding 编码格式，默认为base64
     * @param format 图片压缩格式，默认为png。可选的值有：png、jpg、jpeg、webp。
     * @param quality 图片质量，范围0-100。默认值为100。
     *
     * @eng
     *
     * Encode the image to string, and return the encoded string asynchronously.
     *
     * @param encoding the encoding format, default is base64
     * @param format the image compress format, default is png. The available values are: png, jpg, jpeg, webp.
     * @param quality the image quality, range 0-100. The default value is 100.
     *
     */
    export function encodeImage(img: Image, encoding?: BufferEncoding, format?: ImageFormat, quality?: number): Promise<string>;
    /**
     * @中文
     *
     * 将图片编码为字符串，并同步返回编码后的字符串。
     *
     * @param encoding 编码格式，默认为base64
     * @param format 图片压缩格式，默认为png。可选的值有：png、jpg、jpeg、webp。
     * @param quality 图片质量，范围0-100。默认值为100。
     *
     * @eng
     *
     * Encode the image to string, and return the encoded string synchronously.
     *
     * @param encoding the encoding format, default is base64
     * @param format the image compress format, default is png. The available values are: png, jpg, jpeg, webp.
     * @param quality the image quality, range 0-100. The default value is 100.
     *
     */
    export function encodeImageSync(img: Image, encoding?: BufferEncoding, format?: ImageFormat, quality?: number): string;
    /**
     * @中文
     *
     * 将图片编码为二进制数据，并异步返回编码后的Buffer对象。
     *
     * @param format 图片压缩格式，默认为png。可选的值有：png、jpg、jpeg、webp。
     * @param quality 图片质量，范围0-100。默认值为100。
     *
     * @eng
     *
     * Encode the image to Buffer, and return the encoded Buffer object asynchronously.
     *
     * @param format the image compress format, default is png. The available values are: png, jpg, jpeg, webp.
     * @param quality the image quality, range 0-100. The default value is 100.
     *
     */
    export function encodeImageToBuffer(img: Image, format?: ImageFormat, quality?: number): Promise<Buffer>;
    /**
     * @中文
     *
     * 将图片编码为二进制数据，并同步返回编码后的Buffer对象。
     *
     * @param format 图片压缩格式，默认为png。可选的值有：png、jpg、jpeg、webp。
     * @param quality 图片质量，范围0-100。默认值为100。
     *
     * @eng
     *
     * Encode the image to Buffer, and return the encoded Buffer object synchronously.
     *
     * @param format the image compress format, default is png. The available values are: png, jpg, jpeg, webp.
     * @param quality the image quality, range 0-100. The default value is 100.
     *
     */
    export function encodeImageToBufferSync(img: Image, format?: ImageFormat, quality?: number): Buffer;
    /**
     * @中文
     *
     * 从Buffer中解码图片，并异步返回解码后的图片对象。若无法解码，则抛出异常。
     *
     * @eng
     *
     * Decode the image from Buffer, and return the decoded image object asynchronously. If the decoding failed, throw an exception.
     *
     */
    export function decodeImageFromBuffer(buffer: Buffer): Promise<Image>;
    /**
     * @中文
     *
     * 从Buffer中解码图片，并同步返回解码后的图片对象。若无法解码，则抛出异常。
     *
     * @eng
     *
     * Decode the image from Buffer, and return the decoded image object synchronously. If the decoding failed, throw an exception.
     *
     */
    export function decodeImageFromBufferSync(buffer: Buffer): Image;
    export const MAX_LEVEL_AUTO = -1;
    /**
     * @中文
     *
     * 模板匹配选项，用于指定模板匹配的方法、匹配精度等。
     *
     * @eng
     *
     * Template matching options, used to specify the method of template matching, the matching accuracy etc.
     *
     * @see {@link findImage}
     *
     */
    export interface MatchTemplateOptions {
        readonly method?: number;
        readonly weakThreshold?: number;
        readonly threshold?: number;
        readonly level?: number;
        readonly max?: number;
        readonly useTransparentMask?: boolean;
        readonly region?: Region;
    }
    export interface Match {
        similarity: number;
        point: cv.Point2;
    }
    export type Region = cv.Rect | Array<number>;
    export interface FindImageOptions {
        readonly threshold?: number;
        readonly level?: number;
        readonly region?: Region;
    }
    /**
     * @中文
     *
     * 在大图中搜索小图，并返回匹配结果。通过找图选项可以指定匹配精度、搜索区域和图像金字塔级别。
     *
     * @param src 大图
     * @param template 小图，即模板图片
     * @param options 找图选项
     * @returns 模板图片在大图中的位置，或者null
     *
     * @eng
     *
     * Search for the template image in the larger image, and return the matching result. Using options to specify the matching accuracy, search region and image pyramid level.
     *
     * @param src the larger image
     * @param template the template image
     * @param options the find image options
     *
     * @example
     * ```javascript
     * "nodejs";
     *
     * const { requestScreenCapture } = require('media_projection')
     * const { findImage, readImage } = require('image');
     *
     * async function main() {
     *   const capturer = await requestScreenCapture();
     *   const template = await readImage("./template.png");
     *   const img = await capturer.nextImage();
     *   console.log(await findImage(img, template));
     * }
     * main();
     *
     * ```
     */
    export function findImage(src: Image, template: Image, options?: FindImageOptions): Promise<cv.Point2 | null>;
    export function findImageInRegion(src: Image, template: Image, x: number, y: number, width?: number, height?: number, threshold?: number): Promise<cv.Point2 | null>;
    export function findImageSync(src: Image, template: Image, options?: FindImageOptions): cv.Point2 | null;
    export function findImageInRegionSync(src: Image, template: Image, x: number, y: number, width?: number, height?: number, threshold?: number): cv.Point2 | null;
    export interface FindColorOptions {
        readonly threshold?: number;
        readonly region?: Region;
    }
    export function findColorSync(src: Image, color: Color, options: FindColorOptions): cv.Point2 | null;
    export function findColor(src: Image, color: Color, options: FindColorOptions): Promise<cv.Point2 | null>;
    export function detectsColor(src: Image, color: Color, x: number, y: number, options?: CompareColorOptions): boolean;
    export interface ColorPath {
        readonly firstColor: Color;
        offsetColors: Array<OffsetColor>;
    }
    export interface OffsetColor {
        readonly color: Color;
        readonly offsetX: number;
        readonly offsetY: number;
    }
    export function findMultiColorsSync(src: Image, colors: ColorPath, options?: FindColorOptions): cv.Point2 | null;
    export function findMultiColors(src: Image, colors: ColorPath, options?: FindColorOptions): Promise<cv.Point2 | null>;
    export function detectsMultiColors(src: Image, colors: ColorPath, x: number, y: number, options?: CompareColorOptions): boolean;
    export interface FeatureMatchingOptions extends DetectAndComputeFeaturesOptions {
        readonly matcher?: FeatureMatcher;
        readonly drawMatches?: string;
        readonly thredshold?: number;
        readonly region: Region;
    }
    export interface ObjectFrame {
        readonly topLeft: cv.Point2;
        readonly topRight: cv.Point2;
        readonly bottomLeft: cv.Point2;
        readonly bottomRight: cv.Point2;
        readonly center: cv.Point2;
        readonly centerX: number;
        readonly centerY: number;
    }
    export interface FeatureMatchingResult {
        readonly frame: ObjectFrame;
    }
    export function matchFeatures(scene: ImageFeatures, object: ImageFeatures, options?: FeatureMatchingOptions): Promise<ObjectFrame | null>;
    export function matchTemplate(src: Image, template: Image, options: MatchTemplateOptions): Promise<Array<Match>>;
    export function matchTemplateSync(src: Image, template: Image, options: MatchTemplateOptions): Array<Match>;
}
declare module "shell" {
    import EventEmitter from "events";
    /**
     * @中文
     *
     * shell命令执行结果。由{@link Shell.exec}和{@link exec}返回。
     *
     * @eng
     *
     * Shell command execution result. Returned by {@link Shell.exec} and {@link exec}.
     */
    export interface ExecutionResult {
        /**
         * @中文
         *
         * 命令执行的返回码，即退出代码。一般0表示执行成功，其他值表示执行失败。
         *
         * @eng
         *
         * Exit code of the command. 0 means success, other values mean failure.
         */
        readonly code: number;
        /**
         * @中文
         *
         * 命令执行的输出。包含标准输出和标准错误输出。
         *
         * @eng
         *
         * Output of the command. Includes standard output and standard error.
         */
        readonly output: string;
        /**
         * @中文
         *
         * 命令执行的标准输出。比如`ls`命令的stdout是文件列表。
         *
         * @eng
         *
         * Standard output of the command. For example, `ls` command's stdout is a list of files.
         */
        readonly stdout: string;
        /**
         * @中文
         *
         * 命令执行的标准错误输出。
         *
         * @eng
         *
         * Standard error of the command.
         */
        readonly stderr: string;
    }
    export type ExitResult = string | number;
    export type StandardOutputType = "stderr" | "stdout";
    /**
     * @中文
     *
     * Shell类，通过{@link createShell}创建新实例。
     *
     * @eng
     *
     * Shell class. Created new instance by {@link createShell}.
     */
    export interface Shell extends EventEmitter {
        /**
         * @中文
         *
         * 往shell的标准输入中提交文本内容，若文本内容末尾未包含换行符，则会自动添加换行符。
         *
         * @eng
         *
         * Submit text to shell's standard input. If the text does not end with a newline character, a newline character will be appended automatically.
         */
        submit(input: string): void;
        /**
         * @中文
         *
         * 执行shell命令，并等待执行结果。
         *
         * @param cmd 要执行的命令
         * @returns 执行结果的Promise
         *
         * @eng
         *
         * Execute a shell command and wait for the result asynchronously.
         *
         * @param cmd Shell command to execute
         * @returns Promise of the execution result
         *
         * @example
         * ```javascript
         * "nodejs";
         * const { createShell } = require('shell');
         * async function main() {
         *     const shell = createShell();
         *     console.log(await shell.exec("touch test.txt"));
         *     console.log(await shell.exec("ls -l test.txt"));
         *     await shell.exit();
         * }
         * main();
         * ```
         */
        exec(cmd: string): Promise<ExecutionResult>;
        /**
         * @中文
         *
         * 退出shell进程。若forcedly为true，则会直接杀死进程，此时返回值为字符串，表示杀死进程的signal；如果forcedly为false，则会使用`exit`命令退出shell进程，并返回退出码(exit code)。
         *
         * @param forcedly 是否强制退出
         *
         * @eng
         *
         * Exit the shell process. If forcedly is true, the process will be terminated and the return value will be a string representing the signal that killed the process. If forcedly is false, the process will be terminated by `exit` command and the return value will be the exit code.
         */
        exit(forcedly?: boolean): Promise<ExitResult>;
        /**
         * @中文
         *
         * shell的标准输出或标准输出结果有新数据的事件。`type`参数用于区分是标准输出还是标准错误输出。
         *
         * @event data
         *
         * @eng
         *
         * Event emitted when shell's standard output or standard error has new data. `type` parameter is used to distinguish standard output and standard error.
         *
         * @event data
         */
        on(event: "data", listener: ((chunk: Buffer, type: StandardOutputType) => void)): this;
        /**
         * @中文
         *
         * shell的标准输出或标准输出结果有新的一行数据的事件。`type`参数用于区分是标准输出还是标准错误输出。
         *
         * @event line
         *
         * @eng
         *
         * Event emitted when shell's standard output or standard error has new line. `type` parameter is used to distinguish standard output and standard error.
         *
         * @event line
         */
        on(event: "line", listener: ((line: string, type: StandardOutputType) => void)): this;
    }
    /**
     * @中文
     *
     * Shell选项。用于创建新的Shell或RootAutomator时指定。参见{@link createShell}和{@link setDefaultShellOptions}。
     *
     * @eng
     *
     * Shell options. Used to specify options when creating a new Shell or RootAutomator. See {@link createShell} and {@link setDefaultShellOptions}.
     */
    export interface ShellOptions {
        /**
         * @中文
         *
         * 是否使用Root权限。
         *
         * @eng
         *
         * Whether to use root permission.
         */
        root?: boolean;
        /**
         * @中文
         *
         * 启动进程的命令，比如`su`用于启动root进程。当此选项指定时，`root`选项将被覆盖。
         *
         * @eng
         *
         * Commands to start processes, such as `su` are used to start the root process. When this option is specified, the `root` option will be overridden.
         */
        cmd?: string;
        /**
         * @中文
         *
         * 是否使用adb shell（当前实现为Shizuku）。
         *
         * @eng
         *
         * Whether to use adb shell (currently implemented as Shizuku).
         */
        adb?: boolean;
        /**
         * @中文
         *
         * 环境变量，例如 `{PATH: "/data/local/tmp"}`。
         *
         * @eng
         *
         * Environment variables, e.g. `{PATH: "/data/local/tmp"}`.
         */
        env?: NodeJS.ProcessEnv;
    }
    /**
     * @中文
     *
     * 设置默认的Shell选项。这些选项包含是否使用Root权限、adb权限、环境变量等，会在创建新的Shell或RootAutomator实例时使用。
     *
     * @param options Shell选项
     *
     * @eng
     *
     * Set default options for Shell. These options include whether to use Root permission, adb permission, environment variables, etc. They will be used when creating new Shell or RootAutomator instance.
     *
     * @param options Shell options
     */
    export function setDefaultShellOptions(options: ShellOptions): void;
    /**
     * @中文
     *
     * 获取默认的Shell选项。
     *
     * @eng
     *
     * Get default options for Shell.
     *
     * @see {@link setDefaultShellOptions}
     */
    export function getDefaultShellOptions(): ShellOptions;
    /**
     * @中文
     *
     * 创建一个Shell实例。
     *
     * 我们通常用{@link exec}函数来一次性执行单条命令并获取结果，但如果有多条命令需要执行，用Shell对象的效率更高。这是因为无需每次执行都创建新的shell进程。
     *
     * 通过Shell对象我们也可监听到Shell的输出。
     *
     * @param options Shell选项，将覆盖默认的Shell选项
     * @returns Shell实例
     *
     * @eng
     *
     * Create a Shell instance.
     *
     * We usually use {@link exec} function to execute a single command and get the result, but if there are multiple commands to execute, the efficiency of Shell object is higher. This is because we don't need to create a new shell process every time we execute.
     *
     * We can also listen to Shell's output by using Shell object.
     *
     * @param options Shell options, will override default options
     * @returns New shell instance
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { createShell } = require("shell");
     * const shell = createShell();
     * shell.on("line", (line) => {
     *     console.log(line);
     * });
     * shell.exec("ls");
     *
     * const id = $autojs.keepRunning();
     * shell.exit().then(() => $autojs.cancelKeepRunning(id));
     *
     * ```
     */
    export function createShell(options?: ShellOptions): Shell;
    /**
     * @中文
     *
     * 创建一个新的shell进程，并执行命令，异步返回结果。
     *
     * @param cmd 要执行的命令
     * @param options Shell选项，将覆盖默认的Shell选项
     * @returns 执行结果的Promise
     *
     * @eng
     *
     * Create a new shell process, and execute a command, return the result asynchronously.
     *
     * @param cmd Command to execute
     * @param options Shell options, will override default options
     * @returns Promise of execution result
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { exec, isRootAvailable } = require("shell");
     * async function main() {
     *     console.log(await exec("npm"));
     *     if (await isRootAvailable()) {
     *        console.log(await exec("ls /data", { root: true }));
     *     }
     * }
     * main();
     * ```
     */
    export function exec(cmd: string, options?: ShellOptions): Promise<ExecutionResult>;
    export type PrivilegeType = "root" | "adb";
    /**
     * @中文
     *
     * 检查是否有特定的特权，比如是否有root权限。
     *
     * @param type 特权类型，比如"root"或"adb"
     * @returns 是否有该类型的特权的Promise
     *
     * @eng
     *
     * Check if there is a specific privilege, such as whether there is root permission.
     *
     * @param type Privilege type, such as "root" or "adb"
     * @returns Whether there is a specific privilege
     *
     * @example
     * ```javascript
     * "nodejs";
     *
     * const { checkAccess } = require("shell");
     * async function main() {
     *    const hasRoot = await checkAccess("root");
     *    const hasAdb = await checkAccess("adb");
     *    console.log(`hasRoot: ${hasRoot}, hasAdb: ${hasAdb}`);
     * }
     * main();
     * ```
     */
    export function checkAccess(type: PrivilegeType): Promise<boolean>;
    /**
     * @中文
     *
     * 检查设备是否已Root。需要注意的是，设备已Root不代表本应用已获得Root权限。
     *
     * @eng
     *
     * Check if device is rooted. Note that device is rooted does not mean this app has root permission.
     *
     * @example
     * ```javascript
     * "nodejs";
     *
     * const { isRootAvailable } = require("shell");
     * async function main() {
     *    const rootAvailable = await isRootAvailable();
     *    console.log(`rootAvailable: ${rootAvailable}`);
     * }
     * main();
     * ```
     */
    export function isRootAvailable(): Promise<boolean>;
    /**
     * @中文
     *
     * 使用默认的shell示例执行`input tab x y`命令，模拟点击位置(x, y)。
     *
     * 默认的shell示例在首次使用{@link Tap}, {@link Swipe}, {@link SendKey}, {@link InputText}等操作时会使用默认Shell选项{@link getDefaultShellOptions}自动创建。若您想让这些操作使用adb权限或特定Shell选项，应当在执行这些函数前使用{@link setDefaultShellOptions}设置Shell选项。
     *
     * 这些操作函数以大写字母开头，表示其通常需要root或adb权限，否则只能在本应用内生效。
     *
     *
     * @eng
     *
     * Use default shell instance to execute `input tab` command, simulate clicking position (x, y).
     *
     * Default shell instance will be created automatically when using {@link Tap}, {@link Swipe}, {@link SendKey}, {@link InputText} etc. If you want to use adb permission or specific shell options, you should use {@link setDefaultShellOptions} before using these functions.
     *
     * These functions start with uppercase letter, which means they require root or adb permission, otherwise they only work in this app.
     *
     * @example
     *
     * ```javascript
     * "nodejs";
     * const { Tap } = require("shell");
     * async function main() {
     *     await Tap(100, 100);
     * }
     * main();
     * ```
     */
    export function Tap(x: number, y: number): Promise<void>;
    /**
     * @中文
     *
     * 使用默认的shell示例执行`input swipe x1 y1 x2 y2 duration`命令，模拟从位置(x1, y1)滑动到位置(x2, y2)。
     *
     * 默认的shell示例在首次使用{@link Tap}, {@link Swipe}, {@link SendKey}, {@link InputText}等操作时会使用默认Shell选项{@link getDefaultShellOptions}自动创建。若您想让这些操作使用adb权限或特定Shell选项，应当在执行这些函数前使用{@link setDefaultShellOptions}设置Shell选项。
     *
     * 这些操作函数以大写字母开头，表示其通常需要root或adb权限，否则只能在本应用内生效。
     *
     * @param duration 滑动时间，单位毫秒
     *
     * @eng
     *
     * Use default shell instance to execute `input swipe x1 y1 x2 y2 duration` command, simulate sliding from position (x1, y1) to position (x2, y2).
     *
     * Default shell instance will be created automatically when using {@link Tap}, {@link Swipe}, {@link SendKey}, {@link InputText} etc. If you want to use adb permission or specific shell options, you should use {@link setDefaultShellOptions} before using these functions.
     *
     * These functions start with uppercase letter, which means they require root or adb permission, otherwise they only work in this app.
     *
     * @param duration Swipe duration, unit is millisecond
     *
     * @example
     *
     * ```javascript
     * "nodejs";
     * const { Swipe } = require("shell");
     * async function main() {
     *     await Swipe(800, 100, 800, 1000);
     * }
     * main();
     * ```
     */
    export function Swipe(x1: number, y1: number, x2: number, y2: number, duration?: number): Promise<void>;
    /**
     * @中文
     *
     * 使用默认的shell示例执行`input keyevent key`命令，模拟发送按键key。
     *
     * 默认的shell示例在首次使用{@link Tap}, {@link Swipe}, {@link SendKey}, {@link InputText}等操作时会使用默认Shell选项{@link getDefaultShellOptions}自动创建。若您想让这些操作使用adb权限或特定Shell选项，应当在执行这些函数前使用{@link setDefaultShellOptions}设置Shell选项。
     *
     * 这些操作函数以大写字母开头，表示其通常需要root或adb权限，否则只能在本应用内生效。
     *
     * @param key 按键名或按钮码，比如"HOME"或3表示Home按键，参见[KeyEvent](https://developer.android.com/reference/android/view/KeyEvent#KEYCODE_HOME)。
     *
     * @eng
     *
     * Use default shell instance to execute `input keyevent key` command, simulate sending key.
     *
     * Default shell instance will be created automatically when using {@link Tap}, {@link Swipe}, {@link SendKey}, {@link InputText} etc. If you want to use adb permission or specific shell options, you should use {@link setDefaultShellOptions} before using these functions.
     *
     * These functions start with uppercase letter, which means they require root or adb permission, otherwise they only work in this app.
     *
     * @param key Key name or key code, like "HOME" or 3, see [KeyEvent](https://developer.android.com/reference/android/view/KeyEvent#KEYCODE_HOME)
     *
     * @example
     *
     * ```javascript
     * "nodejs";
     * const { SendKey, setDefaultShellOptions } = require("shell");
     *
     * async function main() {
     *     setDefaultShellOptions({
     *        adb: true,
     *     });
     *     await SendKey("HOME");
     * }
     * main();
     * ```
     */
    export function SendKey(key: number | string): Promise<void>;
    /**
     * @中文
     *
     * 使用默认的shell示例执行`input text`命令，模拟输入文字。
     *
     * 默认的shell示例在首次使用{@link Tap}, {@link Swipe}, {@link SendKey}, {@link InputText}等操作时会使用默认Shell选项{@link getDefaultShellOptions}自动创建。若您想让这些操作使用adb权限或特定Shell选项，应当在执行这些函数前使用{@link setDefaultShellOptions}设置Shell选项。
     *
     * 这些操作函数以大写字母开头，表示其通常需要root或adb权限，否则只能在本应用内生效。
     *
     * @param text 要输入的文字，只支持ASCII字符，不支持中文
     *
     * @eng
     *
     * Use default shell instance to execute `input text` command, simulate inputting text.
     *
     * Default shell instance will be created automatically when using {@link Tap}, {@link Swipe}, {@link SendKey}, {@link InputText} etc. If you want to use adb permission or specific shell options, you should use {@link setDefaultShellOptions} before using these functions.
     *
     * These functions start with uppercase letter, which means they require root or adb permission, otherwise they only work in this app.
     *
     * @param text Text to input, only support ASCII characters
     *
     * @example
     *
     * ```javascript
     * "nodejs";
     * const { InputText } = require("shell");
     * async function main() {
     *     await InputText("Hello, World");
     * }
     * main();
     * ```
     */
    export function InputText(text: string): Promise<void>;
}
declare module "app" {
    import EventEmitter from 'events';
    /**
     *
     * @中文
     *
     * 当前应用的包名。
     *
     * 在Auto.js Pro中运行为`org.autojs.autojspro`，在打包应用中运行为打包应用的包名。
     *
     * @eng
     *
     * The package name of the current application.
     *
     * In Auto.js Pro, it is `org.autojs.autojspro`; in released app, it is the package name of the released app.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { packageName } = require("app");
     * console.log(packageName);
     * ```
     */
    export const packageName: string;
    /**
     * @中文
     *
     * Intent选项，用于构建一个Intent来启动一个Activity或者发送广播等。
     *
     * 有关Intent的详细信息，参见[Intent](https://developer.android.com/reference/android/content/Intent)。
     *
     * @eng
     *
     * Intent options, used to build an Intent to start an Activity or send a broadcast.
     *
     * For more information about Intent, see [Intent](https://developer.android.com/reference/android/content/Intent).
     */
    export interface IntentOptions {
        /**
         * @中文
         *
         * 启动Activity、发送广播的目标组件的类名。
         *
         * @eng
         *
         * Target component class name, such as the class name of activity, service or broadcast.
         */
        className?: string;
        /**
         * @中文
         *
         * 目标包名。 设置一个显式的应用程序包名，该包名将限制该Intent可解析的组件。如果设置为默认值null，则所有组件都将被视为可解析。如果不为null，则Intent只能解析到给定应用程序包名中的组件。
         *
         * @eng
         *
         * The package name of the component to start. If null, all components are considered.
         */
        packageName?: string;
        /**
         * @中文
         *
         * 以键值对构成的这个Intent的Extras(额外信息)。提供该意图的其他信息，例如发送邮件时的邮件标题、邮件正文。参见[Extras](https://developer.android.com/reference/android/content/Intent.html#standard-extra-data)。
         *
         * @eng
         *
         * The Extras(extra information) of this Intent. Provide extra information for this Intent, such as the title of the email when sending an email. See [Extras](https://developer.android.com/reference/android/content/Intent.html#standard-extra-data).
         */
        extras?: any;
        /**
         * @中文
         *
         * 意图的类别。比较少用。参见[Categories](https://developer.android.com/reference/android/content/Intent.html#standard-categories)
         *
         * @eng
         *
         * The category of this Intent. See [Categories](https://developer.android.com/reference/android/content/Intent.html#standard-categories)
         */
        category?: string | Array<string>;
        /**
         * @中文
         *
         * 意图的Action，指意图要完成的动作，是一个字符串常量，比如"android.intent.action.SEND"。当action以"android.intent.action"开头时，可以省略前缀，直接用"SEND"代替。参见[Actions](https://developer.android.com/reference/android/content/Intent.html#standard-activity-actions)。
         *
         * @eng
         *
         * Set the general action to be performed, such as "android.intent.action.SEND". When the action starts with "android.intent.action", you can omit the prefix and use "SEND" instead. See [Actions](https://developer.android.com/reference/android/content/Intent.html#standard-activity-actions).
         *
         */
        action?: string;
        /**
         * @中文
         *
         * intent的额外标识，字符串或number数组，例如`["activity_new_task", "grant_read_uri_permission"]`。参见[Flags](https://developer.android.com/reference/android/content/Intent.html#setFlags%28int%29)。
         *
         * @eng
         *
         * The flags of the intent, an array of strings or numbers, e.g. `["activity_new_task", "grant_read_uri_permission"]`. See [Flags](https://developer.android.com/reference/android/content/Intent.html#setFlags%28int%29).
         * Set special flags controlling how this intent is handled. Most values here depend on the type of component being executed by the Intent, specifically the FLAG_ACTIVITY_* flags are all for use with Context.startActivity() and the FLAG_RECEIVER_* flags are all for use with Context.sendBroadcast().
         *
         */
        flags?: (string | number)[];
        /**
         * @中文
         *
         * 意图的MimeType，表示和该意图直接相关的数据的类型，表示比如"text/plain"为纯文本类型。
         *
         * @eng
         *
         * Set an explicit MIME data type.
         * This is used to create intents that only specify a type and not data, for example to indicate the type of data to return.
         *
         * Note: MIME type matching in the Android framework is case-sensitive, unlike formal RFC MIME types. As a result, you should always write your MIME types with lower case letters, or use normalizeMimeType(String) or setTypeAndNormalize(String) to ensure that it is converted to lower case.
         */
        type?: string;
        /**
         * @中文
         *
         * 意图的Data，表示和该意图直接相关的数据，是一个Uri, 可以是文件径或者Url等。例如要打开一个文件, action为"android.intent.action.VIEW", data为"file:///sdcard/1.txt"。
         *
         * @eng
         *
         * Set the data this intent is operating on, e.g. "https://www.google.com", "file://sdcard/1.txt".
         *
         * Note: scheme matching in the Android framework is case-sensitive, unlike the formal RFC. As a result, you should always write your Uri with a lower case scheme, or use Uri#normalizeScheme or setDataAndNormalize(Uri) to ensure that the scheme is converted to lower case.
         */
        data?: string | android.net.Uri;
    }
    /**
     * @中文
     *
     * 允许使用Root权限的Intent选项。Intent选项用于构建一个Intent来启动一个Activity或者发送广播等。
     *
     * 有关Intent的详细信息，参见[Intent](https://developer.android.google.cn/reference/android/content/Intent)。
     *
     * @eng
     *
     * Intent options that allow the use of the root permission. Intent options are used to build an Intent to start an Activity or send a broadcast.
     *
     * For more information about Intents, see [Intent](https://developer.android.google.cn/reference/android/content/Intent).
     *
     * @see {@link startActivity}
     * @see {@link sendBroadcast}
     */
    export interface IntentOptionsWithRoot extends IntentOptions {
        /**
         * @中文
         *
         * 是否使用Root权限，用于启动Service、Activity等。
         *
         * @eng
         *
         * Whether to use the root permission to start the service, activity, etc.
         */
        root?: boolean | undefined;
    }
    /**
     * @中文
     *
     * 根据Intent选项构造一个新的Intent。
     *
     * Intent(意图) 是一个消息传递对象，您可以使用它从其他应用组件请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：
     * * 启动活动(Activity)：
     *     Activity 表示应用中的一个"屏幕"。例如应用主入口都是一个Activity，应用的功能通常也以Activity的形式独立，例如微信的主界面、朋友圈、聊天窗口都是不同的Activity。通过将 Intent 传递给 startActivity()，您可以启动新的 Activity 实例。Intent 描述了要启动的 Activity，并携带了任何必要的数据。
     * * 启动服务(Service)：
     *     Service 是一个不使用用户界面而在后台执行操作的组件。通过将 Intent 传递给 startService()，您可以启动服务执行一次性操作（例如，下载文件）。Intent 描述了要启动的服务，并携带了任何必要的数据。
     * * 传递广播：
     *     广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将 Intent 传递给 sendBroadcast()、sendOrderedBroadcast() 或 sendStickyBroadcast()，您可以将广播传递给其他应用。
     *
     * 需要注意的是，除非应用专门暴露Activity出来，否则在没有root权限的情况下使用intent是无法跳转到特定Activity、应用的特定界面的。例如我们能通过Intent跳转到QQ的分享界面，是因为QQ对外暴露了分享的Activity；而在没有root权限的情况下，我们无法通过intent跳转到QQ的设置界面，因为QQ并没有暴露这个Activity。
     * 但如果有root权限，则在intent的参数加上`"root": true`即可。例如使用root权限跳转到Auto.js的设置界面为：
     * ```
     * "nodejs";
     * const { startActivity } = require("app");
     * startActivity({
     *     packageName: "org.autojs.autojspro",
     *     className: "org.autojs.autojs.ui.settings.SettingsActivity",
     *     root: true
     * });
     * ```
     *
     * @param options 构建Intent的选项
     * @returns 新的Intent对象
     *
     * @eng
     *
     * Build a new intent from options.
     *
     * An intent is an abstract description of an operation to be performed. It can be used with startActivity to launch an Activity, broadcastIntent to send it to any interested BroadcastReceiver components, and Context.startService(Intent) or Context.bindService(Intent, ServiceConnection, int) to communicate with a background Service.
     *
     * An Intent provides a facility for performing late runtime binding between the code in different applications. Its most significant use is in the launching of activities, where it can be thought of as the glue between activities. It is basically a passive data structure holding an abstract description of an action to be performed.
     *
     *
     * @param options intent options to build intent
     * @returns The new intent object
     *
     * @example
     * ```javascript
     * "nodejs";
     * const app = require("app");
     * const i = app.makeIntent({
     *     action: "VIEW",
     *     type: "image/png",
     *     data: "file:///sdcard/1.png"
     * });
     * $autojs.androidContext.startActivity(i);
     * ```
     *
     */
    export function makeIntent(options: IntentOptions): any;
    /**
     *
     * @中文
     *
     * 根据选项构造一个Intent，并启动该Activity。
     *
     * @param target 目标activity的名称或者根据Intent选项构造的Activity Intent。若target为字符串，则：
     *  * console: 启动日志Activity
     *  * settings: 启动设置Activity
     * @returns Promise，如果是使用root权限，则会等待执行shell命令后返回；如果不是使用root权限，则会直接返回。**不管如何，都不会等待Activity启动才返回。**
     *
     *
     * @eng
     *
     * Build a new intent from options and start the activity.
     *
     * @param target activity name or activity intent to start. If target is a string, then:
     * * console: start LogActivity
     * * settings: start SettingsActivity
     * @returns Promise, if using root permission, will wait for shell command to finish; if not using root permission, will return immediately. **Never wait for activity to start before returning.**
     *
     * @see {@link makeIntent}
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { startActivity } = require("app");
     * startActivity({
     *     action: "SEND",
     *     type: "text/plain",
     *     data: "file:///sdcard/1.txt"
     * });
     * ```
     */
    export function startActivity(target: "console" | "settings" | IntentOptionsWithRoot): Promise<void>;
    /**
     * @中文
     *
     * 根据选项构造一个Intent，并启动该服务。
     *
     * @param target 构造Service Intent的选项
     * @returns Promise，如果是使用root权限，则会等待执行shell命令后返回；如果不是使用root权限，则会直接返回。**不管如何，都不会等待Service启动才返回。**
     *
     * @eng
     *
     * Build a new intent from options and start the service.
     *
     * @param target service options to build service intent
     * @returns Promise, if using root permission, will wait for shell command to finish; if not using root permission, will return immediately. **Never wait for service to start before returning.**
     *
     * @see {@link makeIntent}
     *
     */
    export function startService(target: IntentOptionsWithRoot): Promise<void>;
    /**
     * @中文
     *
     * 根据选项构造一个Intent，并发送该广播。
     *
     * @param target 目标广播的名称或者根据Intent选项构造的广播 Intent。若target为字符串，则：
     *     * `inspect_layout_hierarchy` 布局层次分析
     *     * `inspect_layout_bounds` 布局范围分析
     * 但是这些广播在打包后应用中不可用。
     *
     * @returns Promise，如果是使用root权限，则会等待执行shell命令后返回；如果不是使用root权限，则会直接返回。
     *
     * @eng
     *
     * Build a new intent from options and send the broadcast.
     *
     * @param target broadcast name or broadcast intent to send. If target is a string, then:
     *   * `inspect_layout_hierarchy` inspect layout hierarchy
     *   * `inspect_layout_bounds` inspect layout bounds
     * But these broadcasts are not available in release apps.
     *
     * @returns Promise, if using root permission, will wait for shell command to finish; if not using root permission, will return immediately.
     *
     * @see {@link makeIntent}
     *
     */
    export function sendBroadcast(target: IntentOptionsWithRoot): Promise<void>;
    /**
     * @中文
     *
     * 发送邮件的选项
     *
     * @eng
     *
     * Options to send email
     *
     * @see {@link sendEmail}
     */
    export interface EmailOptions {
        /**
         * @中文
         *
         * 收件人的邮件地址。如果有多个收件人，则用字符串数组表示
         *
         * @eng
         *
         * Email address of the recipient. If there are multiple recipients, then use an array to represent them.
         */
        email: string | Array<string>;
        /**
         * @中文
         *
         * 抄送收件人的邮件地址。如果有多个抄送收件人，则用字符串数组表示
         *
         * @eng
         *
         * Email address of the carbon copy recipient. If there are multiple carbon copy recipients, then use an array to represent them.
         *
         */
        cc?: string | Array<string>;
        /**
         * @中文
         *
         * 密送收件人的邮件地址。如果有多个密送收件人，则用字符串数组表示
         *
         * @eng
         *
         * Email address of the blind carbon copy recipient. If there are multiple blind carbon copy recipients, then use an array to represent them.
         */
        bcc?: string | Array<string>;
        /**
         * @中文
         *
         * 邮件主题(标题)
         *
         * @eng
         *
         * Email subject(title).
         *
         */
        subject?: string;
        /**
         * @中文
         *
         * 邮件正文
         *
         * @eng
         *
         * Email body.
         */
        text?: string;
        /**
         * @中文
         *
         * 附件的路径。
         *
         * @eng
         *
         * Path of the attachment.
         */
        attachment?: string;
        /**
         * @中文
         *
         * 若有多个邮件应用，该标题会在用户选择界面显示。
         *
         * @eng
         *
         * If there are multiple email applications, this title will be displayed in the user selection interface.
         */
        chooserTitle?: string;
    }
    /**
     * @中文
     *
     * 启用发送邮件的应用。如果没有安装邮箱应用，则抛出`ActivityNotException`。
     *
     * @param options 邮件发送选项
    
    * @eng
     *
     * Start the email application. If there is no email application, then throw `ActivityNotException`.
     *
     * @param options Email sending options
     *
     */
    export function sendEmail(options: EmailOptions): void;
    /**
     * @中文
     *
     * 通过应用名称启动应用。如果该名称对应的应用不存在，则返回false；否则返回true。如果该名称对应多个应用，将随机启动其中一个。
     *
     * **注意！**在高版本Android或部分系统上，会限制通过后台启动应用，也即在后台的情况下即使返回true，也可能没有实际启动该应用。
     *
     * @param targetAppName 要启动的应用名称
     * @returns 是否找到该应用，并不返回是否真正启动成功
     *
     * @eng
     *
     * Start the application by application name. If the application does not exist, then return false; otherwise return true. If the application name corresponds to multiple applications, then randomly start one of them.
     *
     * **Note!** On some Android versions, the application may be limited to start in the background, even if the return value is true, and it may not actually start the application.
     *
     * @param targetAppName Name of the application to start
     * @returns Whether the application exists, instead of whether it is actually launched successfully.
     *
     * @see [Restrictions on starting activities from the background](https://developer.android.com/guide/components/activities/background-starts)
     *
     */
    export function launchApp(targetAppName: string): boolean;
    /**
     * @中文
     *
     * 获取应用名称对应的已安装的应用的包名。如果该找不到该应用，返回null；如果该名称对应多个应用，则只返回其中某一个的包名。
     *
     * @param targetAppName 应用名称
     * @returns 名称对应的包名，或者null
     *
     * @eng
     *
     * Get the package name corresponding to the application name. If the application does not exist, then return null; if the application name corresponds to multiple applications, then only return the package name of one of them.
     *
     * @param targetAppName Application name
     * @returns Package name, or null
     *
     */
    export function getPackageName(targetAppName: string): string | null;
    /**
     * @中文
     *
     * 通过应用包名启动应用。如果该包名对应的应用不存在，则返回false；否则返回true。
     *
     * **注意！**在高版本Android或部分系统上，会限制通过后台启动应用，也即在后台的情况下即使返回true，也可能没有实际启动该应用。
     *
     * @param packageName 要启动的应用包名
     * @returns 是否找到该应用，并不返回是否真正启动成功
     *
     * @eng
     *
     * Start the application by package name. If the application does not exist, then return false; otherwise return true.
     *
     * **Note!** On some Android versions, the application may be limited to start in the background, even if the return value is true, and it may not actually start the application.
     *
     * @param packageName Package name of the application to be launched.
     * @returns Whether the application exists, instead of whether it is actually launched successfully.
     *
     * @see [Restrictions on starting activities from the background](https://developer.android.com/guide/components/activities/background-starts)
     *
     */
    export function launch(packageName: string): boolean;
    /**
     * @中文
     *
     * 根据选项构造一个Intent，转换为对应的shell的intent命令的参数。
     *
     * @param options Intent选项
     *
     * @returns 对应的shell的intent命令的参数
     *
     * @eng
     *
     * Construct an Intent according to the options, and convert it to the corresponding shell intent command parameters.
     *
     * @param options Intent options
     *
     * @returns The corresponding shell intent command parameters
     *
     * @see [adb am](https://developer.android.com/studio/command-line/adb#am)
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { intentToShell } = require("app");
     * const { exec } = require("shell");
     * exec("am start " + intentToShell({
     *     packageName: "org.autojs.autojs",
     *     className: "org.autojs.autojs.ui.settings.SettingsActivity_"
     * }), { root: true});
     * ```
     */
    export function intentToShell(options: IntentOptions): string;
    /**
     * @中文
     * 解析uri字符串并返回相应的Uri对象。即使Uri格式错误，该函数也会返回一个Uri对象，但之后如果访问该对象的scheme, path等值可能因解析失败而返回`null`。
     *
     * 在高版本Android上，由于系统限制直接在Uri暴露文件的绝对路径，因此如果uri字符串是文件`file://...`，返回的Uri会是诸如`content://...`的形式。
     *
     * @param uri uri字符串或uri对象，后者直接返回uri自身
     * @returns 解析后的Uri对象
     *
     * @eng
     *
     * Parse uri string or uri object and return the corresponding Uri object. If the uri string is invalid, the function will return a Uri object, but the values of scheme, path, etc. may be `null`.
     *
     * On higher version Android, since the system restricts the absolute path of a file, the Uri returned by this function may be a content uri like `content://...` if the uri string is `file://...`
     *
     * @param uri uri string or uri object, the latter directly return the uri itself
     * @returns parsed Uri object
     *
     */
    export function parseUri(uri: string | android.net.Uri): android.net.Uri;
    /**
     *
     * @中文
     *
     * 从一个文件路径创建一个uri对象在高版本Android上，由于系统限制直接在Uri暴露文件的绝对路径，因此返回的Uri会是诸如`content://...`的形式。
     *
     * @param pathOrUri 文件路径或文件uri，比如"/sdcard/1.txt"或"file:///sdcard/1.txt"
     * @returns 文件uri，可作为Intent的data属性
     *
     * @eng
     *
     * Create a uri object from a file path or uri string. In higher version Android, the uri returned will be a content uri.
     *
     * @param pathOrUri pathOrUri file path or file uri, for example "/sdcard/1.txt" or "file:///sdcard/1.txt"
     * @returns file uri, can be used as Intent's data property
     */
    export function getUriForFile(pathOrUri: string): android.net.Uri;
    /**
     *
     * @中文
     *
     * 获取应用包名对应的已安装的应用的名称。如果该找不到该应用，返回null。
     *
     * @param packageName 应用包名
     * @returns 应用名称，或者null
     *
     * @eng
     *
     * Get the app name for the given package name. If the app of the given package name is not found, returns null.
     *
     * @param packageName package name
     * @returns the app name of the given package name, or null if not found
     */
    export function getAppName(packageName: string): string | null;
    /**
     * @中文
     *
     * 打开应用的详情页(设置页)。如果找不到该应用，返回false; 否则返回true。
     *
     * @param packageName 包名
     * @returns 是否成功打开应用设置页
     *
     * @eng
     *
     * Open the details page of the app. If the app is not found, return false; otherwise return true.
     *
     * @param packageName package name
     * @returns whether the app is found
     *
     */
    export function openAppSettings(packageName: string): boolean;
    /**
     * @中文
     *
     * 卸载应用。执行后会会弹出卸载应用的提示框。如果该包名的应用未安装，由应用卸载程序处理，可能弹出"未找到应用"的提示。
     *
     * @param packageName 包名
     *
     * @eng
     *
     * Uninstall application. Will pop up uninstall application dialog. If the package name of the application is not installed, the application uninstaller will handle it, which may pop up a "not found" prompt.
     *
     * @param packageName the package name to uninstall
     *
     */
    export function uninstall(packageName: string): void;
    /**
     * @中文
     *
     * 用其他应用查看文件。文件不存在的情况由查看文件的应用处理。
     * 如果找不出可以查看该文件的应用，则抛出`ActivityNotException`。
     * ```
     * "nodejs";
     * const app = require("app");
     * app.viewFile("/sdcard/1.txt");
     * ```
     * @param file 文件路径
     *
     * @eng
     *
     * Open file with other apps. The case of file not exist will be handled by the app that open the file.
     * If can't find the app to open the file, it will throw `ActivityNotException`.
     *
     */
    export function viewFile(file: string): void;
    /**
     *
     * @中文
     *
     * 用其他应用编辑文件。文件不存在的情况由编辑文件的应用处理。
     * 如果找不出可以编辑该文件的应用，则抛出`ActivityNotException`。
     *
     * @param file 文件路径
     *
     * @eng
     *
     * Edit file with other apps. The case that file does not exist is handled by the third party app.
     * If no app can edit the file, then throw `ActivityNotException`.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const app = require("app");
     * app.editFile("/sdcard/1.txt/");
     * ```
     */
    export function editFile(file: string): void;
    /**
     * @中文
     *
     * 用浏览器打开网站url。
     * 如果没有安装浏览器应用，则抛出`ActivityNotException`。
     *
     * @param url 网站的Url，需要以"http://"或"https://"开头。
     *
     * @eng
     *
     * Open website with browser.
     * If no browser app installed, then throw `ActivityNotException`.
     *
     * @param url The url of the website, must start with "http://" or "https://".
     *
     */
    export function openUrl(url: string): void;
    /**
     * @中文
     *
     * 获取已安装的应用列表的过滤选项。
     *
     * @eng
     *
     * The filter options of the installed apps.
     *
     * @see {@link getInstalledApps}
     */
    export interface PMOptions {
        /**
         * @中文
         *
         * 指定返回的应用信息中包含的信息，例如`["activities", "meta_data"]`。
         *
         * 可能的值包括：
         *
         * * `"activities"` 应用的Activity组件信息
         * * `"configurations"` 应用的硬件配置
         * * `"gids"` 应用的group id
         * * `"instrumentation"` 应用的Instrumentation信息
         * * `"intent_filters"` 应用的意图过滤
         * * `"meta_data"` 应用的元信息（默认）
         * * `"permissions"` 应用的权限信息
         * * `"providers"` 应用的ContentProvider组件信息
         * * `"receivers"` 应用的BroadcastReceiver组件信息
         * * `"services"` 应用的Service组件信息
         * * `"shared_library_files"` 应用的动态链接库文件信息
         * * `"signatures"` 应用的签名信息（已弃用
         * * `"signing_certificates"` 应用的签名信息
         * * `"uri_permission_patterns"`
         * * `"disabled_components"` 被卸载的但保留了数据的应用
         * * `"disabled_until_used_components"` 禁用直到被使用的组件
         * * `"uninstalled_packages"` 被卸载的但保留了数据的应用
         *
         * @eng
         *
         * The information of the app to be returned, for example `["activities", "meta_data"]`.
         *
         * Possible values include:
         *
         * * `"activities"` The activity components of the app
         * * `"configurations"` The hardware configuration of the app
         * * `"gids"` The group id of the app
         * * `"instrumentation"` The instrumentation of the app
         * * `"intent_filters"` The intent filters of the app
         * * `"meta_data"` The meta data of the app (default)
         * * `"permissions"` The permissions of the app
         * * `"providers"` The content provider components of the app
         * * `"receivers"` The broadcast receiver components of the app
         * * `"services"` The service components of the app
         * * `"shared_library_files"` The shared library files of the app
         * * `"signatures"` The signatures of the app (deprecated)
         * * `"signing_certificates"` The signing certificates of the app
         * * `"uri_permission_patterns"`
         * * `"disabled_components"` The disabled components of the app
         * * `"disabled_until_used_components"` The disabled until used components of the app
         * * `"uninstalled_packages"` The uninstalled packages of the app
         *
         * @see [PackageManager.GET_*](https://developer.android.com/reference/android/content/pm/PackageManager#GET_ACTIVITIES)
         */
        get?: Array<string>;
        /**
         * @中文
         *
         * 指定要匹配的应用列表，例如`["disabled_components", "uninstalled_packages"]`。
         *
         * * `"uninstalled_packages"` 被卸载的但保留了数据的应用
         * * `"disabled_components"` 被禁用的组件
         * * `"disabled_until_used_components"` 禁用直到被使用的组件
         * * `"system_only"` 只匹配系统应用
         * * `"factory_only"` 只匹配预装应用
         * * `"apex"` APEX应用
         *
         * @eng
         *
         * The list of apps to be matched, for example `["disabled_components", "uninstalled_packages"]`.
         *
         * * `"uninstalled_packages"` Flag parameter to retrieve some information about all applications (even uninstalled ones) which have data directories. This state could have resulted if applications have been deleted with flag DELETE_KEEP_DATA with a possibility of being replaced or reinstalled in future.
         *      Note: this flag may cause less information about currently installed applications to be returned.
         *      Note: use of this flag requires the android.permission.QUERY_ALL_PACKAGES permission to see uninstalled packages.
         * * `"disabled_components"` include disabled components in the returned info
         * * `"disabled_until_used_components"` nclude disabled components which are in that state only because of COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED in the returned info. Note that if you set this flag, applications that are in this disabled state will be reported as enabled
         * * `"system_only"`  include only components from applications that are marked with ApplicationInfo#FLAG_SYSTEM.
         * * `"factory_only"` The factory only apps
         * * `"apex"`  include APEX packages that are currently installed. In APEX terminology, this corresponds to packages that are currently active, i.e. mounted and available to other processes of the OS. In particular, this flag alone will not match APEX files that are staged for activation at next reboot.
         *
         * @see [PackageManager.MATCH_*](https://developer.android.com/reference/android/content/pm/PackageManager#MATCH_SYSTEM_ONLY)
         */
        match?: Array<string>;
    }
    /**
     * @中文
     *
     * 获取安装的应用列表。
     *
     * 返回值是ApplicationInfo对象的数组。 如果没有安装任何应用，则返回一个空数组。
     *
     * 选项options的match选项用于指定要返回哪些应用程序，get选项用于指定返回的应用程序携带哪些信息。
     *
     * @eng
     *
     * Get the list of installed applications.
     *
     * Returns an array of ApplicationInfo objects. If there are no installed applications, an empty array is returned.
     *
     * Options options.match specifies which applications to return. Options options.get specifies which information about each application to return.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const app = require("app");
     * const apps = app.getInstalledApps({
     *     get: ['meta_data'],
     *     match: ['system_only']
     * });
     * console.log(apps);
     * ```
     * @param options 过滤选项
     * @returns 为当前用户安装的所有应用程序包的列表。如果设置了match选项 `uninstalled_packages`，则包括被删除但保留了数据的应用程序。
     *
     * @see [PackageManager.getInstalledApplication](https://developer.android.com/reference/android/content/pm/PackageManager#getInstalledApplications(int))
     *
     */
    export function getInstalledApps(options?: PMOptions): Array<android.content.pm.ApplicationInfo>;
    /**
     *
     * @中文
     *
     * 获取安装的应用列表。
     *
     * @param options 过滤选项
     * @returns PackageInfo对象的数组。 如果没有安装任何应用，则返回一个空数组。
     *
     * @eng
     *
     * Get the list of installed applications.
     *
     * @param options options.match specifies which applications to return. Options options.get specifies which information about each application to return.
     * @returns An array of PackageInfo objects. If there are no installed applications, an empty array is returned.
     *
     * @see [PackageManager.getInstalledPackages](https://developer.android.com/reference/android/content/pm/PackageManager#getInstalledPackages(int))
     *
     */
    export function getInstalledPackages(options?: PMOptions): Array<android.content.pm.PackageInfo>;
    /**
     * @中文
     *
     * 解析apk文件并返回包信息。
     *
     * @param file 文件路径
     * @param options 过滤选项
     * @returns 包信息，若apk无法解析，返回null
     *
     * @eng
     *
     * Parse an APK file and return the package info.
     *
     * @param file The file path.
     * @param options the filter options
     * @returns A PackageInfo object containing information about the package archive. If the package could not be parsed, returns null.
     *
     * @see [PackageManager.getPackageArchiveInfo](https://developer.android.com/reference/android/content/pm/PackageManager#getPackageArchiveInfo(java.lang.String,%20int))
     *
     * @example
     * ```javascript
     * "nodejs";
     * const app = require("app");
     * const info = app.getApkInfo("/path/to/apk", {
     *    get: ['meta_data'],
     * });
     * console.log(info.packageName);
     * ```
     *
     */
    export function getApkInfo(file: string, options?: PMOptions): android.content.pm.PackageInfo | null;
    export interface BroadcastReceiver extends EventEmitter {
        on(event: "receive", listener: (intent: android.content.Intent) => void): this;
    }
    export function registerBroadcastReceiver(filter: string | string[] | android.content.IntentFilter): BroadcastReceiver;
    export function unregisterBroadcastReceiver(receiver: BroadcastReceiver): void;
}
declare module "ui/view" {
    import EventEmitter from "events";
    type View = android.view.View;
    export interface ViewBinding {
        readonly [viewId: string]: JsView<View>;
    }
    export interface Extras {
        [key: string]: any;
    }
    export type JsView<T extends View> = T & JsViewExt<T>;
    export interface JsViewExt<T> extends EventEmitter {
        findView<T extends View>(id: string): JsView<T> | null;
        attr(attrName: string): string | null | undefined;
        attr(attrName: string, value: string | null): void;
        readonly binding: ViewBinding;
        readonly extras: Extras;
        clearViewBindingCache(): void;
    }
    export interface ViewEvent {
        consumed: boolean;
        view: View;
    }
    export type AttributeValue = string | null | undefined;
    export interface WidgetAttributes {
        [key: string]: AttributeValue;
    }
    export type WidgetClass = {
        new (): Widget;
    };
    /**
     * 1. created
     * 2. render
     * 3. rootViewCreated: root view created but children are not inflated
     * 4. inflated: children inflated and internal and initial attributes are applied, but external attributes are not applied
     * 5. mounted: external attributes applied
     */
    export abstract class Widget {
        attrs: WidgetAttributes;
        private _view?;
        get view(): JsView<android.view.View>;
        created(): void;
        get initialAttributes(): WidgetAttributes;
        rootViewCreated(view: JsView<android.view.View>): void;
        inflated(): void;
        mounted(): void;
        abstract render(context: android.content.Context, parent: android.view.ViewGroup): string | android.view.View;
        getAttribute(name: string, def: () => AttributeValue): AttributeValue;
        setAttribute(name: string, value: AttributeValue, def: (value: AttributeValue) => void): void;
        hasAttribute(name: string): boolean;
        static register(name: string, widget: WidgetClass): void;
        static create(name: string): Widget | undefined;
        static of<W extends Widget>(view: View): W | undefined;
        private static propForAttr;
        private static widgets;
    }
}
declare module "ui/web" {
    import EventEmitter from "events";
    export interface IPCEvent {
        readonly name: string;
    }
    export interface InvokeEvent {
        readonly channel: string;
        readonly arguments: Array<any>;
    }
    export type InvokeRequestHandler = (event: InvokeEvent, ...args: any) => any | Promise<any>;
    export interface JavaScriptBridge extends EventEmitter {
        eval(code: string): Promise<any>;
        handle(action: string | null | undefined, handler: InvokeRequestHandler): this;
        invoke(channel: string, ...args: any): Promise<any>;
        send(event: string, ...args: any): void;
        on(event: string, listener: ((event: IPCEvent, ...args: any) => void)): this;
    }
    export interface JsWebView extends android.webkit.WebView {
        readonly jsBridge: JavaScriptBridge;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        removeListener(event: string | symbol, listener: (...args: any[]) => void): this;
        off(event: string | symbol, listener: (...args: any[]) => void): this;
        removeAllListeners(event?: string | symbol): this;
        setMaxListeners(n: number): this;
        getMaxListeners(): number;
        listeners(event: string | symbol): Function[];
        rawListeners(event: string | symbol): Function[];
        emit(event: string | symbol, ...args: any[]): boolean;
        listenerCount(event: string | symbol): number;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
        eventNames(): Array<string | symbol>;
    }
}
declare module "ui/layout" {
    import { JsView } from "ui/view";
    type Context = android.content.Context;
    type ViewGroup = android.view.ViewGroup;
    type View = android.view.View;
    export interface Resources {
        [type: string]: Resource;
    }
    export interface Resource {
        [name: string]: number;
    }
    /**
     * @中文
     *
     * 类似于Android中的R，用于获取资源相关的ID，比如`R.drawable.ic_launcher`，`R.style.ScriptTheme`等。
     *
     * @eng
     *
     * Similar to Android's R, used to get resource related ID, such as `R.drawable.ic_launcher` and `R.style.ScriptTheme`.
     *
     * @example
     * ```javascript
     * "nodejs";
     *
     * const { R } = require("ui");
     *
     * const context = $autojs.androidContext;
     * console.log(context.getDrawable(R.drawable.ic_delete))
     *
     * ```
     * @see https://developer.android.com/reference/android/R
     */
    export const R: Resources;
    /**
     * @中文
     *
     * 解析xm内容并创建其对应的View树。若解析失败则抛出[InflateException](https://developer.android.com/reference/android/view/InflateException)异常。
     *
     * @param ctx Android [Context](https://developer.android.com/reference/android/content/Context)对象，若要创建androidx相关的View，则必须指定Material相关主题的Context
     * @param xml xml内容
     * @param parent 若attachToRoot为false，则指定parent为新创建的View的父View；若attachToRoot为false，则parent为解析xml过程中用于生成LayoutParams的View。默认为null。
     * @param attachToParent 创建新View后是否添加到parent中，默认为false
     * @returns
     *
     * @eng
     *
     * Inflate a new view hierarchy from the specified xml resource. Throws InflateException if there is an error.
     *
     * @param ctx Android [Context](https://developer.android.com/reference/android/content/Context), if you want to create androidx-related views, you must specify a Material-related theme context
     * @param xml xml content
     * @param parent Optional view to be the parent of the generated hierarchy (if attachToRoot is true), or else simply an object that provides a set of LayoutParams values for root of the returned hierarchy (if attachToRoot is false.)
     * @param Whether the inflated hierarchy should be attached to the root parameter? If false, root is only used to create the correct subclass of LayoutParams for the root view in the XML.
     */
    export function inflateXml(ctx: Context, xml: string, parent?: ViewGroup, attachToParent?: boolean): JsView<View>;
    /**
     * @中文
     *
     * 获取默认主题的Context。
     *
     * @eng
     *
     * Get the default theme context.
     */
    export function defaultThemeContext(): Context;
}
declare module "ui/util" {
    /**
     * @中文
     *
     * 判断当前线程是否是UI线程
     *
     * @returns 是否是UI线程
     *
     * @eng
     *
     * Whether the current thread is UI thread
     *
     * @returns Whether the current thread is UI thread
     */
    export function isUiThread(): boolean;
}
declare module "ui/activity" {
    import EventEmitter from "events";
    import { Color } from "color";
    import * as app from "app";
    const android: typeof globalAndroid;
    const AndroidActivity: (typeof android.app.Activity);
    export interface StatusBarConfig {
        readonly color: Color | string | number;
        readonly light?: boolean;
    }
    export class Activity extends AndroidActivity {
        protected insetsController: JavaObject;
        constructor();
        onCreate(savedInstanceState?: android.os.Bundle): void;
        protected get layoutXml(): string | null;
        protected get layoutXmlFile(): string | null;
        protected get layoutId(): number | null;
        protected get initialStatusBar(): StatusBarConfig | null;
        protected onContentViewSet(contentView: android.view.View): void;
        private _setContentView;
        get contentView(): android.view.View;
    }
    export type ActivityClass<T extends Activity> = {
        new (): T;
    };
    export function setMainActivity<T extends Activity>(activityClass: ActivityClass<T>): void;
    export interface ActivityLifecycle extends EventEmitter {
        on(event: "activity_created", listener: (activity: android.app.Activity, savedInstanceState?: android.os.Bundle) => void): this;
        on(event: "activity_started", listener: (activity: android.app.Activity) => void): this;
        on(event: "activity_resumed", listener: (activity: android.app.Activity) => void): this;
        on(event: "activity_paused", listener: (activity: android.app.Activity) => void): this;
        on(event: "activity_stopped", listener: (activity: android.app.Activity) => void): this;
        on(event: "activity_save_instance_state", listener: (activity: android.app.Activity, outState: android.os.Bundle) => void): this;
        on(event: "activity_destroyed", listener: (activity: android.app.Activity) => void): this;
        on(event: "all_activities_destroyed", listener: () => void): this;
    }
    export const activityLifecycle: ActivityLifecycle;
    export function startActivity<T extends Activity>(activityClass: ActivityClass<T>, options?: app.IntentOptions): void;
}
declare module "ui/res" {
    export function loadAndroidResources(): Promise<void>;
    export interface ImageLoader {
        loadImageDrawable(view: android.view.View, uri: String): Promise<android.graphics.drawable.Drawable>;
        loadImageBitmap(view: android.view.View, uri: String): Promise<android.graphics.Bitmap>;
        loadImageInto(imageView: android.widget.ImageView, uri: String): Promise<void>;
        loadImageIntoBackground(view: android.view.View, uri: String): Promise<void>;
        cancel(view: android.view.View): void;
        clearMemoryCache(): void;
        clearDiskCache(): void;
    }
    export const imageLoader: ImageLoader;
}
declare module "ui" {
    export * from "ui/activity";
    export * from "ui/view";
    export * from "ui/layout";
    export * from "ui/web";
    export * from "ui/util";
    export * from "ui/res";
    export interface Point {
        readonly x: number;
        readonly y: number;
    }
    /**
     * @中文
     *
     * 大小填满父布局/窗口
     *
     * @eng
     *
     *  MATCH_PARENT means that the view wants to be as big as its parent, minus the parent's padding, if any.
     */
    export const MATCH_PARENT = -1;
    /**
     * @中文
     *
     * 自适应大小。
     *
     * @eng
     *
     * WRAP_CONTENT means that the view wants to be just large enough to fit its own internal content, taking its own padding into account.
     */
    export const WRAP_CONTENT = -2;
    /**
     * 表示大小的对象，单位一般为像素。另外，当值为{@link WRAP_CONTENT}时，表示自适应大小；当值为{@link MATCH_PARENT}时，表示大小填满父布局/窗口。
     */
    export interface Size {
        readonly width: number;
        readonly height: number;
    }
}
declare module "device" {
    const EventEmitter: any;
    /**
     * @中文
     *
     * Android版本信息。
     *
     * @eng
     *
     * Android version information.
     */
    export interface AndroidVersion {
        /**
         * @中文
         *
         * 版本名称，比如 `4.4.2`, "12"。
         *
         * @eng
         *
         * Version name, such as `4.4.2`, "12".
         */
        readonly name: string;
        /**
         * @中文
         *
         * API版本，比如Android 10为29。
         *
         * @eng
         *
         * API version, such as Android 10 is 29.
         *
         */
        readonly code: number;
    }
    /**
     * @中文
     *
     * OS提供获取系统相关信息，比如系统版本号、版本名称。
     *
     * @eng
     *
     * OS provides system information, such as system version number and version name.
     *
     * @example
     * ```javascript
     * const { OS } = require('device');
     * console.log(OS.sdkName); // e.g. "7.1"
     * console.log(OS.sdkVersionCode); // e.g. 25
     * ```
     */
    export class OS {
        /**
         * Android 1.0
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_BASE: AndroidVersion;
        /**
         * Android 1.1
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_BASE_1_1: AndroidVersion;
        /**
         * Android 1.5
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_CUPCAKE: AndroidVersion;
        /**
         * Android 1.6
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_DONUT: AndroidVersion;
        /**
         * Android 2.0
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_ECLAIR: AndroidVersion;
        /**
         * Android 2.0.1
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_ECLAIR_0_1: AndroidVersion;
        /**
         * Android 2.1.x
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_ECLAIR_MR1: AndroidVersion;
        /**
         * Android 2.2.x
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_FROYO: AndroidVersion;
        /**
         * Android 2.3
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_GINGERBREAD: AndroidVersion;
        /**
         * Android 2.3.3
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_GINGERBREAD_MR1: AndroidVersion;
        /**
         * Android 3.0.x
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_HONEYCOMB: AndroidVersion;
        /**
         * Android 3.1.x
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_HONEYCOMB_MR1: AndroidVersion;
        /**
         * Android 3.2
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_HONEYCOMB_MR2: AndroidVersion;
        /**
         * Android 4.0
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_ICE_CREAM_SANDWICH: AndroidVersion;
        /**
         * Android 4.0.3
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_ICE_CREAM_SANDWICH_MR1: AndroidVersion;
        /**
         * Android 4.1
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_JELLY_BEAN: AndroidVersion;
        /**
         * Android 4.2
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_JELLY_BEAN_MR1: AndroidVersion;
        /**
         * Android 4.3
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_JELLY_BEAN_MR2: AndroidVersion;
        /**
         * Android 4.4.2
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_KITKAT: AndroidVersion;
        /**
         * Android 4.4W
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_KITKAT_WATCH: AndroidVersion;
        /**
         * Android 5.0
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_L: AndroidVersion;
        /**
         * Android 5.1
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_LOLLIPOP_MR1: AndroidVersion;
        /**
         * Android 6.0
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_M: AndroidVersion;
        /**
         * Android 7.0
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_N: AndroidVersion;
        /**
         * Android 7.1
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_N_MR1: AndroidVersion;
        /**
         * Android 8.0
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_O: AndroidVersion;
        /**
         * Android 8.1
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_O_MR1: AndroidVersion;
        /**
         * Android 9
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_P: AndroidVersion;
        /**
         * Android 10
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_Q: AndroidVersion;
        /**
         * Android 11
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_R: AndroidVersion;
        /**
         * Android 12
         *
         * @see {@link requiresAndroidVersion}
         */
        static readonly ANDROID_S: AndroidVersion;
        private static sdkVersions;
        private static _sdkVersionCode;
        private static _sdkName;
        private constructor();
        /**
         * @中文
         *
         * 获取当前系统的SDK版本号，即Android API版本号。例如Android 10为29，Android 7.0为24。完整的对应表参见[SDK Platform release notes](https://developer.android.com/studio/releases/platforms)。
         *
         * @eng
         *
         * Get the current system's SDK version, which is the Android API version. For example, Android 10 is 29, Android 7.0 is 24. The complete corresponding table can be found in [SDK Platform release notes](https://developer.android.com/studio/releases/platforms).
         *
         * @see https://developer.android.com/reference/android/os/Build.VERSION#SDK_INT
         */
        static get sdkVersionCode(): number;
        /**
         * @中文
         *
         * Android版本名称，例如"10"、"7.0"、"4.4W"等。对于比较新的Android版本，可能返回unknown。
         *
         * @eng
         *
         * Android version name, such as "10", "7.0", "4.4W". For a new Android version, it may return "unknown".
         */
        static get sdkName(): string;
        /**
         * @中文
         *
         * 系统源码版本控制的内部版本号，比如git的commit id。
         *
         * @eng
         *
         * The internal value used by the underlying source control to represent this build. E.g., a perforce changelist number or a git hash.
         *
         * @see https://developer.android.com/reference/android/os/Build.VERSION#INCREMENTAL
         */
        static get incremental(): string;
        /**
         * @中文
         *
         * 用户可见的版本字符串。 例如，“1.0”或“3.4b5”或“bananas”。不要假设它的值具有任何特定的结构，或者不同版本的 RELEASE 值可以以某种方式排序。
         *
         * @eng
         *
         * The user-visible version string. E.g., "1.0" or "3.4b5" or "bananas". This field is an opaque string. Do not assume that its value has any particular structure or that values of RELEASE from different releases can be somehow ordered.
         *
         * @see https://developer.android.com/reference/android/os/Build.VERSION#RELEASE
         */
        static get release(): string;
        /**
         * @中文
         *
         * 安全补丁的版本号。
         *
         * @eng
         *
         * The user-visible security patch level. This value represents the date when the device most recently applied a security patch.
         *
         * @see https://developer.android.com/reference/android/os/Build.VERSION#SECURITY_PATCH
         */
        static get securityPatch(): string;
        /**
         * @中文
         *
         * 要求最低在给定的Android版本中运行。如果当前系统版本小于给定版本，则抛出异常，异常信息为给定的message字段。
         *
         * @param version 最小Android版本
         * @param message 异常信息，默认为Requires Android ${version.name}(API ${version.code}) to run this code
         *
         * @eng
         *
         * Require running on the given Android version or higher. If the current system version is lower than the given version, then throw an exception with the given message.
         *
         * @param version The minimum Android version
         * @param message The exception message, default to ”Requires Android ${version.name}(API ${version.code}) to run this code“
         *
         * @example
         * ```javascript
         * "nodejs";
         *
         * const { OS } = require('device');
         * OS.requiresAndroidVersion(OS.ANDROID_N);
         * ```
         */
        static requiresAndroidVersion(version: AndroidVersion, message?: string): void;
    }
    /**
     * 音量类型，包括：
     * * `music`: 音乐(媒体)音量
     * * `alarm`: 闹钟音量
     * * `notification`: 通知音量
     * * `ring`: 铃声音量
     * * `voice_call`: 通话音量
     * * `system`: 系统音量
     * * `dtmf`: DTMF音量
     * * `accessibility`: 辅助功能音量
     */
    export type StreamType = 'music' | 'alarm' | 'notification' | "voice_call" | "system" | "ring" | "dtmf" | "accessibility";
    export interface StreamVolumeRange {
        min: number;
        max: number;
    }
    export type PluggedType = 'usb' | 'wireless' | 'ac';
    /**
     * 设备的显示相关信息。
     *
     * @see https://developer.android.com/reference/android/util/DisplayMetrics
     */
    export interface DisplayMetrics {
        /**
         * @中文
         *
         * 显示宽度，单位像素。
         *
         * @eng
         *
         * Display width, in pixels.
         */
        widthPixels: number;
        /**
         * @中文
         *
         * 显示高度，单位像素。
         *
         * @eng
         *
         * Display height, in pixels.
         */
        heightPixels: number;
        /**
         * @中文
         *
         * 显示器的逻辑密度。这是一个独立像素密度单位的比例系数，在大约160dpi的屏幕上，一个DIP就是一个像素（例如240x320，1.5 "x2 "屏幕），提供系统显示的基线。因此，在160dpi屏幕上，这个密度值将是1；在120dpi屏幕上，它将是0.75；等等。
         *
         * 这个值并不完全遵循真实的屏幕尺寸（由xdpi和ydpi给出），而是用来根据显示dpi的粗略变化，按步骤缩放整个UI的尺寸。例如，一个240x320的屏幕，即使其宽度为1.8"、1.3 "等，其密度也为1。然而，如果屏幕分辨率增加到320x480，但屏幕尺寸仍然是1.5 "x2"，那么密度将增加（可能是1.5）。
         *
         * @eng
         *
         * The logical density of the display. This is a scaling factor for the Density Independent Pixel unit, where one DIP is one pixel on an approximately 160 dpi screen (for example a 240x320, 1.5"x2" screen), providing the baseline of the system's display. Thus on a 160dpi screen this density value will be 1; on a 120 dpi screen it would be .75; etc.
         *
         * This value does not exactly follow the real screen size (as given by xdpi and ydpi), but rather is used to scale the size of the overall UI in steps based on gross changes in the display dpi. For example, a 240x320 screen will have a density of 1 even if its width is 1.8", 1.3", etc. However, if the screen resolution is increased to 320x480 but the screen size remained 1.5"x2" then the density would be increased (probably to 1.5).
         *
         * @see https://developer.android.com/reference/android/util/DisplayMetrics#density
         */
        density: number;
        /**
         * @中文
         *
         * 显示器上显示的字体的比例因子。这与密度相同，只是它可以在运行时根据用户对字体大小的偏好以较小的增量进行调整。
         *
         * @eng
         *
         * A scaling factor for fonts displayed on the display. This is the same as density, except that it may be adjusted in smaller increments at runtime based on a user preference for the font size.
         *
         * @see https://developer.android.com/reference/android/util/DisplayMetrics#scaledDensity
         */
        scaledDensity: number;
        /**
         *
         * @中文
         *
         * 屏幕中每英寸的像素数。
         *
         * @eng
         *
         * The screen density expressed as dots-per-inch.
         *
         * @see https://developer.android.com/reference/android/util/DisplayMetrics#densityDpi
         */
        densityDpi: number;
        /**
         * @中文
         *
         * 屏幕中x方向每英寸的像素数。
         *
         * @eng
         *
         * The screen density expressed as dots-per-inch in the X dimension.
         *
         * @see https://developer.android.com/reference/android/util/DisplayMetrics#xdpi
         *
         */
        xdpi: number;
        /**
         * @中文
         *
         * 屏幕中y方向每英寸的像素数。
         *
         * @eng
         *
         * The screen density expressed as dots-per-inch in the Y dimension.
         *
         * @see https://developer.android.com/reference/android/util/DisplayMetrics#ydpi
         *
         */
        ydpi: number;
    }
    export interface Product {
        /**
         * @中文
         *
         * 设备的产品名称。
         *
         * @eng
         *
         * The name of the overall product.
         *
         * @see https://developer.android.com/reference/android/os/Build.html#PRODUCT
         */
        name: string;
        /**
         * @中文
         *
         * 设备的工业设计名称。
         *
         * @eng
         *
         * The name of the industrial design.
         *
         * @see https://developer.android.com/reference/android/os/Build.html#DEVICE
         */
        device: string;
        /**
         * @中文
         *
         * 设备的主板名称。
         *
         * @eng
         *
         * The name of the underlying board, like "goldfish".
         *
         * @see https://developer.android.com/reference/android/os/Build.html#BOARD
         */
        board: string;
        /**
         * @中文
         *
         * 设备的产品名称。
         *
         * @eng
         *
         * The name of the overall product.
         *
         * @see https://developer.android.com/reference/android/os/Build.html#PRODUCT
         */
        brand: string;
        /**
         * @中文
         *
         * 设备型号。
         *
         * @eng
         *
         * The end-user-visible name for the end product.
         *
         * @see https://developer.android.com/reference/android/os/Build.html#MODEL
         */
        model: string;
    }
    /**
     * @中文
     *
     * 亮度模式，Manual为手动亮度，Automatic为自动亮度。
     *
     * @eng
     *
     * The brightness mode, Manual is for manual brightness, Automatic is for automatic brightness.
     *
     * @see https://developer.android.com/reference/android/provider/Settings.System#SCREEN_BRIGHTNESS_MODE_AUTOMATIC
     */
    export enum BrightnessMode {
        Manual = 0,
        Automatic = 1
    }
    /**
     * @中文
     *
     * 通过{@link Device.memoryInfo}获取的内存信息。
     *
     * @eng
     *
     * Information you can retrieve about the available memory through
     * {@link Device.memoryInfo}.
     */
    export interface MemoryInfo {
        /**
         * @中文
         *
         * 当前的系统可用内存，以字节为单位。
         *
         * @eng
         *
         * The available memory on the system.  This number should not
         * be considered absolute: due to the nature of the kernel, a significant
         * portion of this memory is actually in use and needed for the overall
         * system to run well.
         */
        availMem: number;
        /**
         * @中文
         *
         * 当前的系统总内存，以字节为单位。
         *
         * @eng
         *
         * The total memory accessible by the kernel.  This is basically the
         * RAM size of the device, not including below-kernel fixed allocations
         * like DMA buffers, RAM for the baseband CPU, etc.
         */
        totalMem: number;
        /**
         * @中文
         *
         * 当系统的可用内存达到此内存阈值时，被认为是低内存。
         *
         * @eng
         *
         * The threshold of {@link availMem} at which we consider memory to be
         * low and start killing background services and other non-extraneous
         * processes.
         */
        threshold: number;
        /**
         * 如果为true，则表示系统内存不足。
         *
         * @eng
         *
         * Set to true if the system considers itself to currently be in a low
         * memory situation.
         */
        lowMemory: boolean;
    }
    /**
     * @中文
     *
     * Device类提供获取设备状态、信息、调整设备亮度等方法。它是一个单例，只需要通过`const { device } = require('device')`即可获取实例。
     *
     * @eng
     *
     * Device class provides methods to get device status, information, adjust device brightness, etc. It is a singleton, you can get the instance by `const { device } = require('device')`.
     */
    export class Device extends EventEmitter {
        private context;
        private _receiver;
        private _screenSize?;
        private constructor();
        private get contentResolver();
        /**
         * @中文
         *
         * 设备的产品信息，包括产品名称、设备名称、设备板名、产品品牌、产品型号。
         *
         * @eng
         *
         * Device product information, including product name, device name, device board name, product brand, product model.
         *
         * @example
         * ```javascript
         * "nodejs";
         * const { device } = require('device');
         * console.log(device.product);
         * // {
         * //  name: 'mars',
         * //  device: 'mars',
         * //  board: 'mars',
         * //  brand: 'Xiaomi',
         * //  model: 'M2102K1AC'
         * // }
         * ```
         *
         * @see https://developer.android.com/reference/android/os/Build.html#PRODUCT
         */
        get product(): Product;
        /**
         * @中文
         *
         * 设备的唯一标识符。从Android10开始，应用可能没有权限获取到此值。
         *
         * @eng
         *
         * Gets the hardware serial number, if available.
         *
         * Starting with API level 29, persistent device identifiers are guarded behind additional restrictions, and apps are recommended to use resettable identifiers (see Best practices for unique identifiers). This method can be invoked if one of the following requirements is met:
         * * If the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this is a privileged permission that can only be granted to apps preloaded on the device.
         * * If the calling app has carrier privileges (see TelephonyManager.hasCarrierPrivileges()) on any active subscription.
         * * If the calling app is the default SMS role holder (see RoleManager.isRoleHeld(String)).
         * * If the calling app is the device owner of a fully-managed device, a profile owner of an organization-owned device, or their delegates (see DevicePolicyManager.getEnrollmentSpecificId()).
         *
         * If the calling app does not meet one of these requirements then this method will behave as follows:
         * * If the calling app's target SDK is API level 28 or lower and the app has the READ_PHONE_STATE permission then Build#UNKNOWN is returned.
         * * If the calling app's target SDK is API level 28 or lower and the app does not have the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or higher, then a SecurityException is thrown.
         *
         * @see https://developer.android.com/reference/android/os/Build.html#getSerial()
         */
        get serial(): string;
        /**
         * @中文
         *
         * 设备支持的CPU架构的数组，比如`['arm64-v8a', 'armeabi-v7a']`。
         *
         * @eng
         *
         * An array of supported CPU architectures, such as `['arm64-v8a', 'armeabi-v7a']`.
         */
        get cpuApis(): Array<string>;
        /**
         * @中文
         *
         * 设备的构建ID。
         *
         * @eng
         *
         * Either a changelist number, or a label like "M4-rc20".
         *
         * @see https://developer.android.com/reference/android/os/Build.html#ID
         */
        get buildId(): string;
        /**
         * @中文
         *
         * 显示给用户的构建ID。
         *
         * @eng
         *
         * A build ID string meant for displaying to the user
         *
         * @see https://developer.android.com/reference/android/os/Build.html#DISPLAY
         */
        get display(): string;
        /**
         * @中文
         *
         * 系统Bootloader的版本号。
         *
         * @eng
         *
         * The system bootloader version number.
         *
         * @see https://developer.android.com/reference/android/os/Build.html#BOOTLOADER
         */
        get bootloader(): string;
        /**
         * @中文
         *
         * 硬件名称。
         *
         * @eng
         *
         * The name of the hardware (from the kernel command line or /proc).
         *
         * @see https://developer.android.com/reference/android/os/Build.html#HARDWARE
         */
        get hardware(): string;
        /**
         * @中文
         *
         * 构建的唯一标识字符串。
         *
         * @eng
         *
         * A string that uniquely identifies this build. Do not attempt to parse this value.
         *
         * @see https://developer.android.com/reference/android/os/Build.html#FINGERPRINT
         */
        get fingerprint(): string;
        /**
         * @中文
         *
         * 设备的IMEI。若无权限获取，可能抛出异常；从Android 10开始，应用不再有权限获取IMEI。
         *
         * @eng
         *
         * Returns the unique device ID, for example, the IMEI for GSM and the MEID or ESN for CDMA phones. Return null if device ID is not available.
         *
         * Starting with API level 29, applications are not allowed to access IMEI.
         *
         * @see https://developer.android.com/reference/android/telephony/TelephonyManager#getDeviceId()
         */
        get imei(): string | null;
        /**
         * @中文
         *
         * Android ID。
         *
         * @eng
         *
         * Android ID.
         *
         * @see https://developer.android.com/reference/android/provider/Settings.Secure#ANDROID_ID
         */
        get androidId(): string;
        /**
         * @中文
         *
         * 根据类型获取音量，比如获取媒体音量为`device.getVolume("music")`。
         *
         * @param type 音量类型，参见{@link StreamType}
         *
         * @eng
         *
         * Gets the volume for a particular stream type. For example, using `device.getVolume("music")` to get the current music volume.
         *
         * @param type The stream type whose volume should be returned. One of {@link StreamType}
         *
         */
        getVolume(type: StreamType): number;
        /**
         * @中文
         *
         * 设置音量，比如设置媒体音量为`device.setVolume("music", 10)`。
         *
         * @param type 音量类型，参见{@link StreamType}
         * @param volume 要设置的音量
         * @param flags 标志位，默认为空数组。比如`['SHOW_UI', 'PLAY_SOUND', 'VIBRATE']`表示调整音量时会弹出提示框，播放提示音，并震动。Flags可选的值参见[AudioManager](https://developer.android.com/reference/kotlin/android/media/AudioManager#FLAG_PLAY_SOUND)。
         *
         * @eng
         *
         * Sets the volume for a particular stream type. For example, `device.setVolume("music", 10)` to set the music volume to 10.
         *
         * @param type The stream type whose volume should be set. One of {@link StreamType}
         * @param volume The volume to set. This value must be in the range `0` to `maxVolume` inclusive.
         * @param flags Optional flags. For example, `['SHOW_UI', 'PLAY_SOUND', 'VIBRATE']` indicates that showing ui, playing sound and vibrating when adjusts volume. Flags can be any of the values in documentation of [AudioManager](https://developer.android.com/reference/kotlin/android/media/AudioManager#FLAG_PLAY_SOUND).
         */
        setVolume(type: StreamType, volume: number, flags?: Array<string>): void;
        /**
         * @中文
         *
         * 获取给定音量类型的音量范围，比如`{min: 0, max: 15}`。
         *
         * @param type 音量类型，参见{@link StreamType}
         *
         * @eng
         *
         * Gets the volume range for a particular stream type. e.g. `{min: 0, max: 15}`.
         *
         * @param type The stream type whose volume range should be returned. One of {@link StreamType}
         */
        getVolumeRange(type: StreamType): StreamVolumeRange;
        /**
         * @中文
         *
         * 设备的当前电量，为0~100之间的浮点数。
         *
         * @eng
         *
         * The current battery level of the device, as a float between 0.0 and 1.0.
         *
         * @example
         *
         * ```javascript
         * "nodejs";
         * const { device } = require('device');
         * console.log(device.battery);
         * ```
         */
        get battery(): number;
        /**
         * @中文
         *
         * 设备的屏幕宽度，单位为像素。
         *
         * @eng
         *
         * The width of the screen in pixels.
         */
        get screenWidth(): number;
        private getScreenSize;
        /**
         * @中文
         *
         * 设备的屏幕高度，单位为像素。
         *
         * @eng
         *
         * The height of the screen in pixels.
         */
        get screenHeight(): number;
        /**
         * @中文
         *
         * 设置的显示相关信息，比如宽度、高度、像素密度等。
         *
         * @eng
         *
         * The display related information, such as width, height, pixel density, etc.
         *
         * @see {@link DisplayMetrics}
         */
        get displayMetrics(): DisplayMetrics;
        private _getDisplayMetrics;
        private _getBatteryFromIntent;
        /**
         * @中文
         *
         * 设备当前连接的电源类型，例如`["usb"]`表示连接了USB电源，`["ac"]`表示连接了交流电源，`["wireless", "usb"]`表示同时连接了无线和USB电源。如果设备没有连接电源，则返回空数组。
         *
         * @eng
         *
         * The array of the types of power source which  the device is plugged in to, for example `["usb"]` means connected to USB power, `["ac"]` means connected to AC power. If the device is not connected to power, it returns an empty array.
         *
         * @example
         *
         * ```javascript
         * "nodejs";
         * const { device } = require('device');
         * console.log(device.batteryPluggedTypes);
         * ```
         */
        get batteryPluggedTypes(): Array<PluggedType>;
        private _getBatteryPluggedFromIntent;
        get macAddress(): string | null;
        private _getMacAddressByNetworkInterfaces;
        private _getMacAddressByConnectionInfo;
        private _onReceive;
        /**
         * @中文
         *
         * 设备的亮度，范围为0-255。
         *
         * ```javascript
         * "nodejs";
         *
         * const { device } = require("device");
         * // 打印当前的亮度
         * console.log(device.brightness);
         * // 设置亮度为255
         * device.brightness = 255;
         * ```
         *
         * @eng
         *
         * The brightness mode of the device.
         *
         * ```javascript
         * "nodejs";
         *
         * const { device } = require("device");
         * console.log(device.brightness);
         * // Set the brightness to 255
         * device.brightness = 255;
         * ```
         *
         * @see https://developer.android.com/reference/android/provider/Settings.System#SCREEN_BRIGHTNESS
         */
        get brightness(): number;
        set brightness(value: number);
        /**
         * @中文
         *
         * 设备的亮度模式。
         *
         * ```javascript
         * "nodejs";
         *
         * const { device, BrightnessMode } = require("device");
         * // 打印当前的亮度模式
         * console.log(device.brightnessMode);
         * // 设置亮度为自动亮度
         * device.brightnessMode = BrightnessMode.AUTOMATIC;
         * ```
         *
         * @eng
         *
         * The brightness mode of the device.
         *
         * ```javascript
         * "nodejs";
         *
         * const { device, BrightnessMode } = require("device");
         * console.log(device.brightnessMode);
         * // Set the brightness to automatic brightness
         * device.brightnessMode = BrightnessMode.AUTOMATIC;
         * ```
         *
         * @see https://developer.android.com/reference/android/provider/Settings.System#SCREEN_BRIGHTNESS_MODE
         */
        get brightnessMode(): BrightnessMode;
        set brightnessMode(value: BrightnessMode);
        private get activityManager();
        /**
         * @中文
         *
         * 获取当前设备的内存信息， 包括总内存、可用内存、是否低内存状态等。
         *
         * 内存单位为字节，即byte。
         *
         * @eng
         *
         * Return general information about the memory state of the system, including total memory, available memory, etc. This can be used to help decide how to manage your own memory.
         *
         * Memory units are bytes.
         *
         * @example
         * ```javascript
         * "nodejs";
         * const { device } = require('device');
         * console.log(`total memory: ${device.memoryInfo.totalMem / 1024 / 1024} MB`);
         * console.log(device.memoryInfo);
         * ```
         *
         * @see https://developer.android.com/reference/android/app/ActivityManager#getMemoryInfo(android.app.ActivityManager.MemoryInfo)
         */
        get memoryInfo(): MemoryInfo;
        /**
         * @中文
         *
         * 让设备震动一段时间，需要应用在前台时才能调用此函数。
         *
         * @param millis 震动时间，单位毫秒
         *
         * @eng
         *
         * Vibrate constantly for the specified period of time. The app should be in the foreground for the vibration to happen.
         *
         * @param millis Vibration time, in milliseconds
         *
         * @see https://developer.android.com/reference/android/os/Vibrator.html#vibrate(long)
         */
        vibrate(millis: number): void;
        /**
         * @中文
         *
         * 取消震动。
         *
         * @eng
         *
         * Turn the vibrator off.
         *
         * @see https://developer.android.com/reference/android/os/Vibrator.html#cancel()
         */
        cancelVibration(): void;
        /**
        * @中文
        *
        * 返回主要的共享/外部存储目录路径，对于现代的Android设备里面，一般指内部存储的目录路径。
        *
        * 注意：不要被这里的“外部”这个词弄糊涂了。最好将此目录视为媒体/共享存储。它是一个文件系统，可以保存相对大量的数据，并且在所有应用程序之间共享（不强制执行权限）。传统上这是一张 SD 卡，但它也可以作为设备中的内置存储实现，与受保护的内部存储不同，并且可以作为文件系统安装在计算机上。
        *
        * 在具有多个用户的设备上（如 UserManager 所述），每个用户都有自己的隔离共享存储。应用程序只能访问它们正在运行的用户的共享存储。
        *
        * 在具有多个共享/外部存储目录的设备中，此目录表示用户将与之交互的主存储。可通过 Context.getExternalFilesDirs(String)、Context.getExternalCacheDirs() 和 Context.getExternalMediaDirs() 访问辅助存储。
        *
        * 应用程序不应该直接使用这个顶级目录，以免污染用户的根命名空间。应用程序私有的任何文件都应放置在 Context.getExternalFilesDir 返回的目录中，如果卸载应用程序，系统将负责删除该目录。其他共享文件应放置在 getExternalStoragePublicDirectory 返回的目录之一中。
        *
        * 写入此路径需要 Manifest.permission.WRITE_EXTERNAL_STORAGE 权限，从 Build.VERSION_CODES.KITKAT 开始，读取权限需要 Manifest.permission.READ_EXTERNAL_STORAGE 权限，如果您拥有写入权限，则会自动授予该权限。
        *
        * 从 Build.VERSION_CODES.KITKAT 开始，如果您的应用程序只需要存储内部数据，请考虑使用不需要读取或写入权限的 Context.getExternalFilesDir(String)、Context.getExternalCacheDir() 或 Context.getExternalMediaDirs()。
        *
        * 此路径可能会在平台版本之间发生变化，因此应用程序应该只保留相对路径。
        *
        * @eng
        *
        * Return the primary shared/external storage directory. This directory may not currently be accessible if it has been mounted by the user on their computer, has been removed from the device, or some other problem has happened. You can determine its current state with getExternalStorageState().
        *
        * Note: don't be confused by the word "external" here. This directory can better be thought as media/shared storage. It is a filesystem that can hold a relatively large amount of data and that is shared across all applications (does not enforce permissions). Traditionally this is an SD card, but it may also be implemented as built-in storage in a device that is distinct from the protected internal storage and can be mounted as a filesystem on a computer.
        *
        * On devices with multiple users (as described by UserManager), each user has their own isolated shared storage. Applications only have access to the shared storage for the user they're running as.
        *
        * In devices with multiple shared/external storage directories, this directory represents the primary storage that the user will interact with. Access to secondary storage is available through Context.getExternalFilesDirs(String), Context.getExternalCacheDirs(), and Context.getExternalMediaDirs().
        *
        * Applications should not directly use this top-level directory, in order to avoid polluting the user's root namespace. Any files that are private to the application should be placed in a directory returned by Context.getExternalFilesDir, which the system will take care of deleting if the application is uninstalled. Other shared files should be placed in one of the directories returned by getExternalStoragePublicDirectory.
        *
        * Writing to this path requires the Manifest.permission.WRITE_EXTERNAL_STORAGE permission, and starting in Build.VERSION_CODES.KITKAT, read access requires the Manifest.permission.READ_EXTERNAL_STORAGE permission, which is automatically granted if you hold the write permission.
        *
        * Starting in Build.VERSION_CODES.KITKAT, if your application only needs to store internal data, consider using Context.getExternalFilesDir(String), Context.getExternalCacheDir(), or Context.getExternalMediaDirs(), which require no permissions to read or write.
        *
        * This path may change between platform versions, so applications should only persist relative paths.
        *
        * @see https://developer.android.com/reference/android/os/Environment#getExternalStorageDirectory()
        */
        get externalStorageDirectory(): string;
    }
    export const device: Device;
}
declare module "ui_selector" {
    import { UiObject } from "ui_object";
    /***
     * @中文
     *
     * 选择器条件的具体值的类型接口
     *
     * @eng
     *
     * Selector condition value type interface
     *
     */
    export type PropertyValue = string | number | boolean;
    /***
     * @中文
     *
     * 选择器条件的值的操作符的类型接口
     *
     * @eng
     *
     * Selector condition value operator type interface
     *
     */
    export interface PropertyOperator {
        ">="?: PropertyValue;
        ">"?: PropertyValue;
        "<"?: PropertyValue;
        "<="?: PropertyValue;
        "="?: PropertyValue;
        "!="?: PropertyValue;
    }
    /**
     * @中文
     *
     * 选择器查找条件的值的类型接口
     *
     * @eng
     *
     * Selector query property type interface
     *
     */
    export type PropertyQuery = PropertyValue | PropertyOperator | RegExp;
    /**
     * @中文
     *
     * 选择器查找条件的接口
     *
     * @eng
     *
     * Selector query condition interface
     *
     */
    export interface SelectorQuery {
        [key: string]: PropertyQuery;
    }
    /**
    * @中文
    *
    * 控件过滤器
    *
    * @param obj 控件
    *
    * @returns 是否通过
    *
    * @eng
    *
    * Filter for UI object
    *
    * @param obj UI object
    *
    * @returns Whether passed
    *
    */
    export type UiObjectFilter = (obj: UiObject) => boolean;
    /**
    * @中文
    *
    * 控件提供器
    *
    * @returns 控件列表，或返回控件列表的Promise
    *
    * @eng
    *
    * UI object provider
    *
    * @returns UI object list, or return UI object list as Promise
    *
    */
    export type UiObjectProvider = () => Array<UiObject> | Promise<Array<UiObject>>;
    /**
     * @中文
     *
     * 遍历顺序。0为正序，1为倒序。
     *
     * @eng
     *
     * Traversal order。0 is ascending, 1 is descending.
     *
     */
    export enum TraversalOrder {
        Normal = 0,
        Reverse = 1
    }
    export class NotFoundError extends Error {
    }
    export interface FindOptions {
        timeout?: number;
        maxRetries?: number;
    }
    /**
     * @中文
     *
     * 控件选择器类。
     *
     * @eng
     *
     * UI selector class.
     *
     */
    export class UiSelector {
        /**
        * @中文
        *
        * 默认Ui控件提供器。
        *
        * @eng
        *
        * Default UI Object provider.
        *
        */
        static defaultUiObjectProvider: UiObjectProvider;
        static defaultRetryInterval: number;
        private _filters;
        private _target;
        private _maxResultCount;
        private _minResultCount;
        private _timeout;
        private _maxRetries;
        private _retryInterval;
        /**
        * @中文
        *
        * 设置选择控件的条件。
        *
        * @param filter 选择条件
        *
        * @returns 自身
        *
        * @eng
        *
        * Set the selection condition.
        *
        * @param filter Selection condition
        *
        * @returns Self
        *
        */
        where(filter: UiObjectFilter | SelectorQuery): this;
        /**
        * @中文
        *
        * 设置选择控件的来源
        *
        * @param target 目标
        *
        * @returns 自身
        *
        * @eng
        *
        * Set the selection source.
        *
        * @param target Target
        *
        * @returns Self
        *
        */
        from(target: UiObject | Array<UiObject> | UiSelector | UiObjectProvider): this;
        /**
        * @中文
        *
        * 设置最多返回的控件数量。
        *
        * @param max 最大数量
        *
        * @returns 自身
        *
        * @eng
        *
        * Set the maximum number of UI objects to return.
        *
        * @param max Maximum number
        *
        * @returns Self
        *
        */
        atMost(max: number): this;
        /**
        * @中文
        *
        * 设置最少返回的控件数量。
        *
        * @param min 最小数量
        *
        * @returns 自身
        *
        * @eng
        *
        * Set the minimum number of UI objects to return.
        *
        * @param min Minimum number
        *
        * @returns Self
        *
        */
        atLeast(min: number): this;
        atLeastOne(): this;
        /**
        * @中文
        *
        * 设置查询超时时间。
        *
        * @param timeout 超时时间
        *
        * @returns 自身
        *
        * @eng
        *
        * Set the query timeout.
        *
        * @param timeout Timeout
        *
        * @returns Self
        *
        */
        timeout(timeout: number): this;
        /**
        * @中文
        *
        * 设置查询重试次数。
        *
        * @param max 重试次数
        *
        * @returns 自身
        *
        * @eng
        *
        * Set the query retry times.
        *
        * @param max Retry times
        *
        * @returns Self
        *
        */
        maxRetries(max: number): this;
        retryInterval(interval: number): this;
        /**
        * @中文
        *
        * 获取全部符合条件的控件。
        *
        * @returns 返回控件列表的Promise
        *
        * @eng
        *
        * Get all UI objects that match the condition.
        *
        * @returns Promise of UI object list
        *
        */
        all(): Promise<Array<UiObject>>;
        /**
        * @中文
        *
        * 获取第一个符合条件的控件。
        *
        * @returns 返回控件的Promise
        *
        * @eng
        *
        * Get the first UI object that match the condition.
        *
        * @returns Promise of UI object
        *
        */
        firstOrNull(): Promise<UiObject | null>;
        first(): Promise<UiObject>;
        findFirst(options?: FindOptions): Promise<UiObject>;
        findFirstOrNull(options?: FindOptions): Promise<UiObject | null>;
        /**
        * @中文
        *
        * 获取最后一个符合条件的控件。
        *
        * @returns 返回控件的Promise
        *
        * @eng
        *
        * Get the last UI object that match the condition.
        *
        * @returns Promise of UI object
        *
        */
        lastOrNull(): Promise<UiObject | null>;
        last(): Promise<UiObject>;
        findLast(options?: FindOptions): Promise<UiObject>;
        findLastOrNull(options?: FindOptions): Promise<UiObject | null>;
        /**
        * @中文
        *
        * 获取第i个符合条件的控件。
        *
        * @param i 第几个控件
        *
        * @returns 返回控件的Promise
        *
        * @eng
        *
        * Get the i-th UI object that match the condition.
        *
        * @param i Index
        *
        * @returns Promise of UI object
        *
        */
        takeAtOrNull(i: number): Promise<UiObject | undefined>;
        takeAt(i: number): Promise<UiObject>;
        findAt(i: number, options?: FindOptions): Promise<UiObject>;
        findAtOrNull(i: number, options?: FindOptions): Promise<UiObject | null>;
        private find;
        private iterator;
        private withFindOptions;
    }
}
declare module "settings" {
    /**
     * @中文
     *
     * 此模块可让您控制一些Auto.js内部设置，比如稳定模式、前台服务等。
     *
     * @eng
     *
     * This module can let you control some internal settings of Auto.js, such as stable mode, foreground service, etc.
     *
     * @example
     *
     * ```javascript
     * "nodejs";
     * const { foregroundService, stableMode } = require('settings');
     *
     * foregroundService.value = true;
     * console.log('foregroundService enabled:', foregroundService.value);
     *
     * stableMode.value = true;
     *
     * @packageDocumentation
     */
    /**
     * @中文
     *
     * 设置项。可以通过`value`属性来读取和修改其值。
     *
     * @eng
     *
     * Setting Item. You can get and set its value by `value` property.
     */
    export interface SettingItem<T> {
        value: T;
    }
    /**
     * @中文
     *
     * 稳定模式。若开启，则通过取消设置AccessibilityServiceInfo的FLAG_INCLUDE_NOT_IMPORTANT_VIEWS，在布局分析时省略布局细节。设置后下次启用无障碍生效。
     *
     * @eng
     *
     * Stable Mode. If enabled, the AccessibilityServiceInfo's FLAG_INCLUDE_NOT_IMPORTANT_VIEWS flag will be removed, and the layout analysis will ignore layout details. The setting will take effect next time you enable accessibility service.
     *
     * @see [FLAG_INCLUDE_NOT_IMPORTANT_VIEWS](https://developer.android.com/reference/android/accessibilityservice/AccessibilityServiceInfo#FLAG_INCLUDE_NOT_IMPORTANT_VIEWS)
     */
    export const stableMode: SettingItem<boolean>;
    /**
     * @中文
     *
     * 使用Root权限启用无障碍服务。若开启，在下次启用无障碍服务时，会尝试使用Root权限启用无障碍服务。
     *
     * @eng
     *
     * Enable Accessibility Service with Root permission. If enabled, Auto.js will try to enable with Root permission the next time you enable it.
     */
    export const enableAccessibilityServiceByRoot: SettingItem<boolean>;
    /**
     * @中文
     *
     * 音量上键停止所有脚本。若开启，在按下音量上键时，会停止所有脚本。只有在打包后的APP中此配置项才会生效。
     *
     * @eng
     *
     * Stop all scripts when pressing volume up. If enabled, all scripts will be stopped when pressing volume up. Only works in released apps.
     */
    export const stopAllOnVolumeUp: SettingItem<boolean>;
    /**
     * @中文
     *
     * 启动时不显示日志界面。若开启，在打包后的APP启动时不显示日志界面。
     *
     * @eng
     *
     * Do not show console view when starting. If enabled, the console view will not be shown when the released app starting.
     */
    export const noConsoleOnLaunch: SettingItem<boolean>;
    /**
     * @中文
     *
     * 前台服务。用于保活、截图权限。
     *
     * @eng
     *
     * Foreground Service. Used for keeping alive and screenshot permission.
     */
    export const foregroundService: SettingItem<boolean>;
}
declare module "accessibility" {
    import { Rect, UiObject } from "ui_object";
    import EventEmitter from 'events';
    import { Image } from "image";
    import { SelectorQuery, UiSelector } from "ui_selector";
    /**
     * @中文
     *
     * 无障碍服务 启用配置
     *
     * @eng
     *
     * Accessibility service enable configuration
     */
    export interface EnableServiceOptions {
        /**
         * @中文
         *
         * 是否启用气泡提示
         *
         * @eng
         *
         * Whether to enable toast notification
         */
        toast?: string | boolean;
        timeout?: number;
    }
    /**
     * @中文
     *
     * 气泡事件
     *
     * @eng
     *
     * Toast event
     */
    export interface ToastEvent {
        /**
         * @中文
         *
         * 气泡提示文本
         *
         * @eng
         *
         * Toast message
         */
        readonly text: string;
        /**
         * @中文
         *
         * 发出该气泡的包名
         *
         * @eng
         *
         * Package name of the toast
         */
        readonly packageName: string;
    }
    export interface AccessibilityWindow extends android.view.accessibility.AccessibilityWindowInfo {
        get root(): UiObject | null;
        get id(): number;
        get active(): boolean;
        get title(): string | null;
        get type(): number;
        get bounds(): Rect;
        get layer(): number;
    }
    /**
     * @中文
     *
     * 无障碍服务
     *
     * @eng
     *
     * Accessibility service
     */
    export interface Accessibility extends EventEmitter {
        /**
         * @中文
         *
         * 获取当前活跃窗口的根节点。若无障碍服务未启动，则会等待服务启动；若无法获取到根节点，则返回 `null`的Promise。
         *
         * @eng
         *
         * Get the root node of the active window. If the accessibility service is not enabled, it will wait for the service to be enabled. If it cannot get the root node, it will return `null` as a Promise.
         *
         */
        root(): Promise<UiObject | null>;
        /**
         * @中文
         *
         * 直接获取当前活跃窗口的根节点。若无障碍服务未启动，或无法获取到根节点，则返回 null。
         *
         * @eng
         *
         * Get the root node of the active window directly. If the accessibility service is not started, or the root node cannot be obtained, it returns null.
         */
        rootOrNull(): UiObject | null;
        get windows(): Array<AccessibilityWindow>;
        /**
         * @中文
         *
         * 启用无障碍服务，若无权限将申请权限并等待用户授予权限
         *
         * @param options 启用配置
         *
         * @eng
         *
         * Enable accessibility service, if no permission will request permission and wait for user to grant permission
         *
         * @param options enable configuration
         */
        enableService(options?: EnableServiceOptions): Promise<android.accessibilityservice.AccessibilityService>;
        /**
         * @中文
         *
         * 安卓无障碍服务实例
         *
         * @eng
         *
         * Android accessibility service instance
         */
        readonly service: android.accessibilityservice.AccessibilityService | null;
        /**
         * @中文
         *
         * 无障碍服务是否启用
         *
         * @eng
         *
         * Whether accessibility service is enabled
         */
        readonly enabled: boolean;
        /**
         * @中文
         *
         * 监听Toast事件，当其他应用发出Toast时，会触发该事件。
         *
         * @param event Toast事件
         * @param listener
         *
         * @eng
         *
         * Listen to Toast events, when other applications send Toast, it will trigger this event.
         *
         * @param event Toast event
         * @param listener
         */
        on(event: 'toast', listener: (event: ToastEvent) => void): this;
        /**
         * @中文
         *
         * 启用按键监听，启用后可以通过`key_event`, `key_down`, `key_up`等事件监听按键。
         *
         * @eng
         *
         * Enable key events, after enabling, you can listen to the `key_event`, `key_down`, `key_up` events.
         */
        enableKeyEvents(): this;
        /**
         * @中文
         *
         * 禁用按键监听。
         *
         * @eng
         *
         * Disable monitoring key events.
         */
        disableKeyEvents(): this;
        /**
         * @中文
         *
         *
         *
         * @param event 按键事件，参考[KeyEvent](https://developer.android.com/reference/android/view/KeyEvent)
         * @param listener
         */
        on(event: 'key_event', listener: (keyCode: number, event: android.view.KeyEvent) => void): this;
        /**
         * @中文
         *
         * 按键按下事件，任意按键按下时触发
         *
         * @param event 固定值为 key_down
         * @param listener 回调函数
         *
         * @eng
         *
         * All key events, triggered when any key is pressed/released/other status occurs
         *
         * @param event fixed value as key_down
         * @param listener callback function
         */
        on(event: 'key_down', listener: (keyCode: number, event: android.view.KeyEvent) => void): this;
        /**
         * @中文
         *
         * 按键弹起事件，任意按键弹起时触发
         *
         * @param event 固定值为 key_up
         * @param listener 回调函数
         *
         * @eng
         *
         * All key events, triggered when any key is pressed/released/other status occurs
         *
         * @param event fixed value as key_up
         * @param listener callback function
         */
        on(event: 'key_up', listener: (keyCode: number, event: android.view.KeyEvent) => void): this;
        /**
         * @中文
         *
         * 清除无障碍控件缓存。
         *
         * @eng
         *
         * Clear the accessibility cache of ui object.
         */
        clearCache(): void;
    }
    /**
     * @中文
     *
     * 无障碍服务实例
     *
     * @eng
     *
     * Accessibility service instance
     */
    export const accessibility: Accessibility;
    /**
     * @中文
     *
     * 一个点。表示屏幕上的一个坐标点。以左上角为原点，右下角为最大值，一般等同于屏幕分辨率。
     *
     * @eng
     *
     * A point. Represents a point on the screen. The origin is the top left corner. The maximum value is the screen resolution.
     */
    export interface Point {
        /**
         * @中文
         *
         * X坐标
         *
         * @eng
         *
         * X coordinate
         */
        readonly x: number;
        /**
         * @中文
         *
         * Y坐标
         *
         * @eng
         *
         * Y coordinate
         */
        readonly y: number;
    }
    /**
     * @中文
     *
     * 点击屏幕上指定位置。坐标以屏幕左上角为原点，向右下增加。最大值一般等同于设备分辨率。
     *
     * @param x X坐标
     * @param y Y坐标
     *
     * @eng
     *
     * Click on the screen at the specified position. The origin is the top left corner. The maximum value is the screen resolution.
     *
     * @param x X coordinate
     * @param y Y coordinate
     */
    export function click(x: number, y: number): Promise<boolean>;
    /**
     * @中文
     *
     * 长按屏幕指定位置。
     *
     * @param x X坐标
     * @param y Y坐标
     *
     * @eng
     *
     * Long press the screen at the specified position.
     *
     * @param x X coordinate
     * @param y Y coordinate
     */
    export function longClick(x: number, y: number): Promise<boolean>;
    /**
     * @中文
     *
     * 按住屏幕指定位置一段时间。
     *
     * @param x X坐标
     * @param y Y坐标
     * @param duration 按住时长，单位毫秒
     * @returns 返回是否运行成功的Promise。运行完成时触发。
     *
     * @eng
     *
     * Press the screen at the specified position for a certain time.
     *
     * @param x X coordinate
     * @param y Y coordinate
     * @param duration Press time, in milliseconds
     * @returns A Promise that resolves to whether the gesture is successful.
     */
    export function press(x: number, y: number, duration: number): Promise<boolean>;
    /**
     * @中文
     *
     * 直线滑动。
     *
     * @param x1 起点X坐标
     * @param y1 起点Y坐标
     * @param x2 终点X坐标
     * @param y2 终点Y坐标
     * @param duration 滑动时长，单位毫秒
     * @returns 返回是否运行成功的Promise。运行完成时触发。
     *
     * @eng
     *
     * Line swipe.
     *
     * @param x1 Start X coordinate
     * @param y1 Start Y coordinate
     * @param x2 End X coordinate
     * @param y2 End Y coordinate
     * @param duration Swipe time, in milliseconds
     * @returns A Promise that resolves to whether the gesture is successful.
     */
    export function swipe(x1: number, y1: number, x2: number, y2: number, duration: number): Promise<boolean>;
    /**
     * @中文
     *
     * 模拟手势。依次滑动多个点的折线路径，可通过大量点来模拟曲线。
     *
     * @param points 路径，由点的数组构成。
     * @param duration 滑动时长，单位毫秒。
     * @param delay 滑动开始延迟，单位毫秒。
     * @returns 返回是否运行成功的Promise。
     *
     * @eng
     *
     * Simulate gesture.
     *
     * @param points Path, represented by an array of points.
     * @param duration Swipe time, in milliseconds.
     * @param delay Swipe start delay, in milliseconds.
     * @returns A Promise that resolves to whether the gesture is successful.
     */
    export function performGesture(points: Point[], duration: number, delay?: number): Promise<boolean>;
    /**
     * @中文
     *
     * 同时模拟多个手势。
     *
     * @param gestures 手势数组。
     *
     * @eng
     *
     * Simulate multiple gestures.
     *
     * @param gestures Gesture array.
     */
    export function performGestures(gestures: StrokeDescription[]): Promise<boolean>;
    type GlobalAction = 'back' | 'home' | 'recents' | 'notifications' | 'quick_settings' | 'power_dialog' | 'toggle_split_screen' | 'lock_screen' | 'take_screenshot' | 'keycode_headsethook' | 'accessibility_button' | 'accessibility_shortcut' | 'accessibility_all_apps';
    /**
     * @中文
     *
     * 模拟全局按键。
     *
     * @param action 全局按键类型。
     * @returns 是否成功。
     *
     * @eng
     *
     * Simulate global key.
     *
     * @param action Global key type.
     * @returns Whether it succeeds.
     */
    export function performGlobalAction(action: number | GlobalAction): boolean;
    /**
     * @中文
     *
     * 模拟返回按键
     *
     * @returns 是否成功。
     *
     * @eng
     *
     * Simulate back key.
     *
     * @returns Whether it succeeds.
     */
    export function back(): boolean;
    /**
     * @中文
     *
     * 模拟Home键
     *
     * @returns 是否成功。
     *
     * @eng
     *
     * Simulate home key.
     *
     * @returns Whether it succeeds.
     */
    export function home(): boolean;
    /**
     * @中文
     *
     * 模拟最近任务键
     *
     * @returns 是否成功。
     *
     * @eng
     *
     * Show recents.
     *
     * @returns Whether it succeeds.
     */
    export function toggleRecents(): boolean;
    /**
     * @中文
     *
     * 拉出通知栏。
     *
     * @returns 是否成功。
     *
     * @eng
     *
     * Pull out notification bar.
     *
     * @returns Whether it succeeds.
     */
    export function openNotifications(): boolean;
    /**
     * @中文
     *
     * 显示快速设置(下拉通知栏到底)。
     *
     * @returns 是否成功。
     *
     * @eng
     *
     * Show quick settings (Pull notification bar to the bottom).
     *
     * @returns Whether it succeeds.
     */
    export function openQuickSettings(): boolean;
    /**
     * @中文
     *
     * 显示电源设置。
     *
     * @returns 是否成功。
     *
     * @eng
     *
     * Show power dialog.
     *
     * @returns Whether it succeeds.
     */
    export function togglePowerDialog(): boolean;
    /**
     * @中文
     *
     * 分屏。
     *
     * @returns 是否成功。需要安卓7.0或以上。
     *
     * @eng
     *
     * Split screen. Requires Android 7.0 or higher.
     *
     * @returns Whether it succeeds.
     */
    export function toggleSplitScreen(): boolean;
    /**
     * @中文
     *
     * 锁屏。
     *
     * @returns 是否成功。需要安卓9或以上。
     *
     * @eng
     *
     * Lock screen. Requires Android 9 or higher.
     *
     * @returns Whether it succeeds.
     */
    export function lockScreen(): boolean;
    /***
     * @中文
     *
     * 模拟回车键。需要安卓12或以上。
     *
     * @returns 是否成功。
     *
     * @eng
     *
     * Simulate enter key. Requires Android 12 or higher.
     *
     * @returns Whether it succeeds.
     */
    export function sendKeyCodeHeadsethook(): boolean;
    /***
     * @中文
     *
     * 触发辅助功能键。需要安卓12或以上。
     *
     * @returns 是否成功。
     *
     * @eng
     *
     * Simulate accessibility button. Requires Android 12 or higher.
     *
     * @returns Whether it succeeds.
     */
    export function triggerAccessibilityButton(): boolean;
    /***
     * @中文
     *
     * 触发辅助功能快捷键。需要安卓12或以上。
     *
     * @returns 是否成功。
     *
     * @eng
     *
     * Simulate accessibility shortcut. Requires Android 12 or higher.
     *
     * @returns Whether it succeeds.
     */
    export function triggerAccessibilityShortcut(): boolean;
    /**
     * @中文
     *
     * 显示已安装的全部应用。需要安卓12或以上。
     *
     * @returns 是否成功。
     *
     * @eng
     *
     * Show all installed apps. Requires Android 12 or higher.
     *
     * @returns Whether it succeeds.
     */
    export function showLauncherAllApps(): boolean;
    /**
     * @中文
     *
     * 截屏。需要安卓11或以上。
     *
     * @param displayId 屏幕ID。
     * @returns 返回截屏图片的Promise。
     *
     * @eng
     *
     * Take a screenshot. Requires Android 11 or higher.
     *
     * @param displayId Screen ID.
     * @returns A Promise that resolves to the screenshot image.
     */
    export function takeScreenshot(displayId?: number): Promise<Image>;
    /**
     * @中文
     *
     * 返回当前获得焦点或活跃的窗口包名，需要注意的是，这包括悬浮窗等情况（也即如果悬浮窗获得焦点，将返回悬浮窗的包名）。没有焦点/活跃窗口或没有无障碍权限时，返回`null`。
     *
     * @param clearCache 是否清除缓存
     *
     * @eng
     *
     * Returns the package name of the currently focused or active window. It should be noted that this includes situations such as floating windows (that is, if the floating window gains focus, the package name of the floating window will be returned). Returns `null` when there is no focused/active window or no accessibility permissions.
     *
     * @param clearCache Whether to clear the cache.
     * @returns Package name. Returns null if no permission.
     */
    export function currentPackage(clearCache?: boolean): string | null;
    /**
     * @中文
     *
     * 返回最近一次监测到的正在运行的应用的Activity名称，一般可以认为就是当前正在运行的应用的Activity名称。
     *
     * @returns Activity名称。无权限则返回null。
     *
     * @eng
     *
     * Returns the activity name of the last detected running app, usually the activity name of the current running app.
     *
     * @returns activity name. Returns null if no permission.
     */
    export function currentActivity(): string | null;
    /***
     * @中文
     *
     * UI选择。
     *
     * @param query 筛选条件
     * @returns Ui选择器
     *
     * @eng
     *
     * UI selector.
     *
     * @param query Filter condition.
     * @returns UI selector.
     */
    export function select(query?: SelectorQuery): UiSelector;
    /**
     * @中文
     *
     * 点击屏幕中的文本。
     *
     * @param text 需点击的文本内容
     * @param index 点击屏幕中的第几个文本，从0开始
     * @returns 是否成功的Promise
     *
     * @eng
     *
     * Click text on the screen.
     *
     * @param text The text to click.
     * @param index The index of the text to click, starting from 0.
     */
    export function clickText(text: string, index?: number): Promise<boolean>;
    /**
     * @中文
     *
     * 输入文本（在原输入框内容后追加输入）。
     *
     * @param text 输入的文本内容
     * @param index 输入至屏幕中第几个输入框，从0开始
     * @returns 是否成功的Promise
     *
     * @eng
     *
     * Input text.
     *
     * @param text The text to input.
     * @param index The index of the input box to input, starting from 0.
     * @returns Whether it succeeds.
     */
    export function inputText(text: string, index?: number): Promise<boolean>;
    /**
     * @中文
     *
     * 设置文本
     *
     * @param text 设置的文本内容
     * @param index 输入至屏幕中第几个输入框，从0开始
     * @returns 是否成功的Promise
     *
     * @eng
     *
     * Set text.
     *
     * @param text The text to set.
     * @param index The index of the input box to set, starting from 0.
     * @returns Whether it succeeds.
     */
    export function setText(text: string, index?: number): Promise<boolean>;
    /**
     * @中文
     *
     * 向下或向右滑动
     *
     * @param index 滑动第几个可滑动布局。从0开始
     * @returns 是否成功的Promise
     *
     * @eng
     *
     * Scroll down or right.
     *
     * @param index The index of the scrollable layout to scroll, starting from 0.
     * @returns Whether it succeeds.
     */
    export function scrollForward(index?: number): Promise<boolean>;
    /**
     * @中文
     *
     * 向上或向左滑动
     *
     * @param index 滑动第几个可滑动布局。从0开始
     * @returns 是否成功的Promise
     *
     * @eng
     *
     * Scroll up or left.
     *
     * @param index The index of the scrollable layout to scroll, starting from 0.
     * @returns Whether it succeeds.
     */
    export function scrollBackward(index?: number): Promise<boolean>;
    export interface NextEventOptions {
        timeout?: number;
    }
    export interface AccessibilityEvent extends android.view.accessibility.AccessibilityEvent {
        get source(): UiObject | null;
        get packageName(): string;
        get className(): string;
        get eventType(): string;
        get eventTime(): number;
        get action(): number;
        get contentChangeTypes(): Array<string>;
        get windowChangeTypes(): Array<string>;
    }
    export function nextEvent(event: string, options?: NextEventOptions): Promise<android.view.accessibility.AccessibilityEvent>;
    export function nextEventOrNull(event: string, options?: NextEventOptions): Promise<android.view.accessibility.AccessibilityEvent | null>;
    /**
     * @中文
     *
     * 手势描述
     *
     * @eng
     *
     * Gesture description
     */
    export class StrokeDescription {
        private points;
        private duration;
        private delay;
        /**
         * @中文
         *
         * 构造手势描述
         *
         * @param points 路径，由点的数组构成。
         * @param duration 滑动时长，单位毫秒。
         * @param delay 滑动开始延迟，单位毫秒。
         *
         * @eng
         *
         * Construct gesture description
         *
         * @param points Path, constructed by point array.
         * @param duration Slide duration, unit millisecond.
         * @param delay Slide start delay, unit millisecond.
         */
        constructor(points: Point[], duration: number, delay?: number);
        /**
         * @中文
         *
         * 转换为安卓手势描述
         *
         * @returns 安卓手势描述
         *
         * @eng
         *
         * Convert to Android gesture description
         *
         * @returns Android gesture description
         */
        toAndroidStrokeDescription(): android.accessibilityservice.GestureDescription.StrokeDescription;
    }
}
declare module "clip_manager" {
    /**
     * @中文
     *
     * 剪贴板模块，用于获取、设置剪贴板内容。**在Android 10以上，由于系统限制，在后台无法访问、监听剪贴板。**
     *
     * @eng
     *
     * Clipboard module, used to get and set clipboard content. In Android 10 or higher, unless the app has focus, the app cannot access clipboard data.
     *
     * @see [Limited access to clipboard data](https://developer.android.com/about/versions/10/privacy/changes#clipboard-data)
     *
     * @packageDocumentation
     */
    import EventEmitter from 'events';
    /**
     * @中文
     *
     * 剪贴板管理器。用于获取、设置、监听剪贴板内容
     *
     * 要使用它，请用`const { clipboardManager } = require('clip_manager')`导入。
     *
     * @eng
     *
     * Clipboard manager. Used to get, set, and listen to clipboard content.
     *
     * Using `const { clipboardManager } = require('clip_manager')` to import it.
     *
     */
    export interface ClipboardManager extends EventEmitter {
        /**
         * @中文
         *
         * 剪贴板变化事件。当前剪贴板内容发生变化时触发。
         *
         * @eng
         *
         * Clipboard change event. Triggered when the current clipboard content changes.
         *
         */
        on(event: 'clip_changed', listener: (() => void)): this;
        /**
         * @中文
         *
         * 设置剪贴板内容。
         *
         * @param text 文本内容
         *
         * @eng
         *
         * Set clipboard content.
         *
         * @param text Text content
         *
         */
        setClip(text: string): void;
        /**
         * @中文
         *
         * 获取剪贴板内容。
         *
         * @returns 文本内容。
         *
         * @eng
         *
         * Get clipboard content.
         *
         * @returns Text content
         */
        getClip(): string | null;
        /**
         * @中文
         *
         * 判断剪贴板是否有内容。
         *
         * @returns 如果有内容，返回true，否则返回false。
         *
         * @eng
         *
         * Determine if clipboard has content.
         *
         * @returns If there is content, return true, otherwise return false.
         *
         */
        hasClip(): boolean;
        /**
         * @中文
         *
         * 清除剪贴板内容。
         *
         * @eng
         *
         * Clear clipboard content.
         *
         */
        clearClip(): void;
    }
    /**
     * @中文
     *
     * 剪贴板管理器。用于获取、设置、监听剪贴板内容。
     *
     * @eng
     *
     * Clipboard manager. Used to get, set, and listen to clipboard content.
     *
     * @see {@link ClipboardManager}
     *
     * @example
     * ```javascript
     * const { clipboardManager, getClip } = require('clip_manager');
     * clipboardManager.on("clip_changed", () => {
     *   console.log("clipboard changed:", getClip());
     * });
     * $autojs.keepRunning();
     * ```
     */
    export const clipboardManager: ClipboardManager;
    /**
     * @中文
     *
     * 设置剪贴板内容。
     *
     * @param text 文本内容
     *
     * @eng
     *
     * Set clipboard content.
     *
     * @param text Text content
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { setClip } = require('clip_manager');
     * setClip('Hello World!');
     * ```
     *
     */
    export function setClip(text: string): void;
    /**
     * @中文
     *
     * 获取剪贴板内容。
     *
     * @returns 文本内容。
     *
     * @eng
     *
     * Get clipboard content.
     *
     * @returns Text content
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { getClip } = require('clip_manager');
     * console.log(getClip());
     * ```
     *
     */
    export function getClip(): string | null;
    /**
     * @中文
     *
     * 判断剪贴板是否有内容。
     *
     * @returns 如果有内容，返回true，否则返回false。
     *
     * @eng
     *
     * Determine if clipboard has content.
     *
     * @returns If there is content, return true, otherwise return false.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { hasClip } = require('clip_manager');
     * console.log(hasClip());
     * ```
     */
    export function hasClip(): boolean;
    /**
     * @中文
     *
     * 清除剪贴板内容。
     *
     * @eng
     *
     * Clear clipboard content.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { clearClip } = require('clip_manager');
     * clearClip();
     * ```
     */
    export function clearClip(): void;
}
declare module "datastore" {
    /**
     * @中文
     *
     * 本地存储对象，用{@link createDatastore}方法创建。
     *
     */
    export interface Datastore {
        /**
         * @中文
         *
         * 从本地存储中异步获取键值为key的数据并返回Promise。
         *
         * 如果该存储中不包含该数据，这时若指定了默认值参数则返回默认值，否则返回undefined。
         *
         *  @param key 键值
         *
         */
        get<T>(key: string): Promise<T | undefined>;
        /**
         * @中文
         *
         * 从本地存储中同步获取键值为key的数据并返回。大多数情况下不需要使用同步方法，使用异步的{@link get}方法即可，尤其是在UI线程中。
         *
         *
         * @param key 键值
         *
         */
        getSync<T>(key: string): T | undefined;
        /**
         * @中文
         *
         * 把键值对key和value保存到本地存储中。此过程是异步的，返回一个`Promise`，当Promise resolve时表示操作完成。
         *
         * 存储的过程实际上是使用`JSON.stringify()`把value转换为字符串再保存，因此value必须是可JSON化的才能被接受。
         *
         * @param key 键值
         * @param value 值
         *
         */
        set<T>(key: string, value: T): Promise<void>;
        /**
         * @中文
         *
         * 把键值对key和value同步保存到本地存储中。大多数情况下不需要使用同步方法，使用异步的{@link set}方法即可，尤其是在UI线程中。
         *
         * 存储的过程实际上是使用`JSON.stringify()`把value转换为字符串再保存，因此value必须是可JSON化的才能被接受。
         *
         * @param key 键值
         * @param value 值
         */
        setSync<T>(key: string, value: T): void;
        /**
         * @中文
         *
         * 异步移除键值为key的数据，并返回被移除的值的Promise。
         *
         * @param key 要移除的值的键
         * @returns 被移除的值的Promise，若本身key没有对应的数据，则会得到`undefined`（的Promise）。
         *
         */
        remove<T>(key: string): Promise<T | undefined>;
        /**
         * @中文
         *
         * 同步移除键值为key的数据，并返回移除的值。大多数情况下不需要使用同步方法，使用异步的{@link remove}方法即可，尤其是在UI线程中。
         *
         * @param key 要移除的值的键
         * @returns 被移除的值，若本身key没有对应的数据，则返回`undefined`。
         *
         */
        removeSync<T>(key: string): T | undefined;
        /**
        * @中文
        *
        * 异步删除当前本地存储以及它的全部数据。此过程是异步的，返回一个`Promise`，当Promise resolve时表示操作完成。
        *
        */
        clear(): Promise<void>;
        /**
         * @中文
         *
         * 同步删除当前本地存储以及它的全部数据。大多数情况下不需要使用同步方法，使用异步的{@link clear}方法即可，尤其是在UI线程中。
         *
         */
        clearSync(): void;
        /**
         * @中文
         *
         * 判断该本地存储是否包含键值为key的数据并返回Promise，若包含是则该Promise的值为`true`，否则为`false`。
         *
         * @param key 键值
         * @returns 是否包含该键值的Promise
         */
        contains(key: string): Promise<boolean>;
        /**
         * @中文
         *
         * 判断该本地存储是否包含键值为key的数据，若包含是则`true`，否则为`false`。
         *
         * @param key 键值
         * @returns 是否包含该键值
         */
        containsSync(key: string): boolean;
        /**
         * @中文
         *
         * 批量编辑数据。
         *
         * @example
         * ```js
         * const { createDatastore } = require('datastore');
         * // 创建本地存储，其名称为example.test
         * const datastore = createDatastore('example.test');
         *
         * async function main() {
         *     // 批量写入多个值，相比依次写入效率更高
         *     await datastore.edit(editor => {
         *         editor.set('boolKey', true)
         *             .set('arrayKey', [1, '2', false])
         *             .remove('versions');
         *     });
         * }
         *
         * main().catch(console.error);
         * ```
         */
        edit(block: (editor: DatastoreEditor) => void): Promise<void>;
        /**
         * @中文
         *
         * 同步批量编辑数据。
         *
         */
        editSync(block: (editor: DatastoreEditor) => void): void;
    }
    /**
     * @中文
     *
     * 本地存储编辑器。
     *
     */
    export interface DatastoreEditor {
        /**
         * @中文
         *
         * 设置键值，将在随后被批量写回文件。
         *
         */
        set<T>(key: string, value: T): this;
        /**
         * @中文
         *
         * 移除键值，将在随后被批量写回文件。
         *
         */
        remove(key: string): this;
        /**
         * @中文
         *
         * 清空本地存储，将在随后被批量写回文件。
         *
         */
        clear(): this;
    }
    /**
     * @中文
     *
     * 创建本地存储的选项。
     *
     * @see {@link createDatastore}
     */
    export interface DatastoreOptions {
        /**
         * @中文
         *
         * 指定对本地存储的数据进行加密的Key，需要是为长度16, 32或64的字符串或二进制数据（分别对应AES128, AES256和AES512）
         *
         */
        encryptionKey?: string | Buffer;
        /**
        * @中文
        *
        * 自定义本地存储的序列化器，默认是使用JSON进行序列化。以下是默认的JSON序列化器的代码，若要自定义序列化器可参数：
        *
        * @example
        * ```js
        * const jsonSerializer = {
        *   valueToString(data) {
        *       if (typeof (data) === 'undefined') {
        *           return '';
        *       }
        *       return JSON.stringify(data);
        *   },
        *   valueFromString: function (data) {
        *       if (data === null || data.length === 0) {
        *           return undefined;
        *       }
        *       return JSON.parse(data);
        *   },
        * }
        * ```
        *
        */
        serializer?: Serializer;
    }
    /**
     * @中文
     *
     * 本地存储序列化器。
     *
     */
    export interface Serializer {
        /**
         * @中文
         *
         * 将要保存的`value`类型数据进行序列化。
         *
         * @param value 此序列化器支持的可序列化类型的任意数据
         */
        valueToString(value: any): string;
        /**
         * @中文
         *
         * 将本地存储中保存的字符串数据反序列化，转化为实际的数据。
         *
         */
        valueFromString(data: string): any;
    }
    /**
     * @中文
     *
     * 创建一个本地存储。不同名称的本地存储的数据是隔开的，而相同名称的本地存储的数据是共享的。
     *
     * 若本地存储已加密，并且创建时未指定或指定了错误的密钥，则创建时也不会发生错误，在获取数据时可能获取到错误的数据或者抛出反序列化异常。
     *
     * @param name 为创建的本地存储数据命名
     * @param options 创建的本地存储的选项
     *
     * @example
     * ```js
     * // 创建加密的本地存储，密钥为长度16, 32或64的字符串
     * const encrptedDatastore = createDatastore('example.encrypted', { encryptionKey: 'bCGwOgwzsCqXQFaW' });
     * async function main() {
     *     // 使用加密的本地存储保存数据
     *     await encrptedDatastore.set('timestamp', Date.now());
     *     // 从加密的本地存储中读取数据
     *     console.log('timestamp:', await encrptedDatastore.get('timestamp'));
     * }
     *
     * main().catch(console.error);
     * ```
     */
    export function createDatastore(name: string, options?: DatastoreOptions): Datastore;
}
declare module "dialogs" {
    /**
     * @中文
     * dialogs模块用于显示弹框，一般用于提示用户关键信息、输入信息，完成简易的交互。
     *
     * 本模块提供了多种配置模式，能够以应用内弹窗或悬浮窗形式显示确认框、输入框、单选框、多选框等，也可以自定义弹出框显示的View。
     *
     * 可使用`const dialogs = require('dialogs');`导入dialogs模块。然后通过比如`dialogs.showInputDialog("输入框标题", "输入框默认文本");`的方式调用模块中的方法。
     *
     * 也可以直接导入要使用的函数，比如`const { showInputDialog } = require('dialogs'); showInputDialog("输入框标题", "输入框默认文本");`。
     *
     * @eng
     * dialogs module is used to show dialogs, which is usually used to show user key information, input information, and complete simple interaction.
     *
     * This module provides multiple configuration modes, which can be displayed in the application dialog or floating window, confirm dialog, input box, radio button, and so on.
     *
     * You can use `const dialogs = require('dialogs');` to import dialogs module. Then you can use `dialogs.showInputDialog("Title", "Text");` to call the module's method.
     *
     * You can also directly import the function you want to use, such as `const { showInputDialog } = require('dialogs'); showInputDialog("Title", "Text");`
     *
     * @packageDocumentation
     */
    import EventEmitter from "events";
    import { Color } from "color";
    import { Image } from "image";
    /**
     * @中文
     *
     * 默认对话框类型，默认为`app`。可通过{@link setDefaultDialogType}函数修改。
     *
     * @eng
     *
     * Default dialog type, the default value is 'app'. Can be modified by the {@link setDefaultDialogType} function.
     *
     * @see {@link DialogProperties}
     * @see {@link buildDialog}
     */
    export let defaultDialogType: DialogType;
    /**
     * @see {@link defaultDialogType}
     */
    export function setDefaultDialogType(type: DialogType): void;
    /**
     * @中文
     * 显示一个确认对话框，包括一个确认按钮和一个取消按钮。
     *
     * @param title 确认对话框的标题。
     * @param properties 对话框的额外配置属性。参考 {@link DialogProperties}
     * @returns 可通过await获取弹出框选择结果。
     *
     * @eng
     * Show a confirm dialog, including a confirm button and a cancel button.
     *
     * @param title The title of the confirm dialog.
     * @param properties The extra configuration properties of the dialog. See {@link DialogProperties}
     * @returns The result of the dialog. You can use await to get the result.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const dialogs = require('dialogs');
     * async function confirm() {
     *   const sure = await dialogs.showConfirmDialog("Are you sure?");
     *   console.log(sure); // true or false
     *   console.log(await dialogs.showConfirmDialog("Are you sure?", { positive: "Yes", negative: "No" }));
     * }
     * confirm();
     * ```
     */
    export function showConfirmDialog(title: string, properties?: DialogProperties): Promise<boolean>;
    /**
     * @中文
     * 显示一个提示对话框。提示对话框包括标题、内容和一个确认按钮。
     *
     * @param title 对话框的标题。
     * @param properties 对话框的配置属性。参考 {@link DialogProperties}
     * @returns 可通过await等待弹出框消失。
     *
     * @eng
     * Show a alert dialog. Alert dialog includes title, content and a confirm button.
     *
     * @param title The title of the dialog.
     * @param properties The configuration properties of the dialog. See {@link DialogProperties}
     * @returns The result of the dialog. You can use await to wait for the dialog to dismiss.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { showAlertDialog } = require('dialogs');
     * async function alert() {
     *   await showAlertDialog("This is an alert dialog.");
     *   await showAlertDialog("Summary", { content: "Some description" });
     * }
     * alert();
     * ```
     */
    export function showAlertDialog(title: string, properties?: DialogProperties): Promise<void>;
    /**
     * @中文
     * 显示一个输入对话框。
     *
     * @param title 输入对话框的标题。
     * @param prefill 输入对话框的默认文本。
     * @param properties 对话框的配置属性。参考 {@link DialogProperties}
     * @returns 可通过await获取弹出输入框的输入结果。若用户取消了输入，则返回null的Promise。
     *
     * @eng
     * show a input dialog.
     *
     * @param title The title of the input dialog.
     * @param prefill The default text of the input dialog.
     * @param properties The configuration properties of the dialog. See {@link DialogProperties}
     * @returns The promise of the input result. If the user cancels the input, the result will be null.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const dialogs = require('dialogs');
     * async function inputDialog() {
     *   const name = await dialogs.showInputDialog("Input your name", "Tony");
     *   if (name != "") {
     *       console.log(`hello, ${mName}`);
     *   }
     * }
     * inputDialog();
     * ```
     */
    export function showInputDialog(title: string, prefill?: string, properties?: DialogProperties): Promise<string | null>;
    /**
     * @中文
     * 显示一个选择对话框。选择对话框包括标题和一个选择列表，用户点击列表项后会返回点击的结果。
     *
     * @param title 选择对话框的标题。
     * @param items 选择框的选项。
     * @param properties 对话框的配置属性。参考 {@link DialogProperties}
     * @returns 选择选项的索引的Promise，若用户取消了选择，则返回-1。索引从0开始。
     *
     * @eng
     * Show a select dialog.
     *
     * @param title The title of the select dialog.
     * @param items The options of the select dialog.
     * @param properties The configuration properties of the dialog. See {@link DialogProperties}
     * @returns The promise of the selected index. If the user cancels the select, the result will be -1.
     *
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { showSelectDialog } = require('dialogs');
     * async function select() {
     *   const i = await showSelectDialog("Select an item", ["item1", "item2", "item3"]);
     *   console.log(`selected item: ${i}`);
     * }
     * select();
     * ```
     *
     */
    export function showSelectDialog(title: string, items: Array<string>, properties?: DialogProperties): Promise<number>;
    /**
     * @中文
     * 显示一个单选对话框。单选对话框包括标题和一个单选列表，用户点击列表项并确定后会返回点击的结果。
     *
     * @param title 单选对话框的标题。
     * @param items 单选框的选项。
     * @param initialSelectedIndex 默认选中的`items`数组索引序。
     * @param properties 对话框的配置属性。参考 {@link DialogProperties}
     * @returns 选择选项的索引的Promise，若用户取消了选择，则返回-1。索引从0开始。
     *
     * @eng
     * Show a radio dialog.
     *
     * @param title The title of the radio dialog.
     * @param items The options of the radio dialog.
     * @param initialSelectedIndex The default selected index of the `items` array.
     * @param properties The configuration properties of the dialog. See {@link DialogProperties}
     * @returns The promise of the selected index. If the user cancels the radio, the result will be -1.
     *
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { showSingleChoiceDialog } = require('dialogs');
     * async function singleChoice() {
     *   const i = await showSingleChoiceDialog("Choose an item", ["item1", "item2", "item3"]);
     *   console.log(`selected item: ${i}`);
     * }
     * singleChoice();
     * ```
     */
    export function showSingleChoiceDialog(title: string, items: Array<string>, initialSelectedIndex?: number, properties?: DialogProperties): Promise<number>;
    /**
     * @中文
     * 显示一个多选对话框。多选对话框包括标题和一个多选列表，用户选择列表项并确定后会返回点击的结果。
     *
     * @param title 多选对话框的标题。
     * @param items 多选框的选项。
     * @param initialSelectedIndices 默认选中的选项，比如`[0, 2]`表示选中第一项和第三项。
     * @param properties 对话框的配置属性。参考 {@link DialogProperties}
     * @returns 选中选项的索引的数组Promise，若用户取消了选择，则返回空数组。索引从0开始。
     *
     * @eng
     * Show a multi-choice dialog. Multi-choice dialog includes a title and a multi-choice list, and the user clicks on the list items to confirm.
     *
     * @param title The title of the multi-choice dialog.
     * @param items The options of the multi-choice dialog.
     * @param initialSelectedIndices The default selected options. The form is an array of the index of `items` array.
     * @param properties The configuration properties of the dialog. See {@link DialogProperties}
     * @returns The promise of the selected indices. If the user cancels the multi-choice, the result will be an empty array.
     *
     * ```javascript
     * "nodejs";
     * const { showMultiChoiceDialog } = require('dialogs');
     * async function multiChoice() {
     *     const indices = await showMultiChoiceDialog("Choose items", ["item1", "item2", "item3"]);
     *     console.log(`selected items: ${indices}`);
     * }
     * ```
     *
     */
    export function showMultiChoiceDialog(title: string, items: Array<string>, initialSelectedIndices?: Array<number>, properties?: DialogProperties): Promise<Array<number> | null>;
    /**
     * @中文
     * 弹出对话框的类型。
     *
     * * `overlay`: 可显示在其他应用上方，需要悬浮窗权限。
     * * `app`: 应用内对话框，仅可在应用内的当前界面（Activity）显示，不需要额外权限。
     *
     * @eng
     * The type of the dialog.
     *
     * * overlay: can be shown on other applications, need floating window permission.
     * * app: application-level dialog, can only be shown in the current activity, no extra permission required.
     *
     */
    export type DialogType = "overlay" | "app";
    /**
     * @中文
     * 对话框的配置属性。
     *
     * @eng
     * The configuration properties of the dialog.
     *
     * @see {@link buildDialog}
     *
     */
    export interface DialogProperties {
        /**
         * @中文
         * 对话框的标题。
         * @eng
         * dialog title
         */
        readonly title?: string;
        /**
         * @中文
         * 对话框的图标，是一个URL或者图片对象
         * @eng
         * dialog icon, a URL or an image object
         */
        readonly icon?: string | Image;
        /**
         * @中文
         * 对话框文字内容
         * @eng
         * dialog content
         */
        readonly content?: string;
        /**
         * @中文
         * 对话框文字内容的颜色
         * @eng
         * dialog content color
         */
        readonly contentColor?: Color;
        /**
         * @中文
         * 对话框文字内容的行高倍数，1.0为一倍行高
         * @eng
         * dialog content line height, 1.0 is the same as the line height of the text
         */
        readonly contentLineSpacing?: number;
        /**
         * @中文
         * 对话框列表的选项
         *
         * @eng
         * dialog list options
         */
        readonly items?: Array<string>;
        /**
         * @中文
         * 对话框列表的选项的文字颜色
         * @eng
         * dialog list options color
         */
        readonly itemsColor?: Color;
        /**
         * @中文
         * 对话框列表的选项选择模式，可以为:`multi`、`single`、`select`，分别代表多选框、单选框、选择列表
         * @eng
         * dialog list options selection mode, can be: `multi`, `single`, `select`, respectively for multi-choice dialog, single-choice dialog, and selection list
         */
        readonly itemsSelectMode?: "multi" | "single" | "select";
        /**
         * @中文
         * 对话框列表中预先选中的项目索引，如果是单选模式为一个索引；多选模式则为数组
         * @eng
         * dialog list options selected index, if single mode, one index; if multi mode, an array
         */
        readonly itemsSelectedIndex?: number | Array<number>;
        /**
         * @中文
         * 对话框确定按钮的文字内容(最右边按钮)
         * @eng
         * dialog confirm button text
         */
        readonly positive?: string;
        /**
         * @中文
         * 对话框确定按钮的文字颜色(最右边按钮)
         * @eng
         * dialog confirm button color(the right button)
         */
        readonly positiveColor?: Color;
        /**
         * @中文
         * 对话框中立按钮的文字内容(最左边按钮)
         * @eng
         * dialog neutral button text(the middle button)
         */
        readonly neutral?: string;
        /**
         * @中文
         * 对话框中立按钮的文字颜色(最左边按钮)
         * @eng
         * dialog neutral button color(the left button)
         */
        readonly neutralColor?: Color;
        /**
         * @中文
         * 对话框取消按钮的文字内容(确定按钮左边的按钮)
         * @eng
         * dialog cancel button text(the left button of the confirm button)
         */
        readonly negative?: string;
        /**
         * @中文
         * 对话框取消按钮的文字颜色(确定按钮左边的按钮)
         * @eng
         * dialog cancel button color(the left button of the confirm button)
         */
        readonly negativeColor?: Color;
        /**
         * @中文
         * 勾选框文字内容
         * @eng
         * checkbox text
         */
        readonly checkBoxPrompt?: string;
        /**
         * @中文
         * 勾选框是否勾选
         * @eng
         * checkbox is checked
         */
        readonly checkBoxChecked?: boolean;
        /**
         * @中文
         * 对话框进度条配置项
         * @eng
         * dialog progress bar configuration
         */
        readonly progress?: {
            /**
             * @中文
             * 进度条的最大值
             * @eng
             * progress bar max value
             */
            max: number;
            /**
             * @中文
             * 进度条的当前数值
             * @eng
             * progress bar current value
             */
            progress?: number;
            /**
             * @中文
             * 是否显示进度条的最小指及最大值指示，默认为true
             * @eng
             * show progress bar min and max value
             */
            showMinMax?: boolean;
            /**
             * @中文
             * 是否显示为横向进度条，默认为false
             * @eng
             * show progress bar as horizontal
             */
            horizontal?: boolean;
        };
        /**
         * @中文
         * 对话框是否可取消，如果为`false`，则对话框只能用代码手动取消。默认为`false·。
         * @eng
         * dialog is cancelable, if `false`, dialog can only be canceled programmatically. Default is `false`.
         */
        readonly cancelable?: boolean;
        /**
         * @中文
         * 对话框是否在点击对话框以外区域时自动取消，默认为`true`
         * @eng
         * dialog is cancelable when click outside, default is `true`
         */
        readonly canceledOnTouchOutside?: boolean;
        /**
         * @中文
         * 对话框的输入框的输入提示
         * @eng
         */
        readonly inputHint?: string;
        /**
         * @中文
         * 对话框输入框的默认输入内容
         * @eng
         * dialog input default value
         */
        readonly inputPrefill?: string;
        /**
         * @中文
         * 对话框的自定义视图，可使用{@link inflateXml}创建。**使用自定义视图后，大部分对话框内的配置项，比如内容、进度条、输入框等将不再有效，需在自定义View中实现**
         * @eng
         * dialog custom view, use {@link inflateXml} to create. **After using custom view, most configuration items will be invalid, e.g. content, progress, input.**
         */
        readonly customView?: android.view.View;
        /**
         * @中文
         * 对话框是否使用滚动视图包裹内容，默认为`true`
         * @eng
         * dialog is scrollable, default is `true`
         */
        readonly wrapInScrollView?: boolean;
        /**
         * @中文
         * 对话框类型，参考{@link DialogType}。默认为{@link defaultDialogType}，若未修改`defaultDialogType`则默认为`app`。
         * @eng
         * dialog type, see {@link DialogType}. The default is {@link defaultDialogType}, and if `defaultDialogType` is not modified, it defaults to `app`.
         */
        readonly type?: DialogType;
    }
    /**
     * @中文
     * 对话框类型，基于Android原生[Dialog类](https://developer.android.com/reference/android/app/Dialog.html)拓展了一些方法和属性，参见{@link DialogExt}。
     *
     * @eng
     * Dialog type, extends from [Dialog](https://developer.android.com/reference/android/app/Dialog.html) to add some methods and properties. See {@link DialogExt}.
     *
     */
    export type Dialog = android.app.Dialog & DialogExt;
    /**
     * @中文
     * 对话框类型，基于Android原生[Dialog类](https://developer.android.com/reference/android/app/Dialog.html)拓展了一些事件，由{@link buildDialog}和{@link showDialog}创建。
     *
     * 对话框的事件列表参见{@link on}。
     *
     * @eng
     * Dialog type, extends from [Dialog](https://developer.android.com/reference/android/app/Dialog.html) to add some events. Created by {@link buildDialog} and {@link showDialog}.
     *
     * Dialog event list see {@link on}.
     *
     */
    export interface DialogExt extends EventEmitter {
        /**
         * @中文
         *
         * 确定按钮点击事件。
         *
         * @eng
         *
         * positive button click event.
         *
         * @event positive
         */
        on(event: 'positive', listener: (dialog: Dialog) => void): this;
        /**
         * @中文
         *
         * 中立按钮点击事件。
         *
         * @eng
         *
         * neutral button click event.
         *
         * @event neutral
         */
        on(event: 'neutral', listener: (dialog: Dialog) => void): this;
        /**
         * @中文
         *
         * 取消按钮点击事件。
         *
         * @eng
         *
         * negative button click event.
         *
         * @event neutral
         */
        on(event: 'negative', listener: (dialog: Dialog) => void): this;
        /**
         * @中文
         *
         * 带单选框的对话框确认或取消时通过此事件回调选择结果。`index`参数为选择的菜单项的索引，若用户取消选择则为`-1`；`text`参数为选择的菜单项的文本，若用户取消选择为`null`。
         *
         * @eng
         *
         * When the dialog box with the single choice box is confirmed or canceled, the selection result is called back by this event. The `index` parameter is the index of the selected menu item, or `-1` if the user deselected it; the `text` parameter is the text of the selected menu item, or `null` if the user deselected it.
         *
         * @event single_choice
         */
        on(event: 'single_choice', listener: (index: number, text: string | null, dialog: Dialog) => void): this;
        /**
         * @中文
         *
         * 带多选框的对话框确认或取消时通过此事件回调选择结果。`indices`参数为选择的菜单项的索引数组，若用户取消选择则为空数组；`texts`参数为选择的菜单项的文本数组，若用户取消选择为空数组。
         *
         * @eng
         *
         * When a dialog box with a multi-select box is confirmed or canceled, the selection result is called back by this event. The `indices` parameter is the index array of the selected menu items, or an empty array if the user deselects; the `texts` parameter is the text array of the selected menu items, or an empty array if the user deselects.
         *
         * @event multi_choice
         */
        on(event: 'multi_choice', listener: (indices: Array<number>, texts: Array<string>, dialog: Dialog) => void): this;
        /**
         * @中文
         *
         * 带选择菜单的对话框确认或取消时通过此事件回调选择结果。`index`参数为选择的菜单项的索引，若用户取消选择则为`-1`；`text`参数为选择的菜单项的文本，若用户取消选择为`null`。
         *
         * @eng
         *
         * When the dialog box with the selection menu is confirmed or canceled, the selection result is called back by this event. The `index` parameter is the index of the selected menu item, or `-1` if the user deselected it; the `text` parameter is the text of the selected menu item, or `null` if the user deselected it.
         *
         * @event item_select
         */
        on(event: 'item_select', listener: (index: number, text: string | null, dialog: Dialog) => void): this;
        /**
         * @中文
         *
         * 带输入框的对话框文本变化时触发该事件。
         *
         * @eng
         *
         * This event is triggered when text in input box changes.
         *
         * @event input
         */
        on(event: 'input_change', listener: (text: string, dialog: Dialog) => void): this;
        /**
         * @中文
         *
         * 带输入框的对话框确认或取消时，会将输入框的内容通过此事件回调。如果用户取消了输入，`text`参数会为`null`。
         *
         * @eng
         *
         * Dialog with input box, will callback `text` parameter when user confirm or cancel. If user cancel, `text` will be `null`.
         *
         * @event input
         */
        on(event: 'input', listener: (text: string, dialog: Dialog) => void): this;
        /**
         * @中文
         *
         * 对话框消失事件。
         *
         * @eng
         *
         * dialog dismiss event.
         *
         * @event dismiss
         */
        on(event: 'dismiss', listener: (dialog: Dialog) => void): this;
        /**
         * @中文
         *
         * 对话框取消事件，比如点击外部区域触发。
         *
         * @eng
         *
         * dialog cancel event, e.g. triggered when click outside of the dialog.
         *
         * @event cancel
         */
        on(event: 'cancel', listener: (dialog: Dialog) => void): this;
    }
    /**
     * @中文
     * 创建一个对话框。可自定义对话框的标题、内容、进度条、输入框、按钮等。
     *
     * @param properties 对话框的配置属性。参考 {@link DialogProperties}
     * @returns Dialog对象的Promise
     *
     * @eng
     * Create a dialog. You can customize dialog's title, content, progress, input, button, etc.
     *
     * @param properties Dialog's configuration properties. See {@link DialogProperties}
     * @returns Dialog object's Promise
     *
     * ```javascript
     * "nodejs";
     * const { buildDialog} = require("dialogs");
     * async function main() {
     *   const dialog = await buildDialog({
     *      title: "",
     *      content: "",
     *   }).on("positive", () => {
     *       console.log("positive");
     *   });
     *   dialog.show();
     * }
     * main();
     * ```
     */
    export function buildDialog(properties: DialogProperties): Promise<Dialog>;
    /**
     * @中文
     * 创建并显示一个对话框。类似于{@link buildDialog}构建对话框，但是构建后直接显示而无需调用`show`。
     *
     * @param properties 对话框的配置属性。参考 {@link DialogProperties}
     * @returns 对话框对象的Promise
     *
     * @eng
     *
     * Create and show a dialog. Similar to {@link buildDialog}, but show directly without calling `show`.
     *
     * @param properties Dialog's configuration properties. See {@link DialogProperties}
     * @returns Dialog object's Promise
     *
     */
    export function showDialog(properties: DialogProperties): Promise<Dialog>;
}
declare module "floating_window" {
    import { Point, Size, ViewEvent } from "ui/index";
    import EventEmitter from 'events';
    /**
     * @中文
     *
     * 创建悬浮窗的选项，用于指定悬浮窗的大小和位置。
     *
     * @eng
     *
     * Options for creating a floating window, used to specify the size and position of the window.
     */
    export interface CreateWindowOptions {
        /**
         * @中文
         *
         * 悬浮窗的初始位置，比如{x: 100, y: 200}。默认为{x: 0, y: 0}。
         *
         * @eng
         *
         * The initial position of the floating window, such as {x: 100, y: 200}. The default is {x: 0, y: 0}.
         */
        initialPosition?: Point;
        /**
         * @中文
         *
         * 悬浮窗的初始大小，比如{width: 100, height: 200}。默认为自适应大小。
         *
         * @eng
         *
         * The initial size of the floating window, such as {width: 100, height: 200}. The default is wrap content.
         */
        initialSize?: Size;
        /**
         * @中文
         *
         * 悬浮窗内容是否可以超出屏幕之外。
         *
         * @eng
         *
         * Whether the content of the floating window can exceed the screen.
         */
        layoutNoLimit?: boolean;
        /**
         * @中文
         *
         * 用于创建悬浮窗的context，若指定为`accessibility.service`，则设置悬浮窗类型为无障碍悬浮窗，可显示在状态栏上方。默认为全局ApplictionContext，即`$autojs.androidContext`。
         *
         * @eng
         *
         * The context used to create the floating window. If it is specified as `accessibility.service`, the floating window type is set to an accessible floating window, which can be displayed above the status bar. Defaults to the global ApplicationContext, which is `$autojs.androidContext`.
         *
         * @see [TYPE_ACCESSIBILITY_OVERLAY](https://developer.android.com/reference/android/view/WindowManager.LayoutParams#TYPE_ACCESSIBILITY_OVERLAY)
         */
        context?: android.content.Context;
    }
    /**
     * @中文
     *
     * 是否自动贴边。如果为true，在拖拽结束时，悬浮窗会自动贴边；如果为bounce，则会跳跃多次后贴边，类似Auto.js Pro自带悬浮窗的弹性效果。
     *
     * @eng
     *
     * Whether to automatically stick to the edge. If true, when dragging ends, the floating window will stick to the edge; if is "bounce", it will bounce multiple times and stick to the edge, like Auto.js Pro's floating window.
     */
    export type KeepToEdgeType = "bounce" | boolean;
    /**
     * @中文
     *
     * 悬浮窗拖拽选项。
     *
     * @eng
     *
     * Dragging options of the floating window.
     */
    export interface DragGestureOptions {
        /**
         * @中文
         *
         * 悬浮窗贴边类型，可以为true, false或"bounce"，参见{@link KeepToEdgeType}。默认为false。
         *
         * @eng
         *
         * The type of sticking to the edge of the floating window, can be true, false or "bounce", see {@link KeepToEdgeType}. The default is false.
         */
        keepToEdge?: KeepToEdgeType;
        /**
         * @中文
         *
         * 当keepToEdge为"bounce"时，悬浮窗弹性跳跃的时长，默认为300，单位毫秒。
         *
         * @eng
         *
         * The duration of the floating window's elastic bounce, the default is 300 milliseconds.
         */
        bounceDuration?: number;
        /**
         * @中文
         *
         * 指定悬浮窗拖拽手势的可拖动View的点击监听。由于启用拖拽手势来拦截拖动锚点View的触摸事件，你无法再对它使用通常方法监听点击，此方法提供了额外的方式来监听其点击。
         *
         * @eng
         *
         * Specifies the click listener of the anthor view for the drag gesture of the floating window. Since drag gestures are enabled to intercept touch events of the drag anchor view, you can no longer use the usual method to listen for clicks on it, this method provides an additional way to listen for its clicks.
         *
         * @example
         * ```javascript
         * "nodejs";
         * const { createWindow } = require('floating_window');
         * async function main() {
         *   const window = createWindow();
         *   window.setViewFromXml(...);
         *   const dragHandle = window.view.findView('dragHandle');
         *   window.enableDrag(dragHandle, {
         *     onClick: () => {
         *       console.log('click');
         *     }
         *   });
         *   window.show();
         * }
         * main().catch(console.error);
         * ```
         */
        onClick?: () => void;
        /**
         * @中文
         *
         * 指定悬浮窗拖拽手势的可拖动View的长按监听。由于启用拖拽手势来拦截拖动锚点View的触摸事件，你无法再对它使用通常方法监听长按，此方法提供了额外的方式来监听其长按。
         *
         * @eng
         *
         * Specifies the long click listener of the anthor view for the drag gesture of the floating window. Since drag gestures are enabled to intercept touch events of the drag anchor view, you can no longer use the usual method to listen for long clicks on it, this method provides an additional way to listen for its long clicks.
         *
         * @example
         * ```javascript
         * "nodejs";
         * const { createWindow } = require('floating_window');
         * async function main() {
         *   const window = createWindow();
         *   window.setViewFromXml(...);
         *   const dragHandle = window.view.findView('dragHandle');
         *   window.enableDrag(dragHandle, {
         *     onLongClick: () => {
         *       console.log('long click');
         *     }
         *   });
         * }
         * main().catch(console.error);
         * ```
         */
        onLongClick?: () => void;
    }
    /**
     * Window flag: everything behind this window will be dimmed.
     *  Use {@link #dimAmount} to control the amount of dim.
     *
     * @see {@link FloatingWindow.addFlags}
     * @see {@link FloatingWindow.removeFlags}
     * @see https://developer.android.com/reference/android/view/WindowManager.LayoutParams#FLAG_DIM_BEHIND
     **/
    export const FLAG_DIM_BEHIND = 2;
    /**
     * 设置该标志将让该窗口无法获得焦点。
     *
     * Window flag: this window won't ever get key input focus, so the
     * user can not send key or other button events to it.  Those will
     * instead go to whatever focusable window is behind it.  This flag
     * will also enable {@link #FLAG_NOT_TOUCH_MODAL} whether or not that
     * is explicitly set.
     *
     * Setting this flag also implies that the window will not need to
     * interact with
     * a soft input method, so it will be Z-ordered and positioned
     * independently of any active input method (typically this means it
     * gets Z-ordered on top of the input method, so it can use the full
     * screen for its content and cover the input method if needed.  You
     * can use {@link #FLAG_ALT_FOCUSABLE_IM} to modify this behavior.
     *
     * @see {@link FloatingWindow.addFlags}
     * @see {@link FloatingWindow.removeFlags}
     * @see https://developer.android.com/reference/android/view/WindowManager.LayoutParams#FLAG_NOT_FOCUSABLE
     **/
    export const FLAG_NOT_FOCUSABLE = 8;
    /**
     * 设置该标志将让该窗口无法获得触摸事件，但在Android 12及以上因系统安全限制无效。
     *
     * Window flag: this window can never receive touch events.
     *
     * The intention of this flag is to leave the touch to be handled by some window below
     * this window (in Z order).
     *
     * Starting from Android {@link Build.VERSION_CODES#S}, for security reasons, touch
     * events that pass through windows containing this flag (ie. are within the bounds of the
     * window) will only be delivered to the touch-consuming window if one (or more) of the
     * items below are true:
     *   * <b>Same UID</b>: This window belongs to the same UID that owns the touch-consuming
     *   window.
     *   * <b>Trusted windows</b>: This window is trusted. Trusted windows include (but are
     *   not limited to) accessibility windows ({@link #TYPE_ACCESSIBILITY_OVERLAY}), the IME
     *   ({@link #TYPE_INPUT_METHOD}) and assistant windows (TYPE_VOICE_INTERACTION). Windows of
     *   type {@link #TYPE_APPLICATION_OVERLAY} are <b>not</b> trusted, see below.
     *   * <b>Invisible windows</b>: This window is {@link View#GONE} or
     *   {@link View#INVISIBLE}.
     *   * <b>Fully transparent windows</b>: This window has {@link LayoutParams#alpha} equal
     *   to 0.
     *   * <b>One SAW window with enough transparency</b>: This window is of type {@link
     *   #TYPE_APPLICATION_OVERLAY}, has {@link LayoutParams#alpha} below or equal to the
     *   <a href="#MaximumOpacity">maximum obscuring opacity</a> (see below) and it's the
     *   <b>only</b> window of type {@link #TYPE_APPLICATION_OVERLAY} from this UID in the touch
     *   path.
     *   * <b>Multiple SAW windows with enough transparency</b>: The multiple overlapping
     *   {@link #TYPE_APPLICATION_OVERLAY} windows in the
     *   touch path from this UID have a <b>combined obscuring opacity</b> below or equal to
     *   the <a href="#MaximumOpacity">maximum obscuring opacity</a>. See section
     *   <a href="#ObscuringOpacity">Combined obscuring opacity</a> below on how to compute this
     *   value.
     * If none of these cases hold, the touch will not be delivered and a message will be
     * logged to logcat.
     *
     * <a name="MaximumOpacity"></a>
     * <h3>Maximum obscuring opacity</h3>
     * This value is <b>0.8</b>. Apps that want to gather this value from the system rather
     * than hard-coding it might want to use {@link
     * android.hardware.input.InputManager#getMaximumObscuringOpacityForTouch()}.
     *
     * <a name="ObscuringOpacity"></a>
     * <h3>Combined obscuring opacity</h3>
     *
     * The <b>combined obscuring opacity</b> of a set of windows is obtained by combining the
     * opacity values of all windows in the set using the associative and commutative operation
     * defined as:
     * <pre>
     * opacity({A,B}) = 1 - (1 - opacity(A))*(1 - opacity(B))
     * </pre>
     * where {@code opacity(X)} is the {@link LayoutParams#alpha} of window X. So, for a set
     * of windows {@code {W1, .., Wn}}, the combined obscuring opacity will be:
     * <pre>
     * opacity({W1, .., Wn}) = 1 - (1 - opacity(W1)) * ... * (1 - opacity(Wn))
     * </pre>
     *
     * @see {@link FloatingWindow.addFlags}
     * @see {@link FloatingWindow.removeFlags}
     * @see https://developer.android.com/reference/android/view/WindowManager.LayoutParams#FLAG_NOT_TOUCHABLE
     **/
    export const FLAG_NOT_TOUCHABLE = 16;
    /**
     * 设置该标志让窗口显示时保持屏幕常亮。
     *
     * Window flag: as long as this window is visible to the user, keep
     *  the device's screen turned on and bright.
     *
     * @see {@link FloatingWindow.addFlags}
     * @see {@link FloatingWindow.removeFlags}
     * @see https://developer.android.com/reference/android/view/WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON
     * */
    export const FLAG_KEEP_SCREEN_ON = 128;
    /**
     * 设置该标志让窗口保持在屏幕内显示。
     *
     * Window flag for attached windows: Place the window within the entire screen, ignoring
     * any constraints from the parent window.
     *
     *  Note: on displays that have a {@link DisplayCutout}, the window may be placed
     *  such that it avoids the {@link DisplayCutout} area if necessary according to the
     *  {@link #layoutInDisplayCutoutMode}.
     */
    export const FLAG_LAYOUT_IN_SCREEN = 256;
    /**
     * 设置该标志让窗口可超出屏幕范围。
     *
     * Window flag: allow window to extend outside of the screen.
     *
     * @see {@link FloatingWindow.addFlags}
     * @see {@link FloatingWindow.removeFlags}
     * @see https://developer.android.com/reference/android/view/WindowManager.LayoutParams#FLAG_LAYOUT_NO_LIMITS
     **/
    export const FLAG_LAYOUT_NO_LIMITS = 512;
    /**
     * Window flag: hide all screen decorations (such as the status bar) while
     * this window is displayed.  This allows the window to use the entire
     * display space for itself -- the status bar will be hidden when
     * an app window with this flag set is on the top layer. A fullscreen window
     * will ignore a value of {@link #SOFT_INPUT_ADJUST_RESIZE} for the window's
     * {@link #softInputMode} field; the window will stay fullscreen
     * and will not resize.
     *
     * This flag can be controlled in your theme through the
     * {@link android.R.attr#windowFullscreen} attribute; this attribute
     * is automatically set for you in the standard fullscreen themes
     * such as {@link android.R.style#Theme_NoTitleBar_Fullscreen},
     * {@link android.R.style#Theme_Black_NoTitleBar_Fullscreen},
     * {@link android.R.style#Theme_Light_NoTitleBar_Fullscreen},
     * {@link android.R.style#Theme_Holo_NoActionBar_Fullscreen},
     * {@link android.R.style#Theme_Holo_Light_NoActionBar_Fullscreen},
     * {@link android.R.style#Theme_DeviceDefault_NoActionBar_Fullscreen}, and
     * {@link android.R.style#Theme_DeviceDefault_Light_NoActionBar_Fullscreen}.
     *
     * @deprecated Use {@link WindowInsetsController#hide(int)} with {@link Type#statusBars()}
     * instead.
     *
     * @see {@link FloatingWindow.addFlags}
     * @see {@link FloatingWindow.removeFlags}
     * @see https://developer.android.com/reference/android/view/WindowManager.LayoutParams#FLAG_FULLSCREEN
     **/
    export const FLAG_FULLSCREEN = 1024;
    /**
     * 设置该标志让窗口内容无法被截图、录屏。
     *
     * Window flag: treat the content of the window as secure, preventing
     * it from appearing in screenshots or from being viewed on non-secure
     * displays.
     *
     * See {@link android.view.Display#FLAG_SECURE} for more details about
     * secure surfaces and secure displays.
     *
     *
     * @see {@link FloatingWindow.addFlags}
     * @see {@link FloatingWindow.removeFlags}
     * @see https://developer.android.com/reference/android/view/WindowManager.LayoutParams#FLAG_SECURE
     **/
    export const FLAG_SECURE = 8192;
    /**
     * 设置该标志后，窗口将可在有窗口外部的触摸事件时收到ACTION_OUTSIDE事件。
     *
     * Window flag: if you have set {@link #FLAG_NOT_TOUCH_MODAL}, you
     * can set this flag to receive a single special MotionEvent with
     * the action
     * {@link MotionEvent#ACTION_OUTSIDE MotionEvent.ACTION_OUTSIDE} for
     * touches that occur outside of your window.  Note that you will not
     * receive the full down/move/up gesture, only the location of the
     * first down as an ACTION_OUTSIDE.
     *
     *
     * @see {@link FloatingWindow.addFlags}
     * @see {@link FloatingWindow.removeFlags}
     * @see https://developer.android.com/reference/android/view/WindowManager.LayoutParams#FLAG_WATCH_OUTSIDE_TOUCH
     **/
    export const FLAG_WATCH_OUTSIDE_TOUCH = 262144;
    /**
     * @中文
     *
     * 悬浮窗对象。用于控制悬浮窗位置、大小、内容等。
     *
     * @eng
     *
     * Floating window object. Used to control the position, size, and content of the floating window.
     */
    export interface FloatingWindow extends EventEmitter {
        /**
         * @中文
         *
         * 解析xml为View，设置为悬浮窗的内容。
         *
         * @eng
         *
         * Parse xml to View, set as the content of the floating window.
         */
        setViewFromXml(xml: string): void;
        /**
         * @中文
         *
         * 设置给定的View为悬浮窗的内容。
         *
         * @eng
         *
         * Set the given View as the content of the floating window.
         */
        setView(view: android.view.View): void;
        /**
        * @中文
        *
        * 当前悬浮窗的内容View，若没有设置，则为`undefined`。
        *
        * @eng
        *
        * The content view of the floating window, or undefined if not set.
        */
        readonly view?: android.view.View;
        /**
         * @中文
         *
         * 解析给定路径的xml文件为View，设置为悬浮窗的内容。读取文件是异步的，因此此函数也是异步的。
         *
         * @param xmlFile xml文件路径
         *
         * @eng
         *
         * Parse the given path of xml file to View, set as the content of the floating window. The reading of the file is asynchronous, so this function is also asynchronous.
         *
         * @param xmlFile xml file path
         */
        setViewFromXmlFile(xmlFile: string): Promise<void>;
        /**
         *
         * @中文
         *
         * 设置悬浮窗的位置，单位为像素。
         *
         * @param x x坐标
         * @param y y坐标
         *
         * @eng
         *
         * Set the position of the floating window.
         *
         * @param x x coordinate
         * @param y y coordinate
         */
        setPosition(x: number, y: number): Promise<void>;
        /**
         * @中文
         *
         * 悬浮窗的当前位置。
         *
         * @eng
         *
         * The current position of the floating window.
         */
        readonly position: Point;
        /**
         *
         * @中文
         *
         * 设置悬浮窗的大小，单位为像素。
         *
         * @param width 宽度，可能为负数，参见{@link Size}。
         * @param height 高度，可能为负数，参见{@link Size}。
         *
         * @eng
         *
         * Set the size of the floating window, unit is pixel.
         *
         * @param width width, can be negative, see {@link Size}
         * @param height height, can be negative, see {@link Size}
         *
         */
        setSize(width: number, height: number): Promise<void>;
        /**
         * @中文
         *
         * 悬浮窗的当前大小。
         *
         * @eng
         */
        readonly size: Size;
        /**
         * @中文
         *
         * 悬浮窗是否正在显示。
         *
         * @eng
         *
         * Whether the floating window is showing.
         */
        readonly isShowing: boolean;
        /**
         * @中文
         *
         * 显示悬浮窗。
         *
         * 需要注意的是，显示悬浮窗需要启动悬浮窗服务，若应用处于后台，可能会无法启动服务；另外，显示悬浮窗需要悬浮窗权限，如果没有权限，悬浮窗可能无法显示，可以使用{@link manageDrawOverlays}和{@link canDrawOverlays}来查询和跳转悬浮窗权限。
         *
         * @eng
         *
         * Show the floating window.
         *
         * Note that showing the floating window needs to start the floating window service, which may not be possible if the application is in the background. Also, showing the floating window needs floating window permission, if it does not have permission, the floating window may not be displayed. You can use {@link manageDrawOverlays} and {@link canDrawOverlays} to query and jump to floating window permission.
         */
        show(): Promise<void>;
        /**
         * @中文
         *
         * 关闭悬浮窗。
         *
         * @eng
         *
         * Close the floating window.
         */
        close(): Promise<void>;
        /**
         * @中文
         *
         * 启用悬浮窗的拖拽手势。
         *
         * @param view 启用拖拽手势的拖动锚点，拖动该View即可拖动整个悬浮窗
         * @param options 拖拽悬浮窗的选项
         * @returns DragGesture对象，可用于后续禁用手势
         *
         * @eng
         *
         * Enable drag gesture of the floating window.
         *
         * @param view the drag anchor view of the drag gesture, drag the View to drag the whole floating window
         * @param options drag options of the floating window
         * @returns DragGesture object, which can be used to disable the gesture
         */
        enableDrag(view: android.view.View, options?: DragGestureOptions): DragGesture;
        /**
         * @中文
         *
         * 给悬浮窗口增加特定标志位，比如{@link FLAG_NOT_TOUCHABLE}让窗口不可触摸，{@link FLAG_NOT_FOCUSABLE}让窗口不可获得焦点。
         *
         * 本模块附带部分常用的标志位，但完整的标志位需要访问Android文档[WindowManager.LayoutParams](https://developer.android.com/reference/android/view/WindowManager.LayoutParams#FLAG_ALLOW_LOCK_WHILE_SCREEN_ON)。
         *
         * @eng
         *
         * Add specific flags to floating windows, such as {@link FLAG_NOT_TOUCHABLE} to make the window untouchable, {@link FLAG_NOT_FOCUSABLE} to make the window unfocusable.
         *
         * This module comes with some commonly used flags, but the complete flags need to visit the Android documentation [WindowManager.LayoutParams](https://developer.android.com/reference/android/view/WindowManager.LayoutParams#FLAG_ALLOW_LOCK_WHILE_SCREEN_ON).
         *
         * @example
         * ```
         * "nodejs";
         * const { createWindow, FLAG_NOT_TOUCHABLE } = require("floating_window");
         * async function main() {
         *   const window = createWindow();
         *   window.setViewFromXml(...);
         *   window.addFlags(FLAG_NOT_TOUCHABLE)
         *   window.show();
         * }
         * main();
         * ```
         */
        addFlags(flags: number): void;
        /**
         * @中文
         *
         * 对悬浮窗口移除特定标志位，比如{@link FLAG_NOT_TOUCHABLE}让窗口恢复可触摸，{@link FLAG_NOT_FOCUSABLE}让窗口可获得焦点。
         *
         * 本模块附带部分常用的标志位，但完整的标志位需要访问Android文档[WindowManager.LayoutParams](https://developer.android.com/reference/android/view/WindowManager.LayoutParams#FLAG_ALLOW_LOCK_WHILE_SCREEN_ON)。
         *
         * @eng
         *
         * Remove certain flags for floating windows, such as {@link FLAG_NOT_TOUCHABLE} to make the window touchable, {@link FLAG_NOT_FOCUSABLE} to make the window focusable.
         *
         * This module comes with some commonly used flags, but the complete flags need to visit the Android documentation [WindowManager.LayoutParams](https://developer.android.com/reference/android/view/WindowManager.LayoutParams#FLAG_ALLOW_LOCK_WHILE_SCREEN_ON).
         *
         * @example
         * ```
         * "nodejs";
         * const { createWindow, FLAG_LAYOUT_NO_LIMITS, FLAG_NOT_FOCUSABLE } = require("floating_window");
         * async function main() {
         *   const window = createWindow();
         *   window.setViewFromXml(...);
         *   window.removeFlags(FLAG_LAYOUT_NO_LIMITS | FLAG_NOT_FOCUSABLE)
         *   window.show();
         * }
         * main();
         * ```
         */
        removeFlags(flags: number): void;
        on(event: 'touch', listener: (event: ViewEvent & android.view.MotionEvent) => void): this;
    }
    /**
     * @中文
     *
     * {@link FloatingWindow.enableDrag}返回的对象，可用于禁用和重新启用拖拽手势。
     *
     * @eng
     *
     * The object returned by {@link FloatingWindow.enableDrag}, which can be used to disable and re-enable drag gesture.
     */
    export interface DragGesture {
        /**
         * @中文
         *
         * 设置拖拽手势是否启用。
         *
         * @eng
         *
         * Set whether the drag gesture is enabled.
         */
        setEnabled(enabled: boolean): void;
    }
    /**
     * @中文
     *
     * 创建一个新悬浮窗，可指定悬浮窗的初始大小、位置等参数。
     *
     * @param options 创建悬浮窗选项，参见{@link CreateWindowOptions}
     *
     * @eng
     *
     * Create a new floating window, with options to specify the initial size, position, etc.
     *
     * @param options create window options, see {@link CreateWindowOptions}
     */
    export function createWindow(options?: CreateWindowOptions): FloatingWindow;
    /**
     * @中文
     *
     * 判断是否有悬浮窗权限。
     *
     * @returns 如果本应用有悬浮窗权限，则返回 `true`，否则返回 `false`
     *
     * @eng
     *
     * Whether the app has floating window permission.
     *
     * @returns `true` if the app has floating window permission, otherwise `false`
     */
    export function canDrawOverlays(): boolean;
    /**
     * @中文
     *
     * 跳转到管理悬浮窗权限的页面。
     *
     * @eng
     *
     * Jump to the page to manage floating window permission.
     */
    export function manageDrawOverlays(): void;
}
declare module "handler_thread" {
    export class HandlerThread {
        private javaObject;
        private _handler;
        constructor(name: string);
        get handler(): JavaObject;
        get looper(): JavaObject | null;
    }
    export const sharedHandlerThread: HandlerThread;
}
declare module "media" {
    /**
     * @中文
     *
     * 多媒体播放器。提供更丰富的音乐播放管理功能。比如播放、暂停、进度监听等。
     *
     * @eng
     *
     * Multimedia player. Provide more rich music playing management function. For example, play, pause, progress listener, etc.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { MediaPlayer } = require("media");
     * const player = new MediaPlayer();
     * player.play("/sdcard/Music/test.mp3");
     * setInterval(() => {
     *     console.log(player.currentPosition);
     * }, 1000);
     * ```
     *
     * @see https://developer.android.com/reference/android/media/MediaPlayer
     */
    export class MediaPlayer {
        private player;
        private prepareDeferred;
        private seekDeferred;
        private completionDeferred?;
        private exitListener;
        constructor();
        /**
         * @中文
         *
         * 播放音乐。在async函数中可使用await关键字等待播放完成。
         *
         * @param uri 音乐文件路径，或网址。
         * @param volume 播放音量，为0~1的浮点数，默认为1。
         * @param looping 是否循环播放，如果looping为true则循环播放，默认为false。
         *
         * @eng
         *
         * Play music. In 'async function' can be used keyword 'await' to wait for the music to be played.
         *
         * @param uri The music file path, or the URL.
         * @param volume The volume of the music, a float number between 0 and 1, default is 1.
         * @param looping Whether to loop the music, if looping is true, the music will be looped, default is false.
         */
        play(uri: string, volume?: number, looping?: boolean): Promise<void>;
        /**
         * @中文
         *
         * 音乐时长。单位毫秒。
         *
         * @eng
         *
         * The duration of the music. Unit is millisecond.
         *
         * @see https://developer.android.com/reference/android/media/MediaPlayer#getDuration()
         */
        get duration(): number;
        /**
         * @中文
         *
         * 当前播放位置。单位毫秒。
         *
         * @eng
         *
         * The current position of the music. Unit is millisecond.
         *
         * @see https://developer.android.com/reference/android/media/MediaPlayer#getCurrentPosition()
         *
         */
        get currentPosition(): number;
        /**
         * @中文
         *
         * 安卓原生播放器的对象。
         *
         * @eng
         *
         * The native player of Android.
         *
         * @see https://developer.android.com/reference/android/media/MediaPlayer
         */
        get androidMediaPlayer(): android.media.MediaPlayer;
        /**
         * @中文
         *
         * 是否正在播放
         *
         * @eng
         *
         * Whether the music is playing
         *
         * @see https://developer.android.com/reference/android/media/MediaPlayer#isPlaying()
         */
        get isPlaying(): boolean;
        /**
         * @中文
         *
         * 重置播放器
         *
         * @eng
         *
         * Reset the player
         *
         * @see https://developer.android.com/reference/android/media/MediaPlayer#reset()
         */
        reset(): void;
        /**
         * @中文
         *
         * 设置音乐播放的数据源，支持本地文件路径、网络音乐地址。
         *
         * @param path 数据源路径，比如/sdcards/test.mp3, http://www.example.com/test.mp3
         *
         * @eng
         *
         * Set the data source, support local file path, or network url address.
         *
         * @param path The data source path, for example, /sdcard/test.mp3, http://www.example.com/test.mp3
         *
         * @see https://developer.android.com/reference/android/media/MediaPlayer#setDataSource(java.lang.String)
         */
        setDataSource(path: string): void;
        /**
         * @中文
         *
         * 设置音量
         *
         * @param leftVolume 左声道音量，为0~1的浮点数。
         * @param rightVolume 右声道音量，为0~1的浮点数，默认等同于左声道。
         *
         * @eng
         *
         * Set the volume
         *
         * @param leftVolume The volume of the left channel, a float number between 0 and 1.
         * @param rightVolume The volume of the right channel, a float number between 0 and 1, default is equal to left channel.
         *
         * @see https://developer.android.com/reference/android/media/MediaPlayer#setVolume(float,%20float)
         */
        setVolume(leftVolume: number, rightVolume?: number): void;
        /**
         * @中文
         *
         * 设置循环播放
         *
         * @param looping 是否循环播放，如果looping为true则循环播放，默认为false。
         *
         * @eng
         *
         * Set the looping
         *
         * @param looping Whether to loop the music, if looping is true, the music will be looped, default is false.
         *
         * @see https://developer.android.com/reference/android/media/MediaPlayer#setLooping(boolean)
         */
        setLooping(looping: boolean): void;
        /**
         * @中文
         *
         * 准备播放器进行播放。手动设置数据源后，需要调用prepare()或prepareSync()后才能开始播放，用于加载或下载音乐文件。
         *
         * 如果直接使用paly()函数播放，则无需调用本函数，因为play()函数会自动调用prepare()。
         *
         * @eng
         *
         * Prepares the player for playback,. After setting the datasource and the display surface, you need to either call prepare() or prepareSync().
         *
         * For files, it is OK to call prepare(), which blocks until MediaPlayer is ready for playback.
         *
         * @example
         * ```javascript
         * "nodejs";
         * const { MediaPlayer } = require("media");
         * async function main() {
         *     const player = new MediaPlayer();
         *     player.setDataSource("https://www.example.com/test.mp3");
         *     await player.prepare();
         *     player.start();
         *     await player.awaitForCompletion();
         * }
         * main();
         * ```
         *
         * @see https://developer.android.com/reference/android/media/MediaPlayer#prepareAsync()
         */
        prepare(): Promise<void>;
        /**
         * @中文
         *
         * 同步准备播放器进行播放。手动设置数据源后，需要调用prepare()或prepareSync()后才能开始播放，用于加载或下载音乐文件。
         *
         * 如果直接使用paly()函数播放，则无需调用本函数，因为play()函数会自动调用prepare()。
         *
         * @eng
         *
         * Prepares the player for playback, synchronously. After setting the datasource and the display surface, you need to either call prepare() or prepareAsync().
         *
         * For files, it is OK to call prepare(), which blocks until MediaPlayer is ready for playback.
         *
         * If you call play() directly, you do not need to call prepareSync(), because play() will automatically call prepare().
         *
         * @example
         * ```javascript
         * "nodejs";
         * const { MediaPlayer } = require("media");
         * const player = new MediaPlayer();
         * player.setDataSource("/sdcard/Music/test.mp3");
         * player.prepareSync();
         * player.start();
         * $autojs.keepRunning();
         * ```
         *
         * @see https://developer.android.com/reference/android/media/MediaPlayer#prepare()
         */
        prepareSync(): void;
        /**
         * @中文
         *
         * 跳转到指定的时间播放。
         *
         * @param msec 指定的时间，单位为毫秒。
         *
         * @eng
         *
         * Seeks to specified time position. Unit is millisecond.
         *
         * @param msec the offset in milliseconds from the start to seek to
         *
         * @see https://developer.android.com/reference/android/media/MediaPlayer#seekTo(int)
         */
        seekTo(msec: number): Promise<void>;
        /**
         * @中文
         *
         * 开始播放
         *
         * @eng
         *
         * Start playing
         *
         * @see https://developer.android.com/reference/android/media/MediaPlayer#start()
         *
         */
        start(): void;
        /**
         * @中文
         *
         * 暂停播放
         *
         * @eng
         *
         * Pause playing
         *
         * @see https://developer.android.com/reference/android/media/MediaPlayer#pause()
         */
        pause(): void;
        /**
         * @中文
         *
         * 停止播放
         *
         * @eng
         *
         * Stop playing
         *
         * @see https://developer.android.com/reference/android/media/MediaPlayer#stop()
         */
        stop(): void;
        /**
         * @中文
         *
         * 设置播放时是否保持屏幕常亮
         *
         * @param keep 是否保持常亮
         *
         * @eng
         *
         * @param keep Whether to keep screen on
         *
         * @see https://developer.android.com/reference/android/media/MediaPlayer#setScreenOnWhilePlaying(boolean)
         */
        setScreenOnWhilePlaying(keep: boolean): void;
        /**
         * @中文
         *
         * 释放与此 MediaPlayer 对象关联的资源。推荐在使用完 MediaPlayer后立即调用此方法。尤其是在应用的UI进入后台时，应调用此方法以释放 MediaPlayer 对象，除非应用程序有特殊的需求保持对象存活。
         *
         * 若未能立即调用该方法释放资源，除了占用不必要的资源（例如内存和编解码器的实例）外，还可能导致移动设备持续消耗电池。
         *
         * @eng
         *
         * Releases resources associated with this MediaPlayer object. It is considered good practice to call this method when you're done using the MediaPlayer. In particular, whenever an Activity of an application is paused (its onPause() method is called), or stopped (its onStop() method is called), this method should be invoked to release the MediaPlayer object, unless the application has a special need to keep the object around.
         *
         * In addition to unnecessary resources (such as memory and instances of codecs) being held, failure to call this method immediately if a MediaPlayer object is no longer needed may also lead to continuous battery consumption for mobile devices, and playback failure for other applications if no multiple instances of the same codec are supported on a device. Even if multiple instances of the same codec are supported, some performance degradation may be expected when unnecessary multiple instances are used at the same time.
         *
         * @see https://developer.android.com/reference/android/media/MediaPlayer#release()
         *
         */
        release(): void;
        /**
         * @中文
         *
         * 等待播放完成
         *
         * @eng
         *
         * Wait for the music to be played
         *
         * @see https://developer.android.com/reference/android/media/MediaPlayer#setOnCompletionListener(android.media.MediaPlayer.OnCompletionListener)
         */
        awaitForCompletion(): Promise<void>;
        private onPrepared;
        private onSeeked;
        private resolveAll;
    }
    /**
     * @中文
     *
     * 扫描文件。用于将音乐文件加入媒体库，也可将图片加入系统相册。
     *
     * @param file 需要扫描的文件路径。
     *
     * @eng
     *
     * Scan file. Used to add music files to the media library, and to add images to the system album.
     *
     * @param file The file path to be scanned.
     *
     * @see https://developer.android.com/reference/android/media/MediaScannerConnection#scanFile(java.lang.String,%20java.lang.String)
     */
    export function scanFile(file: string): void;
    /**
     * @中文
     *
     * 播放音乐。在async函数中可使用await关键字等待播放完成。
     *
     * @param uri 音乐文件路径，或网址。
     * @param volume 播放音量，为0~1的浮点数，默认为1。
     * @param looping 是否循环播放，如果looping为true则循环播放，默认为false。
     *
     * @eng
     *
     * Play music. In 'async function' can be used keyword 'await' to wait for the music to be played.
     *
     * @param uri The music file path, or the URL.
     * @param volume The volume of the music, a float number between 0 and 1, default is 1.
     * @param looping Whether to loop the music, if looping is true, the music will be looped, default is false.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const media = require("media");
     * const url = 'http://music.163.com/song/media/outer/url?id=1309394512.mp3';
     * playByUrl(url);
     * async function playByUrl(uri) {
     *   await media.playMusic(uri, 1.0, false);
     * }
     * ```
     */
    export function playMusic(uri: string, volume?: number, looping?: boolean): Promise<MediaPlayer>;
}
declare module "media_projection" {
    import { EventEmitter } from 'events';
    import { Image } from "image";
    export class ScreenCaptureRequestError extends Error {
        constructor(message: string);
    }
    export class ImageUnavailableError extends Error {
        constructor(message: string);
    }
    /**
     * @中文
     *
     * 截图方向。
     *
     * @eng
     *
     * Screen capture orientation.
     */
    export enum Orientation {
        /**
         * @中文
         *
         * 当前屏幕方向，也即请求截图权限时，设备的屏幕方向。
         *
         * @eng
         *
         * Current screen orientation, which is the screen orientation of the device when requesting screen capture permission.
         */
        CURRENT = 0,
        /**
         * @中文
         *
         * 根据设备方向动态调整截图方向。
         *
         * @eng
         *
         * Adjust screen capture orientation dynamically and automatically according to device orientation.
         */
        AUTO = 1,
        /**
         * @中文
         *
         * 横屏截图。
         *
         * @eng
         *
         * Landscape screen capture.
         */
        LANDSCAPE = 2,
        /**
         * @中文
         *
         * 竖屏截图。
         *
         * @eng
         *
         * Portrait screen capture.
         */
        PORTRAIT = 3
    }
    /**
     * @中文
     *
     * 截图选项。
     *
     * @eng
     *
     * Screen capture options.
     *
     * @see {@link requestScreenCapture}
     */
    export interface ScreenCaptureOptions {
        /**
         * @中文
         *
         * 截图的宽度。默认为屏幕宽度。
         *
         * @eng
         *
         * Screen capture width. Default is screen width.
         */
        width?: number;
        /**
         * @中文
         *
         * 截图的高度。默认为屏幕高度。
         *
         * @eng
         *
         * Screen capture height. Default is screen height.
         */
        height?: number;
        /**
         * @中文
         *
         * 截图的像素密度(dpi)。默认为屏幕像素密度。
         *
         * @eng
         *
         * Screen capture density. Default is screen density.
         *
         */
        density?: number;
        /**
         * @中文
         *
         * 截图的方向。默认为{@link Orientation.AUTO}，即自动调整屏幕方向。
         *
         * @eng
         *
         * Screen capture orientation. Default is {@link Orientation.AUTO}, which means adjust screen orientation automatically.
         */
        orientation?: Orientation;
        /**
         * @see [VIRTUAL_DISPLAY_FLAGS](https://developer.android.com/reference/android/hardware/display/DisplayManager#VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR)
         */
        virtualDisplayFlags?: number;
    }
    export interface ScreenCapturer {
        /**
         * @中文
         *
         * 有新的截图时触发的事件。
         *
         * @eng
         *
         * The event that triggered on new screen capture available.
         */
        on(event: 'image_available', listener: () => void): this;
    }
    export class ScreenCapturer extends EventEmitter {
        private mediaProjection;
        private options?;
        private _image?;
        private _imageData?;
        private _imageOutdated;
        private _orientation;
        private imageAvailable;
        private onExit;
        /**
         * @中文
         *
         * 获取当前最新的截图图片对象。如果当前没有截图，则会抛出{@link ImageUnavailableError}。
         *
         * @eng
         *
         * Get the latest image of screen capturing. If there is no image available, it will throw {@link ImageUnavailableError}.
         */
        latestImage(): Image;
        /**
         * @中文
         *
         * 获取当前最新的截图图片对象。如果当前没有截图，则会返回null。
         *
         * @eng
         *
         * Get the latest image of screen capturing. If there is no image available, returns null.
         */
        latestImageOrNull(): Image | null;
        /**
         * @中文
         *
         * 等待下一张截图并返回。
         *
         * @eng
         *
         * Wait for the next screen capture and return.
         *
         */
        nextImage(): Promise<Image>;
        /**
         * @中文
         *
         * 等待有截图可用。仅在刚申请到截图权限，未有任何截图可用时，会等待有第一张截图到来。在第一张截图到来的任何时刻调用，会立即返回。
         *
         * @eng
         *
         * Wait for the first screenshot to be available. Called anytime the first screenshot arrives, it will return immediately.
         */
        awaitForImageAvailable(): Promise<void>;
        /**
         * @中文
         *
         * 停止截图。
         *
         * @eng
         *
         * Stop screen capturing.
         */
        stop(): void;
        private refreshVirtualDisplay;
        private initVirtualDisplay;
        private getVirtualDisplayConfig;
        private getOrientationAwareMetrics;
    }
    /**
     * @中文
     *
     * 请求截图权限，并返回{@link ScreenCapturer}对象的Promise。如果用户拒绝或遇到错误，则会抛出一个{@link ScreenCaptureRequestError}。
     *
     * 请求截图权限需要启动新的Activity，因此在Android 10及以上，只有应用在前台时才能申请，并且截图期间需要保持前台服务运行，否则会无法收到新截图。
     *
     * @param options 截图选项
     * @param context 用于启动请求截图权限的Activity的Context，一般无需此参数
     * @returns
     *
     * @eng
     *
     * Request for screen capturing, and return a Promise of {@link ScreenCapturer}. If user rejects or encounters an error, it will throw a {@link ScreenCaptureRequestError}.
     *
     * Request for screen capturing needs to start a new Activity, so that on Android 10 and higher, only the app is in the foreground can request. And the app must keep the foreground service running while capturing, otherwise it will not receive new images.
     *
     * @param options Screen capturing options
     * @param context Context for starting the request for screen capturing, usually no need to pass this parameter
     * @returns
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { requestScreenCapture } = require("media_projection");
     *
     * async function main() {
     *   const capturer = await requestScreenCapture();
     *   const img = await capturer.nextImage();
     *   console.log(img);
     * }
     * main();
     * ```
     */
    export function requestScreenCapture(options?: ScreenCaptureOptions, context?: android.content.Context): Promise<ScreenCapturer>;
}
declare module "notification" {
    import EventEmitter from "events";
    type VoidFunction = () => void;
    /**
     * @中文
     *
     * 通知的动作，包括标题和点击通知事件，一般作为用户可点击的通知按钮显示。
     *
     *
     *
     */
    export interface NotificationAction {
        /**
         * @中文
         *
         * 通知动作（按钮）的标题。
         *
         *
         *
         */
        title: string;
        /**
        * @中文
        *
        * 点击动作（按钮）后的回调函数，用户操作后此函数会被执行。
        *
        *
        *
        */
        onClick?: VoidFunction;
    }
    /**
     * @中文
     *
     * 创建通知的选项，包括通知标题、通知内容、通知图标、通知点击后的行为、按钮等。
     *
     *
     *
     * Create notification options, including notification title, content, icon, action, button, etc.
     *
     * @see {@link buildNotification}
     */
    export interface BuildNotificationOptions {
        /**
         * @中文
         *
         * 通知显示时状态栏显示的通知内容。
         *
         *
         *
         */
        ticker?: string;
        /**
         * @中文
         *
         * 通知的内容标题。
         *
         *
         *
         */
        contentTitle?: string;
        /**
         * @中文
         *
         * 通知的内容文本。
         *
         *
         *
         */
        contentText?: string;
        /**
         * @中文
         *
         * 点击通知内容时的回调函数，当用户点击通知内容时此函数会被执行。
         *
         *
         *
         */
        onContentClick?: VoidFunction;
        /**
         * @中文
         *
         * 通知的动作列表，用于配置通知的额外按钮。
         *
         *
         *
         */
        actions?: Array<NotificationAction>;
        /**
         * @中文
         *
         * 当`autoCancel`为`true`时，用户单击通知栏会自动取消，默认为`false`。
         *
         *
         *
         */
        autoCancel?: boolean;
        /**
         * @中文
         *
         * 通知被删除时的回调函数，当用户删除通知时此函数会被执行。
         *
         *
         *
         */
        onDelete?: VoidFunction;
        /**
         * @中文
         *
         * ongoing设置一个正在进行的通知。通常用来表示一个后台任务,比如正在后台播放音乐或者下载文件等。
         *
         *
         *
         */
        ongoing?: boolean;
        /**
         * @中文
         *
         * silent设置状态栏消息是否静默通知，默认为`false`。
         *
         *
         *
         */
        silent?: boolean;
    }
    /**
     * @中文
     *
     * 根据通知选项创建通知，并显示通知。参数`id`是通知的唯一标识，若之前已经有相同id的通知，再次调用`notify`则会更新该通知。`id`也可用于取消通知。
     *
     * @param id 通知的唯一id，为了避免和Auto.js本身的通知冲突，建议从10000开始
     * @param n 通知选项，包括标题、内容等，参见{@link BuildNotificationOptions}
     *
     * @example
     *
     * ```js
     * "nodejs";
     * const notification = require('notification');
     *
     * const notificationId = 10001;
     * notification.notify(notificationId, {
     *     contentTitle: "点击触发一条新通知",
     *     contentText: "这是一条无法被用户清理的通知",
     *     ticker: "收到一条新通知",
     *     onContentClick: () => {
     *         showCounterNotification(0);
     *     },
     *     ongoing: true,
     *     autoCancel: true,
     * });
     * ```
     *
     */
    export function notify(id: number, n: BuildNotificationOptions): void;
    /**
     * @中文
     * 根据通知id取消通知。此函数只能取消本应用发出的通知，也即通过{@link notify}函数显示的通知。要获取和取消其他应用的通知，请通过{@link requestListeningNotifications}。
     *
     * @param id notify通知时传入的id，参见{@link notify}
     *
     */
    export function cancel(id: number): void;
    /**
     * @中文
     * 请求监听通知选项。
     *
     * @see {@link requestListeningNotifications}
     */
    export interface RequestListeningNotificationsOptions {
        /**
         * @中文
         * 请求通知权限时是否弹出气泡消息，若为`true`则弹出默认文案的气泡消息；若为字符串则弹出字符串内容的气泡消息。默认为`false`。
         *
         */
        toast?: boolean | string;
        /**
        * @中文
        *
        * 当没有通知权限时是否自动跳转通知权限界面，默认为`true`。
        *
        */
        goToSettings?: boolean;
    }
    /**
     * @中文
     *
     * 通知监听服务，使用{@link requestListeningNotifications}在用户授权后获得该服务实例。
     *
     * @example
     * ```js
     * "nodejs";
     * const notification = require('notification');
     *
     * async function main() {
     *     const notificationListenerService = await notification.requestListeningNotifications({
     *         toast: true,
     *     });
     *     console.log('listening notifications...');
     *     notificationListenerService.on("notification", n => {
     *         console.log("收到通知");
     *         console.log(`标题: ${n.getTitle()}, 文本: ${n.getText()}, 包名: ${n.getPackageName()}`);
     *     });
     *
     *     $autojs.keepRunning();
     * }
     * main();
     * ```
     *
     *
     */
    export interface NotificationListenerService extends EventEmitter {
        /**
         * @中文
         *
         * 当有新通知时触发该事件。
         *
         * @see {@link NotificationEvent}
         */
        on(event: 'notification', listener: (n: NotificationEvent) => void): this;
        /**
         * @中文
         *
         * 禁用通知监听服务，禁用后将不会再监听通知。
         *
         */
        disable(): void;
    }
    /**
     * @中文
     * 通知事件，继承至Android [Notification](https://developer.android.com/reference/android/app/Notification)，可获取通知标题、内容等信息。
     *
     * @see {@link NotificationListenerService}
     *
     */
    export interface NotificationEvent extends android.app.Notification {
        /**
         * @中文
         *
         * 通知事件的文本。
         */
        getText(): string | null;
        /**
         * @中文
         *
         * 通知事件的标题。
         */
        getTitle(): string | null;
        /**
         * @中文
         *
         * 通知来源的应用包名。
         *
         */
        getPackageName(): string;
        /**
         * @中文
         *
         * 删除通知。
         *
         * @returns 返回是否删除成功。
         *
         */
        delete(): boolean;
        /**
         * @中文
         *
         * 点击通知。
         *
         */
        click(): void;
    }
    /**
     * @中文
     * 请求监听通知，使本应用获取通知监听服务的权限。返回通知监听服务[NotificationListenerService]({@link NotificationListenerService})的Promise对象。
     *
     * @param options 请求监听通知的选项，比如显示给用户的Toast信息
     *
     * @example
     * ```js
     * "nodejs";
     * const notification = require('notification');
     *
     * async function main() {
     *     const notificationListenerService = await notification.requestListeningNotifications({
     *         toast: true,
     *     });
     *     console.log('listening notifications...');
     *     notificationListenerService.on("notification", n => {
     *         console.log("收到通知");
     *         console.log(`标题: ${n.getTitle()}, 文本: ${n.getText()}, 包名: ${n.getPackageName()}`);
     *     });
     *
     *     $autojs.keepRunning();
     * }
     * main();
     * ```
     */
    export function requestListeningNotifications(options?: RequestListeningNotificationsOptions): Promise<NotificationListenerService>;
    /**
     * @中文
     *
     * 跳转通知权限设置页面。
     *
     */
    export function goToNotificationListenerSettings(): void;
}
declare module "ocr" {
    import { Image, Region } from "image";
    import { Rect } from "ui_object";
    /**
     * @中文
     *
     * {@link OCR.detect}返回的数组的元素对象，包含了文字识别的可信度、文本内容、文本范围、文本旋转度以及文本旋转度的可信度等。
     *
     */
    export class OCRResult {
        /**
        * @中文
        *
        * OCR识别结果的原始Java对象。在官方PaddleOCR中没有什么用，在其他官方OCR中可能可以获取附加的额外信息，比如行、字段落、词语分割。
        *
        */
        readonly javaObject: JavaObject;
        /**
         * @中文
         *
         * 该识别文字在图片中的范围。可通过`left`, `top`, `right`, `bottom`等属性获取它的位置，通过`centerX`, `centerY`获得它的中心点，比如`result.bound.centerX`。
         *
         */
        readonly bounds: Rect;
        /**
         * @中文
         *
         * OCR识别的文字内容。
         *
         */
        readonly text: string;
        /**
         * @中文
         *
         * OCR识别文字的可信度，范围为[0, 1]，越接近1表示结果越准确、可信。
         *
         */
        readonly confidence: number;
        /**
         * @中文
         *
         * 该识别文字在图片中的旋转角度，范围为[0, 360)，一般取值为0和180度。该字段仅在OCRDetectionOptions的detectRotation为`true`时有效。
         *
         */
        readonly rotation: number;
        /**
         * @中文
         *
         * 该识别文字的旋转角度可信度，范围为[0, 1]。该字段仅在OCRDetectionOptions的detectRotation为`true`时有效。
         *
         */
        readonly rotationConfidence: number;
        constructor(javaObject: JavaObject, bounds: Rect, text: string, confidence: number, rotation: number, rotationConfidence: number);
        /**
         * @中文
         *
         *在屏幕上点击OCR结果在图片中范围的中点位置，返回是否点击成功。实际上相当于click(result.bounds.centerX, result.bounds.centerY)。
         *
         */
        click(): Promise<boolean>;
    }
    /**
     * @中文
     *
     * OCR对象。由{@link createOCR}创建，用于具体的文字识别。该对象不再需要时，需要调用release()函数释放资源。
     *
     */
    export interface OCR {
        /**
         * @中文
         *
         * 对给定图片根据给定选项进行文字识别，将文字识别的结果作为数组异步返回。
         *
         * @param image 图片，要识别文字的图片。
         * @param options OCR识别选项
         * @returns 文字识别结果的数组的Promise，包括可信度、文本内容、文本范围等
         *
         */
        detect(image: Image, options?: OCRDetectionOptions): Promise<OCRResult[]>;
        /**
         * @中文
         *
         * 释放OCR资源，默认会在程序退出时自动释放，但请在不使用OCR时及时释放以释放资源。
         *
         */
        release(): void;
    }
    /**
     * @中文
     *
     * CPU模式。
     *
     * *`LITE_POWER_HIGH` 绑定大核运行模式。如果 ARM CPU 支持 big.LITTLE，则优先使用并绑定 Big cluster，如果设置的线程数大于大核数量，则会将线程数自动缩放到大核数量。如果系统不存在大核或者在一些手机的低电量情况下会出现绑核失败，如果失败则进入不绑核模式。
     *
     * *`LITE_POWER_LOW` 绑定小核运行模式。如果 ARM CPU 支持 big.LITTLE，则优先使用并绑定 Little cluster，如果设置的线程数大于小核数量，则会将线程数自动缩放到小核数量。如果找不到小核，则自动进入不绑核模式。
     *
     * *`LITE_POWER_FULL` 大小核混用模式。线程数可以大于大核数量，当线程数大于核心数量时，则会自动将线程数缩放到核心数量。
     *
     * *`LITE_POWER_NO_BIND` 不绑核运行模式（推荐）。系统根据负载自动调度任务到空闲的 CPU 核心上。
     *
     * *`LITE_POWER_RAND_HIGH` 轮流绑定大核模式。如果 Big cluster 有多个核心，则每预测10次后切换绑定到下一个核心。
     *
     * *`LITE_POWER_RAND_LOW` 轮流绑定小核模式。如果 Little cluster 有多个核心，则每预测10次后切换绑定到下一个核心。
     *
     * @see {@link createOCR}
     */
    export type CPUPowerMode = 'LITE_POWER_HIGH' | 'LITE_POWER_LOW' | 'LITE_POWER_FULL' | 'LITE_POWER_NO_BIND' | 'LITE_POWER_RAND_HIGH' | 'LITE_POWER_RAND_LOW';
    /**
     * @中文
     *
     * 创建OCR的选项。
     *
     * @see {@link createOCR}
     */
    export interface CreateOCROptions {
        /**
         * @中文
         *
         * 并行线程数，默认为4。
         *
         */
        parallelThreads?: number;
        /**
         * @中文
         *
         * CPU模式，默认为`LITE_POWER_HIGH`。
         *
         */
        cpuPowerMode?: CPUPowerMode;
        /**
         * @中文
         *
         * 是否使用OpenCL，默认为false
         *
         */
        useOpenCL?: boolean;
        /**
         * @中文
         *
         * OCR模型，可以是内置模型，也可以是自定义模型。`slim`指定精度相对低但速度更快的模型，若不指定则为`default`模型，精度高一点但速度慢一点。也可直接指定自定义模型的绝对路径。
         *
         */
        models?: 'default' | 'slim' | string;
        /**
         * @中文
         *
         * 模型的标签文件，默认为`null`，需要配合models字段使用。
         *
         */
        labelsFile?: string;
    }
    /**
     * @中文
     *
     * 根据给定选项，创建OCR对象，可用于文字识别。一般而已不必自定义参数，使用`createOCR`即可创建有效的OCR对象。
     *
     * @param options 创建OCR对象的选项
     *
     * @example
     * ```js
     * "nodejs";
     * const { createOCR } = require('ocr');
     * const { requestScreenCapture } = require('media_projection');
     * const { showToast } = require('toast');
     * const { delay } = require('lang');
     *
     * async function main() {
     *     // 创建OCR对象，需要先在Auto.js Pro的插件商店中下载官方OCR插件。
     *     const ocr = await createOCR({
     *         models: 'default', // 指定精度相对高但速度较慢的模型
     *     });
     *     const capturer = await requestScreenCapture();
     *     for (let i = 0; i < 5; i++) {
     *         const capture = await capturer.nextImage();
     *
     *         // 检测截图文字并计算检测时间，首次检测的耗时比较长
     *         // 检测时间取决于图片大小、内容、文字数量
     *         // 可通过调整createOCR的线程、CPU模式等参数调整检测效率
     *         const start = Date.now();
     *         const result = await ocr.detect(capture);
     *         const end = Date.now();
     *         console.log(result);
     *
     *         showToast(`第${i + 1}次检测: ${end - start}ms`);
     *         await delay(3000);
     *     }
     *     ocr.release();
     * }
     *
     * main().catch(console.error);
     * ```
     */
    export function createOCR(options?: CreateOCROptions): Promise<OCR>;
    /**
     * @中文
     *
     * OCR检测选项。
     *
     */
    export interface OCRDetectionOptions {
        /**
         * @中文
         *
         * OCR识别文本的数量上限，默认为1000。
         *
         */
        max?: number;
        /**
         * @中文
         *
         * 是否检测文字旋转，默认为`false`。
         *
         */
        detectRotation?: boolean;
        /**
         * @中文
         *
         * OCR识别区域，若不指定则为全图片识别。
         */
        region?: Region;
    }
}
declare module "plugins" {
    /**
     * @中文
     *
     * 加载一个插件，并返回插件模块中module.exports导出的对象。
     *
     * 如果插件未安装或不存在，则抛出PluginLoadException异常。
     *
     * @param packageName 插件包名
     * @returns 插件导出对象
     *
     * @eng
     *
     * Load a plugin and return the module.exports object exported by the plugin.
     *
     * If the plugin is not installed or does not exist, throw a PluginLoadException.
     *
     * @param packageName plugin package name
     * @returns plugin exported object
     *
     * @example
     * ```javascript
     * "nodejs";
     * async function main() {
     *     const plugins = require("plugins");
     *     const ffmpeg = await plugins.load("org.autojs.plugin.ffmpeg");
     *     console.log(ffmpeg.inProcess.exec('-i /path/to/mp4.mp4 /path/to/mp3.mp3'));
     * }
     * main().catch(console.error);
     * ```
     */
    export function load(packageName: string): Promise<any>;
    /**
     * @中文
     *
     * 卸载插件。卸载后继续使用之前的插件导出对象将导致未定义行为。
     *
     * @param packageName 插件包名
     * @returns 是否成功卸载插件
     *
     * @eng
     *
     * Unload a plugin. Using the plugin exported object is an undefined behavior after unloading.
     */
    export function unload(packageName: string): Promise<boolean>;
    /**
     * @中文
     *
     * 卸载所有插件。卸载后继续使用之前的插件导出对象将导致未定义行为。
     *
     * @eng
     *
     * Unload all plugins. Using the plugin exported object is an undefined behavior after unloading.
     */
    export function unloadAll(): Promise<void>;
}
declare module "power_manager" {
    /**
     * @中文
     *
     * 返回当前是否对应用pkg启用了【忽略电池优化】。
     *
     * @param pkg 应用包名，默认为本应用包名
     * @returns 是否已忽略电池优化
     *
     * @eng
     *
     * Returns whether the application with the specify package name is enabled to ignore battery optimization.
     *
     * @param pkg The package name of the application, default to the package name of this application.
     * @returns Whether the application is enabled to ignore battery optimization.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { isIgnoringBatteryOptimizations } = require('power_manager');
     * console.log('isIgnoringBatteryOptimizations:', isIgnoringBatteryOptimizations());
     * ```
     */
    export function isIgnoringBatteryOptimizations(pkg?: string): boolean;
    /**
     * @中文
     *
     * 请求用户忽略对应用pkg的电池优化。系统将会弹出一个弹窗提示用户确认，这个过程是异步的，确认结果不会返回。
     *
     * @param forceRequest 如果为false，并且当前已经开启了忽略电池优化，则不执行请求；如果为true，则一律请求忽略电池优化。默认为false。
     * @param pkg 需要忽略电池优化的包名。默认为本应用包名。
     *
     * @eng
     *
     * Request user to ignore battery optimization of the application with the specify package name. System will pop up a dialog to ask user to confirm, this process is asynchronous, the result of the confirmation will not be returned.
     *
     * @param forceRequest If false and the current application is enabled to ignore battery optimization, the request will not be executed; if true, the request will always be executed. The default is false.
     * @param pkg The package name of the application to ignore battery optimization. The default is the package name of this application.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { isIgnoringBatteryOptimizations, requestIgnoreBatteryOptimizations } = require('power_manager');
     * if (!isIgnoringBatteryOptimizations()) {
     *    console.log('requestIgnoreBatteryOptimizations');
     *    requestIgnoreBatteryOptimizations();
     * }
     * ```
     */
    export function requestIgnoreBatteryOptimizations(forceRequest?: boolean, pkg?: string): void;
    /**
     * @中文
     *
     * 如果设备处于交互状态，则返回 true。
     *
     * 当此方法返回 true 时，设备处于唤醒状态并准备好与用户交互（尽管这并不能保证用户此时正在积极地与设备交互）。主屏幕通常在此状态下打开。某些功能（例如接近传感器）可能会暂时关闭屏幕，同时仍使设备处于交互状态。
     *
     * 当此方法返回 false 时，设备正在打瞌睡或睡着，并且必须在它准备好再次与用户交互之前被唤醒。在这种状态下，主屏幕通常是关闭的。某些功能，例如“环境模式”可能会导致主屏幕保持开启（尽管处于低功耗状态）以在设备打盹时显示系统提供的内容。
     *
     * @eng
     *
     * Returns true if the device is in an interactive state.
     *
     * When this method returns true, the device is awake and ready to interact with the user (although this is not a guarantee that the user is actively interacting with the device just this moment). The main screen is usually turned on while in this state. Certain features, such as the proximity sensor, may temporarily turn off the screen while still leaving the device in an interactive state. Note in particular that the device is still considered to be interactive while dreaming (since dreams can be interactive) but not when it is dozing or asleep.
     *
     * When this method returns false, the device is dozing or asleep and must be awoken before it will become ready to interact with the user again. The main screen is usually turned off while in this state. Certain features, such as "ambient mode" may cause the main screen to remain on (albeit in a low power state) to display system-provided content while the device dozes.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { isScreenOn } = require('power_manager');
     * console.log(isScreenOn());
     * ```
     */
    export function isScreenOn(): boolean;
    /**
     * @中文
     *
     * 唤醒锁。
     *
     * @eng
     *
     * WakeLock。
     *
     * @see [PowerManager.WakeLock](https://developer.android.com/reference/android/os/PowerManager.WakeLock)
     */
    export interface WakeLock extends android.os.PowerManager.WakeLock {
        release(): void;
        isHeld(): boolean;
        acquire(timeout?: number): void;
        release(flags?: number): void;
        acquire(): void;
    }
    /**
     * @中文
     *
     * 创建具有指定级别和标志的新唤醒锁。
     *
     * levelAndFlags 参数指定使用逻辑或"|"运算符组合的唤醒锁定级别和可选标志。
     *
     * 唤醒锁定级别为：PARTIAL_WAKE_LOCK、FULL_WAKE_LOCK、SCREEN_DIM_WAKE_LOCK 和 SCREEN_BRIGHT_WAKE_LOCK。必须将确切的一个唤醒锁定级别指定为 levelAndFlags 参数的一部分。
     *
     * 唤醒锁定标志是：ACQUIRE_CAUSES_WAKEUP 和 ON_AFTER_RELEASE。多个标志可以组合为 levelAndFlags 参数的一部分。
     *
     * 在对象上调用 acquire() 以获取唤醒锁，并在完成后调用 release()。
     *
     * 尽管无需特殊权限即可创建唤醒锁，但需要 android.Manifest.permission.WAKE_LOCK 权限才能实际获取或释放返回的唤醒锁。
     *
     * 如果使用它来保持屏幕开启，您应该强烈考虑使用 android.view.WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON 代替。当用户在应用程序之间移动时，该窗口标志将由平台正确管理，并且不需要特殊权限。此外，使用标志将在多显示器场景中仅保持适当的屏幕打开，而使用唤醒锁将保持每个屏幕都打开。
     *
     * @param tag 用于调试目的的类名（或其他标记）。
     * @param levelAndFlags 唤醒锁级别和标志值的组合，定义了所请求的 WakeLock 行为。
     * @returns
     *
     * @eng
     *
     * Creates a new wake lock with the specified level and flags.
     *
     * The levelAndFlags parameter specifies a wake lock level and optional flags combined using the logical OR operator.
     *
     * The wake lock levels are: PARTIAL_WAKE_LOCK, FULL_WAKE_LOCK, SCREEN_DIM_WAKE_LOCK and SCREEN_BRIGHT_WAKE_LOCK. Exactly one wake lock level must be specified as part of the levelAndFlags parameter.
     *
     * The wake lock flags are: ACQUIRE_CAUSES_WAKEUP and ON_AFTER_RELEASE. Multiple flags can be combined as part of the levelAndFlags parameters.
     *
     * Call acquire() on the object to acquire the wake lock, and release() when you are done.
     *
     * Although a wake lock can be created without special permissions, the android.Manifest.permission.WAKE_LOCK permission is required to actually acquire or release the wake lock that is returned.
     *
     * If using this to keep the screen on, you should strongly consider using android.view.WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON instead. This window flag will be correctly managed by the platform as the user moves between applications and doesn't require a special permission. Additionally using the flag will keep only the appropriate screen on in a multi-display scenario while using a wake lock will keep every screen powered on.
     *
     * @param tag Your class name (or other tag) for debugging purposes.
     * @param levelAndFlags Combination of wake lock level and flag values defining the requested behavior of the WakeLock.
     * @returns
     *
     * @see [PowerManager.newWakeLock](https://developer.android.com/reference/android/os/PowerManager#newWakeLock(int,%20java.lang.String))。
     */
    export function newWakeLock(levelAndFlags: number, tag: string): WakeLock;
    export interface WakeUpOptions {
        /**
         * @中文
         *
         * 唤醒锁释放时间，默认为5000毫秒。
         *
         * @eng
         *
         * Wake lock release time, the default is 5000 milliseconds
         */
        timeout?: number;
        /**
         * @中文
         *
         * 唤醒锁行为标志，默认为`PowerManager.FULL_WAKE_LOCK | PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.ON_AFTER_RELEASE`，参见[PowerManager.newWakeLock](https://developer.android.com/reference/android/os/PowerManager#newWakeLock(int,%20java.lang.String))。
         *
         * @eng
         *
         * Wake lock behavior flag, the default is `PowerManager.FULL_WAKE_LOCK | PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.ON_AFTER_RELEASE`. See [PowerManager.newWakeLock](https://developer.android.com/reference/android/os/PowerManager#newWakeLock(int,%20java.lang.String)).
         */
        flags?: number;
    }
    /**
     * @中文
     *
     * 获取一个唤醒锁，该唤醒锁将唤醒屏幕并保持一定时间, timeout时间（默认为5秒）后唤醒锁将自动释放。
     *
     * @param options 唤醒锁选项
     *
     * @eng
     *
     * Acquire a wakelock that wakes the screen for a certain amount of time.
     *
     * @see [PowerManager.newWakeLock](https://developer.android.com/reference/android/os/PowerManager#newWakeLock(int,%20java.lang.String))。
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { isScreenOn, wakeUp } = require('power_manager');
     * if (!isScreenOn()) {
     *     wakeUp();
     * }
     * ```
     */
    export function wakeUp(options?: WakeUpOptions): void;
}
declare module "root_automator" {
    /**
     * @中文
     *
     * RootAutomator是一个使用root权限或adb权限来模拟触摸的对象，用它可以完成触摸与多点触摸，并且这些动作的执行没有延迟。相比起基于无障碍的操作，RootAutomator支持多点触控和动态改变手势。
     *
     * ::: tip
     * 从Pro 9.3开始，推荐使用{@link createRootAutomator2}来代替RootAutomator，相比RootAutomator，它有更好的设备兼容性。
     * :::
     *
     * @eng
     *
     * RootAutomator is an object that uses root or adb permissions to simulate touch. It can be used to complete touch and multi-touch, and the execution of these actions is not delayed. Compared to accessibility-based operations, RootAutomator supports multi-touch and dynamically changing gestures.
     *
     * ::: tip
     * Since Pro 9.3, it is recommended to use {@link createRootAutomator2} instead of RootAutomator, which has better device compatibility than RootAutomator.
     * :::
     *
     * @packageDocumentation
     */
    import { ShellOptions } from "shell";
    /**
     * @中文
     *
     * 创建RootAutomator的选项，包括是否使用root权限、adb权限，或者显式指定输入设备。
     *
     * @eng
     *
     * Create RootAutomator options, including whether to use root permission, adb permission, or explicit input device.
     *
     * @see {@link createRootAutomator}
     */
    export interface RootAutomatorOptions extends ShellOptions {
        /**
         * @中文
         *
         * 触摸输入设备的路径，比如/dev/input/event5。
         *
         * @eng
         *
         * Input device path, such as /dev/input/event5.
         */
        inputDevice?: string;
        /**
         * @中文
         *
         * 是否根据屏幕方向自动切换坐标系，若为true，在横屏时坐标会相对横屏屏幕左上角；若为false，则和Rhino API的RootAutomator行为一致。默认为true。
         *
         * @eng
         *
         * Whether to automatically switch the coordinate system according to the screen orientation. If true, the coordinates will be relative to the top-left corner of the horizontal screen in landscape orientation; if false, the behavior is consistent with the Rhino API's RootAutomator. Defaults to true.
         */
        orientationAware?: boolean;
    }
    /**
     * @中文
     *
     * RootAutomator用于基于root或者adb权限，模拟点击、手势、长按等操作。相比起基于无障碍的操作，RootAutomator支持多点触控和动态改变手势，但可能兼容性不佳。
     *
     * 从Pro 9.3开始推荐使用{@link RootAutomator2}代替RootAutomator。
     *
     * @eng
     *
     * RootAutomator is used to simulate click, gesture, and long press operations based on root or adb permission. Compared to the operation based on accessibility, RootAutomator supports multiple-touch and dynamic gesture, but may not be compatible with all devices.
     *
     * Since Pro 9.3 it is recommended to use {@link RootAutomator2} instead of RootAutomator.
     */
    export interface RootAutomator {
        sendEvent(type: number, code: number, value: number): void;
        syncReport(): void;
        touch(x: number, y: number): void;
        touchX(x: number): void;
        touchY(y: number): void;
        sendSync(): void;
        /**
         * @中文
         *
         * 点击位置(x, y)，时长为5毫秒。
         *
         * @param id 手指ID，默认为0
         * @returns 返回一个Promise对象，当操作完成时，Promise对象会被resolve。
         *
         * @eng
         *
         * Click position (x, y), duration is 5 milliseconds.
         *
         * @param id Finger ID, default is 0
         * @returns A Promise object, which will be resolved when the operation is completed.
         */
        tap(x: number, y: number, id?: number): Promise<void>;
        /**
         * @中文
         *
         * 在给定的duration时长从(x1, y1)位置滑动到(x2, y2)位置。
         *
         * @param duration 滑动时长，单位毫秒
         * @param id 手指ID，默认为0
         * @param sampleMs 滑动点采样时间，单位毫秒，默认为8毫秒
         * @returns 返回一个Promise对象，当操作完成时，Promise对象会被resolve。
         *
         * @eng
         *
         * Swipe from (x1, y1) to (x2, y2) position on the given duration.
         *
         * @param duration Swipe duration, unit is milliseconds
         * @param id Finger ID, default is 0
         * @param sampleMs Swipe point sampling time, unit is milliseconds, default is 8 milliseconds
         * @returns A Promise object, which will be resolved when the operation is completed.
         *
         */
        swipe(x1: number, y1: number, x2: number, y2: number, duration: number, id?: number, sampleMs?: number): Promise<void>;
        /**
         * @中文
         *
         * 按下(x, y)位置持续duration时长，然后抬起手指。
         *
         * @param duration 按下时长，单位毫秒
         * @param id 手指ID，默认为0
         * @returns 返回一个Promise对象，当操作完成时，Promise对象会被resolve。
         *
         * @eng
         *
         * Press on (x, y) position for the given duration, then lift the finger.
         *
         * @param duration Press duration, unit is milliseconds
         * @param id Finger ID, default is 0
         * @returns A Promise object, which will be resolved when the operation is completed.
         *
         */
        press(x: number, y: number, duration: number, id?: number): Promise<void>;
        /**
         * @中文
         *
         * 长按(x, y)位置。长按的时长为[ViewConfiguration.getLongPressTimeout()](https://developer.android.com/reference/android/view/ViewConfiguration.html#getLongPressTimeout())+100毫秒。
         *
         * @param id 手指ID，默认为0
         * @returns 返回一个Promise对象，当操作完成时，Promise对象会被resolve。
         *
         * @eng
         *
         * Long press on (x, y) position. The duration of long press is [ViewConfiguration.getLongPressTimeout()](https://developer.android.com/reference/android/view/ViewConfiguration.html#getLongPressTimeout())+100 milliseconds.
         *
         * @param id Finger ID, default is 0
         * @returns A Promise object, which will be resolved when the operation is completed.
         *
         */
        longPress(x: number, y: number, id?: number): Promise<void>;
        /**
         * @中文
         *
         * 按下(x, y)位置。
         *
         * @param id 手指ID，默认为0
         *
         * @eng
         *
         * Touch down on (x, y) position.
         *
         * @param id Finger ID, default is 0
         */
        touchDown(x: number, y: number, id?: number): void;
        /**
         * @中文
         *
         * 抬起手指。
         *
         * @param id 手指ID，默认为0
         *
         * @eng
         *
         * Touch up.
         *
         * @param id Finger ID, default is 0
         */
        touchUp(id?: number): void;
        /**
         * @中文
         *
         * 将手指移动到(x, y)位置。
         *
         * @param id 手指ID，默认为0
         *
         * @eng
         *
         * Move finger to (x, y) position.
         *
         * @param id Finger ID, default is 0
         */
        touchMove(x: number, y: number, id?: number): void;
        /**
         * @中文
         *
         * 退出RootAutomator。
         *
         * @param forced 如果为true，则会强制杀死进程并中断操作；如果为false，在会当前操作结束后退出进程。
         * @returns 返回一个Promise对象，在退出完成后resolve
         *
         * @eng
         *
         * Exit RootAutomator.
         *
         * @param forced If true, the process will be forcibly killed and the operation will be interrupted; if false, the process will be exited after the current operation ends.
         * @returns A Promise object, which will be resolved when the operation is completed.
         */
        exit(forced?: boolean): Promise<void>;
    }
    /**
     * @中文
     *
     * 描述一个指针、手指的触摸位置。
     *
     * @eng
     *
     * Describes the touch position of a pointer, finger.
     *
     * @see {@link RootAutomator2.touchDown}
     * @see {@link RootAutomator2.touchMove}
     * @see {@link RootAutomator2.touchUp}
     */
    export interface Pointer {
        readonly x: number;
        readonly y: number;
        /**
         * @中文
         *
         * 指针/手指的id，从0开始。
         *
         * @eng
         *
         * The id of the pointer/finger, starting from 0.
         */
        readonly id: number;
    }
    /**
     * @中文
     *
     * RootAutomator2用于基于root或者adb权限，模拟点击、手势、长按等操作。相比起基于无障碍的操作，RootAutomator支持多点触控和动态改变手势；相比RootAutomator，RootAutomator2的兼容性更佳。
     *
     * @eng
     *
     * RootAutomator is used to simulate click, gesture, and long press operations based on root or adb permission. Compared to the operation based on accessibility, RootAutomator supports multiple-touch and dynamic gesture, but may not be compatible with all devices.
     */
    export interface RootAutomator2 {
        /**
         * @中文
         *
         * 点击位置(x, y)，时长为5毫秒。
         *
         * @returns 返回一个Promise对象，当操作完成时，Promise对象会被resolve。
         *
         * @eng
         *
         * Click position (x, y), duration is 5 milliseconds.
         *
         * @returns A Promise object, which will be resolved when the operation is completed.
         *
         * @example
         * ```js
         * "nodejs";
         *
         * async function main() {
         *     const ra = await createRootAutomator2();
    
         *     // 点击(200, 200)的位置
         *     await ra.tap(200, 200);
         * }
         *
         * main().catch(console.error);
         * ```
         */
        tap(x: number, y: number): Promise<void>;
        /**
         * @中文
         *
         * 在给定的duration时长从(x1, y1)位置滑动到(x2, y2)位置。
         *
         * @param duration 滑动时长，单位毫秒
         * @returns 返回一个Promise对象，当操作完成时，Promise对象会被resolve。
         *
         * @eng
         *
         * Swipe from (x1, y1) to (x2, y2) position on the given duration.
         *
         * @param duration Swipe duration, unit is milliseconds
         * @returns A Promise object, which will be resolved when the operation is completed.
         *
         * @example
         * ```js
         * "nodejs";
         *
         * async function main() {
         *     const ra = await createRootAutomator2();
    
         *     // 从(1000, 50)滑动到(1000, 1000)的位置，滑动时长300ms
         *     await ra.swipe(1000, 50, 1000, 1000, 300);
         * }
         *
         * main().catch(console.error);
         * ```
         */
        swipe(x1: number, y1: number, x2: number, y2: number, duration: number): Promise<void>;
        /**
         * @中文
         *
         * 按下(x, y)位置持续duration时长，然后抬起手指。
         *
         * @param duration 按下时长，单位毫秒
         * @returns 返回一个Promise对象，当操作完成时，Promise对象会被resolve。
         *
         * @eng
         *
         * Press on (x, y) position for the given duration, then lift the finger.
         *
         * @param duration Press duration, unit is milliseconds
         * @returns A Promise object, which will be resolved when the operation is completed.
         * @example
         * ```js
         * "nodejs";
         *
         * async function main() {
         *     const ra = await createRootAutomator2();
    
         *     // 按下(1000, 500)位置持续2秒
         *     await ra.press(1000, 500, 2000);
         * }
         *
         * main().catch(console.error);
         * ```
         *
         */
        press(x: number, y: number, duration: number): Promise<void>;
        /**
         * @中文
         *
         * 长按(x, y)位置。长按的时长为[ViewConfiguration.getLongPressTimeout()](https://developer.android.com/reference/android/view/ViewConfiguration.html#getLongPressTimeout())+100毫秒。
         *
         * @returns 返回一个Promise对象，当操作完成时，Promise对象会被resolve。
         *
         * @eng
         *
         * Long press on (x, y) position. The duration of long press is [ViewConfiguration.getLongPressTimeout()](https://developer.android.com/reference/android/view/ViewConfiguration.html#getLongPressTimeout())+100 milliseconds.
         *
         * @returns A Promise object, which will be resolved when the operation is completed.
         *
         * ```js
         * "nodejs";
         *
         * async function main() {
         *     const ra = await createRootAutomator2();
    
         *     // 长按(1000, 500)的位置
         *     await ra.longPress(1000, 500);
         * }
         *
         * main().catch(console.error);
         * ```
         */
        longPress(x: number, y: number): Promise<void>;
        /**
         * @中文
         *
         * 按下(x, y)位置。若对应id的手指之前已经是按下状态，则会模拟手指移动(touchMove)事件。
         *
         * @param id 手指ID，默认为0
         *
         * @eng
         *
         * Touch down the (x, y) position. If the finger corresponding to the id has been pressed before, a touchMove event will be simulated.
         *
         * @param id Finger ID, default is 0
         */
        touchDown(x: number, y: number, id?: number): Promise<void>;
        /**
         * @中文
         *
         * 模拟一个手指按下事件，使用数组描述触摸的位置和相应的手指id。例如`ra.touchDown([{x: 100, y: 100, id: 0}, {x: 200, y: 200, id: 1}])`会使用手指0按下位置(100, 100)，使用手指1按下位置(200, 200)。
         *
         * @eng
         *
         * Send a tocuh down event with multiple pointers, use an array to describe these locations and the corresponding finger ids. For example `ra.touchDown([{x: 100, y: 100, id: 0}, {x: 200, y: 200, id: 1}])` will use finger 0 to touch down at position (100, 100), touch position (200, 200) with finger 1.
         *
         */
        touchDown(pointers: Array<Pointer>): Promise<void>;
        /**
         * @中文
         *
         * 抬起手指。
         *
         * @param id 手指ID，若不指定则抬起所有手指
         *
         * @eng
         *
         * Touch up.
         *
         * @param id Finger ID, if not specified, all fingers will be up
         */
        touchUp(id?: number): Promise<void>;
        /**
         * @中文
         *
         * 模拟一个手指抬起事件，使用数组描述触摸的位置和相应的手指id。例如`ra.touchUp([{x: 100, y: 100, id: 0}, {x: 200, y: 200, id: 1}])`会使用手指0和手指1抬起，其中的坐标位置为手指抬起时的位置。
         *
         * @eng
         *
         * Send a touch up event, using an array to describe the location of the touch and the corresponding finger id. For example `ra.touchUp([{x: 100, y: 100, id: 0}, {x: 200, y: 200, id: 1}])` will use finger 0 and finger 1 up, where the coordinates The position is the position when the finger is lifted.
         *
         */
        touchUp(pointers: Array<Pointer>): Promise<void>;
        /**
         * @中文
         *
         * 将手指移动到(x, y)位置。若对应id的手指之前并非按下状态，则会模拟手指按下(touchDown)事件。
         *
         * @param id 手指ID，默认为0
         *
         * @eng
         *
         * Touch down the (x, y) position. If the finger corresponding to the id has been pressed before, a touchMove event will be simulated.
         *
         * @param id Finger ID, default is 0
         */
        touchMove(x: number, y: number, id?: number): void;
        /**
         * @中文
         *
         * 模拟一个手指移动事件，使用数组描述触摸的位置和相应的手指id。例如`ra.touchMove([{x: 100, y: 100, id: 0}, {x: 200, y: 200, id: 1}])`会将手指0移动到位置(100, 100)，将手指1移动到位置(200, 200)。
         *
         * @eng
         *
         * Move your finger to the (x, y) position. If the finger corresponding to the id was not in the pressed state before, a touchDown event will be simulated.
         *
         */
        touchMove(pointers: Array<Pointer>): Promise<void>;
        /**
         * @中文
         *
         * 等待所有操作完成。例如我们使用`tocuhDown`, `touchMove`, `touchUp`完成了一系列手势，需要等待这些手势完成后继续下一步时，使用`await ra.flush()`来异步等待。
         *
         * @eng
         *
         * Wait for all pending operations to complete. For example, we use `tocuhDown`, `touchMove`, `touchUp` to send a series of gestures, and when we need to wait for these gestures to complete and continue to the next step, use `await ra.flush()` to asynchronously wait.
         *
         */
        flush(): Promise<void>;
        /**
         * @中文
         *
         * 退出RootAutomator2。
         *
         * @param forced 如果为true，将不等待未完成的操作，而是尽可能快地退出；如果为false，在会所有未完成的操作结束后退出进程。
         * @returns 返回一个Promise对象，在退出完成后resolve
         *
         * @eng
         *
         * Exit RootAutomator.
         *
         * @param forced If true, will not wait for outstanding operations, but exit as soon as possible; if false, exit the process after all outstanding operations are completed.
         * @returns A Promise object, which will be resolved when the operation is completed.
         */
        exit(forced?: boolean): Promise<void>;
    }
    /**
     * @中文
     *
     * 根据选项创建一个新的RootAutomator实例。
     *
     * 可以指定是否使用root权限、adb权限、输入设备路径等，参见{@link RootAutomatorOptions}。如果不指定root或adb权限，则默认用{@link getDefaultShellOptions}获取的默认值。
     *
     * 对于输入设备路径`inputDevice`，如果不指定，则会自动检测，但检测失败时会抛出异常；你也可以手动在终端运行`getevent -t`，然后在屏幕上操作，看输入事件的设备路径是什么，比如`/dev/input/event5`。
     *
     * ::: tip
     * 从Pro 9.3开始，推荐使用{@link createRootAutomator2}来代替RootAutomator，相比RootAutomator，它有更好的设备兼容性。
     * :::
     *
     * @param options 创建RootAutomator的选项
     *
     * @eng
     *
     * Create a new RootAutomator instance.
     *
     * You can specify whether to use root permission, adb permission, input device path, etc, see {@link RootAutomatorOptions}. If you don't specify root or adb permission, the default value from {@link getDefaultShellOptions} will be used.
     *
     * For input device path `inputDevice`, if you don't specify, it will be automatically detected, but if it fails to detect, it will throw an exception. You can run `getevent -t` in terminal, then move your finger on the screen, and see the input device path, like `/dev/input/event5`.
     *
     * ::: tip
     * Since Pro 9.3, it is recommended to use {@link createRootAutomator2} instead of RootAutomator, which has better device compatibility than RootAutomator.
     * :::
     *
     * @param options Create RootAutomator options
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { createRootAutomator } = require("root_automator");
     * async function main() {
     *     const ra = await createRootAutomator({root: true});
     *     await ra.tap(100, 100);
     *     await ra.exit();
     * }
     * main();
     * ```
     */
    export function createRootAutomator(options?: RootAutomatorOptions): Promise<RootAutomator>;
    /**
     * @中文
     *
     * 根据选项创建一个新的RootAutomator2实例。RootAutomator2相比RootAutomator有更好的兼容性。
     *
     * 可以指定是否使用root权限、adb权限等，参见{@link ShellOptions}。如果不指定root或adb权限，则默认用{@link getDefaultShellOptions}获取的默认值。
     *
     * @param options 创建RootAutomator2的选项
     *
     * @eng
     *
     * Creates a new RootAutomator2 instance based on the options. RootAutomator2 has better compatibility than RootAutomator.
     *
     * You can specify whether to use root permission, adb permission, etc, see {@link ShellOptions}. If you don't specify root or adb permission, the default value from {@link getDefaultShellOptions} will be used.
     *
     * @param options Create RootAutomator2 options
     *
     * @example
     * ```js
     * "nodejs";
     *
     * const { createRootAutomator2 } = require('root_automator');
     * const { delay } = require('lang');
     * const { device } = require('device');
     *
     * const { screenWidth, screenHeight } = device;
     *
     * async function main() {
     *     const ra = await createRootAutomator2({ root: true });
     *
     *     await ra.tap(200, 200);
     *     await delay(1000);
     *
     *     await ra.press(screenWidth / 2, screenHeight / 2, 500);
     *     await delay(1000);
     *
     *     await ra.swipe(500, 800, 500, 1000, 300);
     *     await delay(1000);
     *
     *
     *     let p0 = {
     *         x: screenWidth / 6,
     *         y: screenHeight / 6,
     *     };
     *     let p1 = {
     *         x: screenWidth - p0.x,
     *         y: screenHeight - p0.y,
     *     }
     *     ra.touchDown([
     *         { x: p0.x, y: p0.y, id: 0 },
     *         { x: p1.x, y: p1.y, id: 1 },
     *     ]);
     *
     *     const steps = 20;
     *     const stepX = Math.round((p1.x - p0.x) / steps) / 2;
     *     const stepY = Math.round((p1.y - p0.y) / steps) / 2;
     *     for (let i = 0; i < steps; i++) {
     *         ra.touchMove([
     *             { x: p0.x + stepX * i, y: p0.y + stepY * i, id: 0 },
     *             { x: p1.x - stepX * i, y: p1.y - stepY * i, id: 1 }
     *         ]);
     *     }
     *     await ra.touchUp();
     *     await ra.flush();
     *
     *     await ra.exit();
     * }
     *
     * main().catch(console.error);
     * ```
     */
    export function createRootAutomator2(options?: ShellOptions): Promise<RootAutomator2>;
}
declare module "sensors" {
    /**
     * @中文
     *
     * sensors模块提供了获取手机上的传感器的信息的支持，这些传感器包括距离传感器、光线光感器、重力传感器、方向传感器等。需要指出的是，本模块只能获取传感器的数据，Auto.js Pro不提供模拟或伪造传感器的数据和事件的功能。
     *
     * @eng
     *
     * sensors module provides the support for getting the sensor information of the device, including the distance sensor, light sensor, gravity sensor, orientation sensor, etc. Note that this module can only get the sensor data, Auto.js Pro does not provide the simulation or fake sensor data and event function.
     *
     * @packageDocumentation
     */
    import { EventEmitter } from "events";
    type AndroidSensor = android.hardware.Sensor;
    /**
     * @中文
     *
     * 传感器事件的更新频率。
     *
     * 作为函数{@link SensorExt.enableSensorEvent}的参数，决定`change`事件的频率。
     *
     * @eng
     *
     * rate of events. This is only a hint to the system. events may be received faster or slower than the specified rate. Usually events are received faster.
     *
     * As the parameter of {@link SensorExt.enableSensorEvent}, determine the rate of `change` event.
     *
     */
    export enum SensorDelay {
        /**
         * @中文
         *
         * 尽可能快地获取传感器数据。
         *
         * @eng
         *
         * get sensor data as fast as possible
         */
        Fastest = 0,
        /**
         * @中文
         *
         * 适合游戏的传感器频率。
         *
         * @eng
         *
         * rate suitable for games
         */
        Game = 1,
        /**
         * @中文
         *
         * 适合UI的传感器频率。
         *
         * @eng
         *
         * rate suitable for the user interface
         */
        Ui = 2,
        /**
         * @中文
         *
         * 默认传感器事件频率。
         *
         * @eng
         *
         * rate (default) suitable for screen orientation changes
         */
        Normal = 3
    }
    /**
     * @中文
     *
     * {@link getSensor}返回的对象类型，在Android原生[Sensor类](https://developer.android.com/reference/android/hardware/Sensor)上拓展了额外的函数，参见{@link SensorExt}。
     *
     * @eng
     *
     * The type of object returned by {@link getSensor}, which extends the original [Android Sensor class](https://developer.android.com/reference/android/hardware/Sensor) with extra functions, see {@link SensorExt}.
     */
    export type Sensor = AndroidSensor & SensorExt;
    /**
     * @中文
     *
     * {@link getSensor}返回的对象的拓展，在Android原生[Sensor类](https://developer.android.com/reference/android/hardware/Sensor)上拓展了额外的函数，主要是{@link SensorExt.enableSensorEvent}和{@link SensorExt.disableSensorEvent}。
     *
     * @eng
     *
     * The extension of object returned by {@link getSensor}, which extends the original [Android Sensor class](https://developer.android.com/reference/android/hardware/Sensor) with extra functions, including {@link SensorExt.enableSensorEvent} and {@link SensorExt.disableSensorEvent}.
     */
    export interface SensorExt extends EventEmitter {
        /**
         * @中文
         *
         * 传感器数据回调事件。其回调的第一个参数是[android.hardware.SensorEvent](https://developer.android.com/reference/android/hardware/SensorEvent)对象，后面的参数则根据传感器类型不同而不同。
         *
         * 常见的传感器的参数类型为：
         *
         * * `accelerometer`: `(event: SensorEvent, ax: number, agy: number, az: number)`，表示各个方向的加速度，单位是`m/s^2`。
         * * `magnetic_field`: `(event: SensorEvent, hx: number, hy: number, hz: number)`，表示各个方向磁场强度，单位是`uT`。
         * * `orientation`: `(event: SensorEvent, azimuth: number, pitch: number, roll: number)`，表示方向，参见[SensorEvent.values](https://developer.android.com/reference/android/hardware/SensorEvent.html#values)。
         * * `gyroscope`: `(event: SensorEvent, axisX: number, axisY: number, axisZ: number)`，表示各个方向的角速度，单位是`rad/s`。
         * * `light`: `(event: SensorEvent, lux: number)`，表示光线强度，单位是`lx`。
         * * `pressure`: `(event: SensorEvent, pressure: number)`，表示气压，单位是`hPa`。
         * * `temperature`: `(event: SensorEvent, temperature: number)`，表示温度，单位是`°C`。
         * * `proximity`: `(event: SensorEvent, distance: number)`，表示距离，单位是`cm`。
         * * `gravity`: `(event: SensorEvent, gx: number, gy: number, gz: number)`，表示各个方向的重力加速度，单位是`m/s^2`。
         * * `linear_acceleration`: `(event: SensorEvent, ax: number, ay: number, az: number)`，表示各个方向的线性加速度，单位是`m/s^2`。
         *
         * @eng
         *
         * Sensor data event. The first parameter is an [android.hardware.SensorEvent](https://developer.android.com/reference/android/hardware/SensorEvent) object, and the rest of the parameters are according to the sensor type.
         *
         * The common sensor parameter type is:
         *
         * * `accelerometer`: `(event: SensorEvent, ax: number, agy: number, az: number)`，the acceleration in each direction, unit is `m/s^2`。
         * * `magnetic_field`: `(event: SensorEvent, hx: number, hy: number, hz: number)`，the magnetic field strength in each direction, unit is `uT`。
         * * `orientation`: `(event: SensorEvent, azimuth: number, pitch: number, roll: number)`, see [SensorEvent.values](https://developer.android.com/reference/android/hardware/SensorEvent.html#values)。
         * * `gyroscope`: `(event: SensorEvent, axisX: number, axisY: number, axisZ: number)`，the angular velocity in each direction, unit is `rad/s`。
         * * `light`: `(event: SensorEvent, lux: number)`，the light intensity, unit is `lx`。
         * * `pressure`: `(event: SensorEvent, pressure: number)`，the pressure, unit is `hPa`。
         * * `temperature`: `(event: SensorEvent, temperature: number)`，the temperature, unit is `°C`。
         * * `proximity`: `(event: SensorEvent, distance: number)`，the distance, unit is `cm`。
         * * `gravity`: `(event: SensorEvent, gx: number, gy: number, gz: number)`，the gravity acceleration in each direction, unit is `m/s^2`。
         * * `linear_acceleration`: `(event: SensorEvent, ax: number, ay: number, az: number)`，the linear acceleration in each direction, unit is `m/s^2`。
         *
         * @see [SensorEvent](https://developer.android.com/reference/android/hardware/SensorEvent)
         * @event change
         */
        on(event: "change", listener: (event: android.hardware.SensorEvent, ...args: any) => void): this;
        /**
         * @中文
         *
         * 传感器精度变化事件。传感器精度`accuracy`范围为0~3，0表示数据不可靠，1~3表示低精度到高精度。
         *
         * @eng
         *
         * Sensor accuracy change event. The sensor accuracy range is 0~3, 0 means data is unreliable, 1~3 means low to high accuracy.
         *
         * @see [onAccuracyChanged](https://developer.android.com/reference/android/hardware/SensorEventListener.html#onAccuracyChanged(android.hardware.Sensor,%20int))
         * @event accuracy_change
         */
        on(event: "accuracy_change", listener: (event: android.hardware.SensorEvent, accuracy: number) => void): this;
        /**
         * @中文
         *
         * 启用传感器事件。在调用本函数前，传感器将不会发送`change`和`accuracy_change`事件。
         *
         * @param delay 传感器事件频率
         *
         * @eng
         *
         * Enable sensor event. Before calling this function, the sensor will not send `change` and `accuracy_change` event.
         *
         * @param delay sensor event rate
         */
        enableSensorEvent(delay?: SensorDelay): this;
        /**
         * @中文
         *
         * 禁用传感器事件。在调用本函数后，传感器将不会发送`change`和`accuracy_change`事件。
         *
         * @eng
         *
         * Disable sensor event. After calling this function, the sensor will not send `change` and `accuracy_change` event.
         */
        disableSensorEvent(): this;
    }
    /**
     * @中文
     *
     * 通过传感器名称获取传感器对象，如果找不到该名称对应的传感器，则返回`undefined`。
     *
     * 常见的传感器列表有：
     * * `accelerometer` 加速度传感器
     * * `magnetic_field` 磁场传感器
     * * `orientation` 方向传感器
     * * `gyroscope` 陀螺仪传感器
     * * `light` 光线传感器
     * * `pressure` 压力传感器
     * * `temperature` 温度传感器
     * * `proximity` 接近(距离)传感器
     * * `gravity` 重力传感器
     * * `linear_acceleration` 线性加速度传感器
     *
     * 完整的列表参见[Sensor](https://developer.android.com/reference/android/hardware/Sensor#TYPE_ALL)。
     *
     * @param name 传感器名称
     * @returns 传感器对象，或者undefined
     *
     * @eng
     *
     *
     * Get the sensor object by the specified sensor name, or `undefined` if not found.
     *
     * A list of common sensors:
     * * `accelerometer`
     * * `magnetic_field`
     * * `orientation`
     * * `gyroscope`
     * * `light`
     * * `pressure`
     * * `temperature`
     * * `proximity`
     * * `gravity`
     * * `linear_acceleration`
     *
     * See [Sensor](https://developer.android.com/reference/android/hardware/Sensor#TYPE_ALL) for a full list.
     *
     * @param name the sensor name
     * @returns the sensor object, or undefined
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { getSensor, SensorDelay } = require("sensors");
     *
     * const sensor = getSensor("light");
     * sensor.enableSensorEvent(SensorDelay.Normal)
     *       .on("change", (light) => {
     *           console.log(light);
     *       });
     * $autojs.keepRunning();
     * ```
     */
    export function getSensor(name: string): Sensor | undefined;
}
declare module "work_manager" {
    /**
     * @中文
     *
     * 任务配置。
     *
     * @eng
     *
     * Task configuration.
     */
    export interface TaskConfig {
        /**
         * @中文
         *
         * 任务的脚本路径，绝对路径。
         *
         * @eng
         *
         * The script path of the task, must be a absolute path.
         */
        readonly path: string;
    }
    /**
     * @中文
     *
     * 日期时间类型，可以是number，表示毫秒时间戳；可以是string，表示标准时间格式；可以是Date对象，表示日期对象。
     *
     * @eng
     *
     * DateTime type, could be a number which represents millisecond timestamp; or be a string which represents standard time format; or a Date object.
     */
    export type DateTime = number | string | Date;
    /**
     * @中文
     *
     * 定时任务配置。
     *
     * @eng
     *
     * Timed task configuration.
     *
     * @see {@link addDailyTask}
     * @see {@link addWeeklyTask}
     * @see {@link addOneTimeTask}
     */
    export interface TimedTaskConfig extends TaskConfig {
        /**
         * @中文
         *
         * 定时任务的执行时间。如果是周期性任务，该时间只会取相应周期的时间，比如每日任务只会取小时和分钟。
         *
         * @eng
         *
         * The time of the timed task. If the task is a periodic task, this time will only take the time of the corresponding period, for example, the daily task will only take the hour and minute.
         */
        readonly time: DateTime;
    }
    /**
     * @中文
     *
     * 新增一个每日运行一次的定时任务。其中时间参数会只保留每天的时间，忽略年月日。
     * 例如创建一个每日下午1点14分运行的定时任务。
     *
     * @param task 用于描述此定时任务的配置
     *
     * @eng
     *
     * Add a timed task which runs once a day. The time parameter will only keep the time of the day, ignore the year, month and day.
     *
     * For example, create a timed task which runs at 1:14 PM every day.
     *
     * @param task The configuration of the timed task.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { addDailyTask } = require("work_manager");
     * addDailyTask({
     *     path: "/path/to/script.js",
     *     time: new Date(0, 0, 0, 13, 14, 0),
     * })).then(task => console.log(task));
     * ```
     */
    export function addDailyTask(task: TimedTaskConfig): Promise<Task>;
    export type DaysOfWeek = 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday' | '一' | '二' | '三' | '四' | '五' | '六' | '日';
    /**
     * @中文
     *
     * 每周任务的配置。
     *
     * @eng
     *
     * Weekly task configuration.
     *
     * @see {@link addWeeklyTask}
     */
    interface WeeklyTaskConfig extends TimedTaskConfig {
        /**
         * @中文
         *
         * 每周的哪几天执行。可以是数字，比如0表示周日，1表示周一。也可以是字符串，比如"周一"、"Sunday"。
         *
         * @eng
         *
         * The days of the week to run. Could be a number, like 0 for Sunday, 1 for Monday. Or a string, like "Sunday".
         *
         */
        readonly daysOfWeek: Array<DaysOfWeek | number>;
    }
    /**
     * @中文
     *
     * 新增一个按星期运行的定时任务。
     *
     * 例如创建一个每周一周二下午1点14分的定时任务
     *
     * @param task 用于描述此定时任务的配置
     *
     * @eng
     *
     * Add a timed task which runs every week.
     *
     * For example, create a timed task which runs every Monday and Tuesday at 1:14 PM.
     *
     * @param task The configuration of the timed task.
     *
     * @example
     *
     * ```javascript
     * "nodejs";
     * const { addWeeklyTask } = require("work_manager");
     * addWeeklyTask({
     *     path: "/sdcard/脚本/test.js",
     *     // Mon Jun 21 2021 13:14:00 GMT+0800
     *     time: 1624252440000,
     *     daysOfWeek: ['Monday', 'Tuesday'],
     * }).then(task => console.log(task));
     * ```
     */
    export function addWeeklyTask(task: WeeklyTaskConfig): Promise<Task>;
    /**
     * @中文
     *
     * 此函数会新增一个一次性的定时任务，任务在执行一次后将在定时任务中自动删除。
     *
     * 例如创建一个2021年5月21日13点14分运行的定时任务。
     *
     * @eng
     *
     * Add a timed task which runs once.
     *
     * For example, create a timed task which runs on May 21, 2021 at 1:14 PM.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { addOneTimeTask } = require("work_manager");
     * addOneTimeTask({
     *     path: "/sdcard/to/script.js",
     *     time: new Date(2021, 5, 21, 13, 14, 0),
     * }).then(task => console.log(task));
     * ```
     */
    export function addOneTimeTask(task: TimedTaskConfig): Promise<Task>;
    /**
     * @中文
     *
     * 意图任务的配置，包括广播任务（接收特定广播事件而触发）、活动任务（外部文件、链接需要打开、编辑时触发）。
     *
     * @eng
     *
     * The configuration of the intent task. It includes broadcast task (triggers at a specific broadcast event), and activity task (triggers at opening external files, links, etc. ).
     *
     * @see {@link addBroadcastIntentTask}
     * @see {@link addActivityIntentTask}
     */
    export interface IntentTaskConfig extends TaskConfig {
        /**
         * @中文
         *
         * 任务的action。比如在活动任务中，"android.intent.action.VIEW"是查看文件时触发；在广播任务中，"android.intent.action.BATTERY_CHANGED"是电量变化时触发。
         *
         * @eng
         *
         * The action of the task. For example, in an activity task, "android.intent.action.VIEW" is triggered when opening files; in a broadcast task, "android.intent.action.BATTERY_CHANGED" is triggered when the battery changes.
         */
        readonly action: string;
        readonly local?: boolean;
        /**
         * @中文
         *
         * 指定是活动任务(activity_intent_task)还是广播任务(broadcast_intent_task)。
         *
         * @eng
         *
         * Specifies whether the task is an activity task (activity_intent_task) or a broadcast task (broadcast_intent_task).
         */
        readonly type?: 'broadcast_intent_task' | 'activity_intent_task';
        /**
         * @中文
         *
         * 用于活动任务中，过滤文件的类型（MimeType）。
         *
         * @eng
         *
         * The MIME type of the file to be opened in an activity task.
         */
        readonly dataType?: string;
    }
    /**
     * @中文
     *
     * 新增一个意图任务，分为两种类型：
     * * 广播意图任务：会在特定事件(广播)时运行。
     * * 活动意图任务：在外部应用处理文件时运行。比如文件管理中请求打开文件、其他应用中分享文件或文本时，若选择由Auto.js处理，则触发相应任务运行。
     *
     * 推荐使用{@link addBroadcastIntentTask}和{@link addActivityIntentTask}，而非直接使用本函数添加任务。
     *
     * @eng
     *
     * Add an intent task. There are two types:
     * * Broadcast intent task: run at a specific broadcast event.
     * * Activity intent task: run when opening external files in an external application. For example, when opening files in the file manager, or when sharing files or text in other applications, if the user selects Auto.js, the corresponding task will be triggered.
     *
     * It is recommended to use {@link addBroadcastIntentTask} and {@link addActivityIntentTask} instead of using this function to add tasks.
     */
    export function addIntentTask(task: IntentTaskConfig): Promise<Task>;
    /**
     *
     * @中文
     *
     * 新增一个广播任务，会在特定事件(广播)时运行。
     *
     * 最关键的参数是广播事件的Action。系统在发生特定事件（比如电量变化）时会发出特定Action的广播。
     *
     * 例如创建一个在电量发生变化时运行脚本的定时任务：
     * ```javascript
     * "nodejs";
     * const { android } = require('rhino').Packages;
     * const Intent = android.content.Intent;
     * const { addBroadcastIntentTask } = require("work_manager");
     * addBroadcastIntentTask({
     *     path: "/path/to/script.js",
     *     action: Intent.ACTION_BATTERY_CHANGED,
     * }).then(task => console.log(`Task ${task} added`));
     * ```
     *
     * 可以在Android文档[Intent: Action](https://developer.android.google.cn/reference/android/content/Intent#constants_1)中找到大多数Android系统自带的Intent Action；一些系统组件也会自定义自己的Action，比如网络连接变化时触发的Action是`ConnectivityManager.CONNECTIVITY_ACTION`（使用时需要导入ConnectivityManager)。
     *
     * 以下列出一些常见的广播Action：
     * * org.autojs.autojs.action.startup : Auto.js启动时，可给Auto.js加上自启动后使任务在开机时运行
     * * Intent.ACTION_BOOT_COMPLETED : 开机时
     * * Intent.ACTION_SCREEN_OFF : 熄屏时
     * * Intent.ACTION_SCREEN_ON : 亮屏时
     * * Intent.ACTION_USER_PRESENT : 屏幕解锁时
     * * Intent.ACTION_BATTERY_CHANGED : 电量变化时
     * * Intent.ACTION_POWER_CONNECTED : 电源连接时
     * * Intent.ACTION_POWER_DISCONNECTED : 电源断开时
     * * ConnectivityManager.CONNECTIVITY_ACTION : 网络连接变化时
     * * Intent.ACTION_PACKAGE_ADDED : 新应用安装时
     * * Intent.ACTION_PACKAGE_REMOVED : 应用卸载时
     * * Intent.ACTION_PACKAGE_REPLACED : 应用更新时
     * * Intent.ACTION_HEADSET_PLUG : 耳机拔插时
     * * Intent.ACTION_CONFIGURATION_CHANGED : 某些设置（屏幕方向、地区等）更改时
     * * Intent.ACTION_TIME_TICK : 每分钟一次
     *
     * 在广播任务运行时，通过`require('engines').myEngine().execArgv.intent`获取广播的Intent对象，通过Intent对象获取对应的参数。
     *
     * 以下是电量变化时触发的任务脚本，获取当前电量。
     * ```javascript
     * "nodejs";
     * const { myEngine } = require('engines');
     * const { android } = require('rhino').Packages;
     *
     * const intent = myEngine().execArgv.intent;
     * if (!intent) {
     *    process.exit();
     * }
     * const BatteryManager = android.os.BatteryManager;
     * const level = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
     * console.log("Battery:", level);
     * ```
     *
     * @param task 意图任务配置
     * @returns 添加的任务的Promise
     *
     * @eng
     *
     * Add a broadcast intent task, will run when a specific event (broadcast) happens.
     *
     * The most important parameter is the broadcast event's Action. System will send out a specific Action broadcast when a specific event (such as battery changed) happens.
     *
     * For example, create a task that runs a script when battery changed:
     * ```javascript
     * "nodejs";
     * const { android } = require('rhino').Packages;
     * const Intent = android.content.Intent;
     * const { addBroadcastIntentTask } = require("work_manager");
     * addBroadcastIntentTask({
     *    path: "/path/to/script.js",
     *   action: Intent.ACTION_BATTERY_CHANGED,
     * }).then(task => console.log(`Task ${task} added`));
     * ```
     *
     * You can find most of Android system's built-in Intent Action in [Intent: Action](https://developer.android.google.cn/reference/android/content/Intent#constants_1) in Android document.
     * Some system components also define their own Actions, for example, ConnectivityManager.CONNECTIVITY_ACTION (use `require('ConnectivityManager')` to import it).
     *
     * Here are some common broadcast Actions:
     * * org.autojs.autojs.action.startup : Auto.js startup
     * * Intent.ACTION_BOOT_COMPLETED : Boot completed
     * * Intent.ACTION_SCREEN_OFF : Screen off
     * * Intent.ACTION_SCREEN_ON : Screen on
     * * Intent.ACTION_USER_PRESENT : Screen unlock
     * * Intent.ACTION_BATTERY_CHANGED : Battery changed
     * * Intent.ACTION_POWER_CONNECTED : Power connected
     * * Intent.ACTION_POWER_DISCONNECTED : Power disconnected
     * * ConnectivityManager.CONNECTIVITY_ACTION : Network connectivity changed
     * * Intent.ACTION_PACKAGE_ADDED : Package added
     * * Intent.ACTION_PACKAGE_REMOVED : Package removed
     * * Intent.ACTION_PACKAGE_REPLACED : Package replaced
     * * Intent.ACTION_HEADSET_PLUG : Headset plugged
     * * Intent.ACTION_CONFIGURATION_CHANGED : Configuration changed
     * * Intent.ACTION_TIME_TICK : Time tick on every minute
     *
     * When the task runs, you can get the Intent object by `require('engines').myEngine().execArgv.intent`.
     *
     * The following is an example of getting battery level when battery changed task is run:
     * ```javascript
     * "nodejs";
     * const { myEngine } = require('engines');
     * const { android } = require('rhino').Packages;
     *
     * const intent = myEngine().execArgv.intent;
     * if (!intent) {
     *    process.exit();
     * }
     * const BatteryManager = android.os.BatteryManager;
     * const level = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
     * console.log("Battery:", level);
     * ```
     *
     * @param task Broadcast intent task configuration
     * @returns Promise of added task
     *
     */
    export function addBroadcastIntentTask(task: IntentTaskConfig): Promise<Task>;
    /**
     * @中文
     *
     * 添加在外部应用处理文件时运行的任意图务。比如文件管理中请求打开文件、其他应用中分享文件或文本时，若选择由Auto.js处理，则触发相应任务运行。
     *
     * 首要参数是action，决定了什么动作会触发任务运行。比如：
     * * `android.intent.action.VIEW`：外部应用打开文件时触发，比如文件管理器中打开mp3、apk等文件
     * * `android.intent.action.SEND`：其他应用分享文件时触发
     * * 更多Action参见[Intent: Action](https://developer.android.google.cn/reference/android/content/Intent#constants_1)
     *
     * 其次是dataType，决定了什么类型的文件会触发任务运行。比如：
     * * *\/*：所有文件
     * * application/vnd.android.package-archive: apk文件
     * * text/plain: 文本文件
     * * video/*: 视频文件
     * * image/*: 图片文件
     *
     * 以下代码执行后将添加一个可以在外部应用查看文本文件的任务：
     * ```javascript
     * const { addActivityIntentTask } = require("work_manager");
     *
     * addActivityIntentTask({
     *   path: "/sdcard/脚本/handle_text.js",
     *   action: 'android.intent.action.VIEW',
     *   dataType: "text/plain"
     * }).then(task => console.log(`Task ${task} added`));
     * ```
     *
     * 以下代码是handle_text.js的内容，他会执行时读取要处理的文件内容并打印：
     * ```
     * // handle_text.js
     * "nodejs";
     * const { myEngine } = require('engines');
     * const { getPathFromUri } = require('app');
     * const { readFileSync } = require('fs');
     * const intent = myEngine().execArgv.intent;
     * if (!intent) {
     *     process.exit();
     * }
     * const uri = intent.getUri();
     * const file = getPathFromUri(uri);
     * console.log(file);
     * console.log(readFileSync(file, 'utf8'));
     * ```
     *
     * @param task 意图任务配置
     * @returns 添加的任务的Promise
     *
     * @eng
     *
     * Add a task to run when an activity intent is handled.
     *
     * For example, when an activity intent is handled, such as opening a file in file manager, the task will be run.
     *
     * The first parameter is action, which decides what action will trigger the task. For example:
     *
     * * `android.intent.action.VIEW`: When an activity intent is handled, such as opening a file in file manager, the task will be run.
     * * `android.intent.action.SEND`: When an activity intent is handled, such as sharing a file, the task will be run.
     * * More actions can be found in [Intent: Action](https://developer.android.google.cn/reference/android/content/Intent#constants_1)
     *
     * The second parameter is dataType, which decides what type of file will trigger the task. For example:
     * * *\/*: All files
     * * application/vnd.android.package-archive: apk files
     * * text/plain: Text files
     * * video/*: Video files
     * * image/*: Image files
     *
     * The following code will add a task to run when an activity intent is handled to open a text file:
     *
     * ```javascript
     * const { addActivityIntentTask } = require("work_manager");
     *
     * addActivityIntentTask({
     *   path: "/sdcard/Scripts/handle_text.js",
     *   action: 'android.intent.action.VIEW',
     *   dataType: "text/plain"
     * }).then(task => console.log(`Task ${task} added`));
     * ```
     *
     * The following code is the content of handle_text.js, which will read the file content and print it:
     * ```
     * // handle_text.js
     * "nodejs";
     * const { myEngine } = require('engines');
     * const { getPathFromUri } = require('app');
     * const { readFileSync } = require('fs');
     * const intent = myEngine().execArgv.intent;
     * if (!intent) {
     *     process.exit();
     * }
     * const uri = intent.getUri();
     * const file = getPathFromUri(uri);
     * console.log(file);
     * console.log(readFileSync(file, 'utf8'));
     * ```
     *
     */
    export function addActivityIntentTask(task: IntentTaskConfig): Promise<Task>;
    /**
     * @中文
     *
     * 根据任务id获取定时任务。
     *
     * @param id 任务ID
     * @returns 查询的任务的Promise，如果没有找到则resolve null
     *
     * @eng
     *
     * Get the timed task by task ID.
     *
     * @param id Task ID
     *
     * @returns The Promise of the task, if not found, resolve null
     *
     * @see {@link Task.id}
     */
    export function getTimedTask(id: number): Promise<Task | null>;
    /**
     * @中文
     *
     * 根据任务id获取意图任务。
     *
     * @param id 任务ID
     * @returns 查询的任务的Promise，如果没有找到则resolve null
     *
     * @eng
     *
     * Get the intent task by task ID.
     *
     * @param id Task ID
     *
     * @returns The Promise of the task, if not found, resolve null
     *
     * @see {@link Task.id}
     */
    export function getIntentTask(id: number): Promise<Task | null>;
    /**
     *
     * @中文
     *
     * 通过任务id删除一个意图任务。
     *
     * @param id 任务id
     * @returns Promise，表示是否删除成功，若对应的任务不存在，则resolve false，否则resolve true
     *
     * @eng
     *
     * Delete an intent task by id.
     *
     * @param id The id of the task.
     * @returns Promise that indicates whether the task is deleted successfully. If the task does not exist, resolve false, otherwise resolve true.
     *
     * @see {@link Task.id}
     */
    export function removeIntentTask(id: number): Promise<boolean>;
    /**
     *
     * @中文
     *
     * 通过任务id删除一个定时任务。
     *
     * @param id 任务id
     * @returns Promise，表示是否删除成功，若对应的任务不存在，则resolve false，否则resolve true
     *
     * @eng
     *
     * Delete a timed task by id.
     *
     * @param id The id of the task.
     * @returns Promise that indicates whether the task is deleted successfully. If the task does not exist, resolve false, otherwise resolve true.
     *
     * @see {@link Task.id}
     */
    export function removeTimedTask(id: number): Promise<boolean>;
    /**
     * @中文
     *
     * 查询定时任务的条件。
     *
     * @eng
     *
     * The conditions of querying timed tasks.
     *
     * @see {@link queryTimedTasks}
     */
    export interface TimedTaskQuery {
        /**
         * @中文
         *
         * 要查询的任务的脚本文件路径。
         *
         * @eng
         *
         * The script file path of the task to be queried.
         */
        path?: string;
    }
    /**
     *
     * @中文
     *
     * 通过脚本路径等条件查询定时任务。
     *
     *
     * @param query 定时任务查询条件，为空则查询所有任务
     * @returns
     *
     * @eng
     *
     * Query timed tasks by script path.
     *
     * @param query timed task query conditions, empty to query all tasks
     * @returns
     *
     * @example
     * ```javascript
     * "nodejs";
     * const work_manager = require('work-manager');
     *
     * const file = "/path/to/script.js";
     * async function main() {
     * const task = await work_manager.addWeeklyTask({
     *     path: file,
     *     time: 1624252440000,
     *     daysOfWeek: ['Sunday'],
     * });
     * const tasks = await work_manager.queryTimedTasks({
     *     path: file
     * });
     * tasks.forEach(t => {
     *     console.log("delete:", t);
     *     console.log(await work_manager.removeTimedTask(t.id));
     * });
     * }
     */
    export function queryTimedTasks(query?: TimedTaskQuery): Promise<Array<Task>>;
    /**
     * @中文
     *
     * 查询意图任务的条件。
     *
     * @eng
     *
     * The query conditions of the intent task.
     *
     * @see {@link queryIntentTasks}
     */
    export interface IntentTaskQuery {
        /**
         * @中文
         *
         * 要查询的任务的脚本文件路径。
         *
         * @eng
         *
         * The script file path of the task to be queried.
         */
        path?: string;
        /**
         * @中文
         *
         * 要查询的任务的action。
         *
         * @eng
         *
         * The action of the task to be queried.
         */
        action?: string;
    }
    /**
     *
     * @中文
     *
     * 通过脚本路径或Intent Action等条件查询意图任务。
     *
     *
     * @param query intent任务查询条件，为空则查询所有任务
     * @returns
     *
     * @eng
     *
     * Query intent tasks by script path or Intent Action.
     *
     * @param query intent task query conditions, empty to query all tasks
     * @returns
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { queryIntentTasks, addBroadcastIntentTask } = require("work_manager");
     * async function main() {
     *     const task = await addBroadcastIntentTask({
     *         path: "/sdcard/to/script.js",
     *         action: Intent.ACTION_BATTERY_CHANGED,
     *     });
     *     // Query all intent tasks
     *     const tasks = await queryIntentTasks();
     *     console.log(tasks);
     * }
     * main();
     * ```
     */
    export function queryIntentTasks(query?: IntentTaskQuery): Promise<Array<Task>>;
    export type TaskType = 'TimedTask' | 'IntentTask';
    class Task {
        private javaTask;
        /**
         * @中文
         *
         * 任务类型。若为定时任务，则为`TimedTask`；若为意图任务，则为`IntentTask`。
         *
         * @eng
         *
         * The type of the task. If the task is a timed task, it is `TimedTask`; if the task is an intent task, it is `IntentTask`.
         */
        readonly type: TaskType;
        constructor(javaTask: JavaObject);
        get javaObject(): JavaObject;
        /**
         * @中文
         *
         * 获取任务的id。可用于查询、删除任务。
         *
         * @eng
         *
         * Get the id of the task. Can be used to query, delete tasks.
         *
         * @see {@link removeIntentTask}
         * @see {@link removeTimedTask}
         * @see {@link getIntentTask}
         * @see {@link getTimedTask}
         */
        get id(): number;
        /**
         * @中文
         *
         * 任务的脚本文件路径。
         *
         * @eng
         *
         * The script file path of the task.
         */
        get path(): string;
        /**
         * @中文
         *
         * 定时任务的时间。如果是意图任务，则返回表示`1970-01-01T00:00:00.000Z`的Date对象；如果是每周或每日任务，则返回的对象的年月日部分为1970-01-01。
         *
         * @eng
         *
         * The date of the timed task. If the task is an intent task, it returns `1970-01-01T00:00:00.000Z`; if the task is a weekly or daily task, the year, month, and day parts of the returned object are 1970-01-01.
         */
        get dateTime(): Date;
        /**
         * @中文
         *
         * 获取任务的action。若非意图任务，则返回null。
         *
         * @eng
         *
         * Get the action of the task. If not an intent task, return null.
         */
        get action(): string | null;
        /**
         *
         * @中文
         *
         * 根据每周任务在哪几天执行，返回相应的number数组。例如在周日和周四执行返回`[0, 4]`；如果是每日任务，返回`[0, 1, 2, 3, 4, 5, 6]`；如果是一次性任务，返回`[]`。
         *
         * @eng
         *
         * Get the days of the week the task is executed on. Return a number array. For example, if the task is executed on Sunday and Thursday, return `[0, 4]`; if it is a daily task, return `[0, 1, 2, 3, 4, 5, 6]`; if it is a one-time task, return `[]`
         *
         */
        get daysOfWeek(): Array<number>;
        toString(): string;
        static wrap(javaTask?: JavaObject): Task | null;
    }
}
declare module "zip" {
    /**
     * @中文
     *
     * 压缩文件夹下所有文件/文件夹，生成到目标路径`dest`。
     *
     * @param dir 需要压缩的文件夹路径，如果文件夹下有子文件夹均会一并压缩
     * @param dest 压缩后的压缩包存放路径
     * @param options 可选参数
     *
     * @eng
     *
     * Compress all files and folders under `dir` to `dest`.
     *
     * @param dir The path of the folder to be compressed.
     * @param dest The path of the target zip file.
     * @param options Optional parameters.
     *
     * @example
     * ```javascript
     * const { zipDir } = require('zip');
     * zipDir('./dir', './dest.zip')
     *  .then(zipFile => console.log(zipFile));
     * ```
     *
     */
    export function zipDir(dir: string, dest: string, options?: ZipOptions): Promise<ZipFile>;
    /**
     * @中文
     *
     * 压缩单文件`file`到路径`dest`。
     * @param file 需要压缩的单文件路径。
     * @param dest 压缩后的压缩包存放路径
     * @param options 选项
     *
     * @eng
     *
     * Compress a single file `file` to `dest`.
     * @param file The path of the file to be compressed.
     * @param dest The path of the target zip file.
     * @param options Optional parameters.
     *
     * @example
     * ```javascript
     * const { zipFile } = require('zip');
     * zipFile('./file.txt', './dest.zip')
     *  .then(zipFile => console.log(zipFile));
     * ```
     */
    export function zipFile(file: string, dest: string, options?: ZipOptions): Promise<ZipFile>;
    /**
     * @中文
     *
     * 压缩多个文件`fileList`到路径`dest`。`fileList`中不能包含文件夹。
     * @param fileList 需压缩的多个文件路径的数组
     * @param dest 压缩目标路径
     * @param options 选项
     *
     * @eng
     *
     * Compress multiple files `fileList` to `dest`. `fileList` cannot contain folders.
     *
     * @param fileList The array of paths of the files to be compressed.
     * @param dest The path of the target zip file.
     * @param options Optional parameters.
     *
     * @example
     * ```javascript
     * const { zipFiles } = require('zip');
     * zipFiles(['./file1.txt', './file2.txt'], './dest.zip')
     *  .then(zipFile => console.log(zipFile));
     * ```
     */
    export function zipFiles(fileList: Array<string>, dest: string, options?: ZipOptions): Promise<ZipFile>;
    /**
     * @中文
     *
     * 解压zip文件。如果文件夹`dest`不存在则创建该文件夹并将内容解压到里面；如果`dest`已经存在，则在`dest`下面创建一个和`zipFile`文件同名的文件夹，并将内容解压到里面。
     *
     * @param zipFile 需解压的压缩包文件路径
     * @param dest 解压后的文件夹目录
     * @param options 解压选项，可选
     *
     * @eng
     *
     * Unzip a zip file. If `dest` directory does not exist, create it and unzip the content to it; if `dest` directory exists, create a folder with the same name as `zipFile` in `dest` and unzip the content to it.
     *
     * @example
     * ```javascript
     * "nodejs";
     * const { unzip, zipDir } = require('zip');
     *
     * async function main() {
     *     // create a zip file with password
     *     const zipFilePath = './dest.zip';
     *     await zipDir('./dir', zipFilePath, { password: 'Auto.js Pro' });
     *     // unzip the zip file
     *     await unzip(zipFilePath, './dest', { password: 'Auto.js Pro' });
     * }
     * main();
     * ```
     */
    export function unzip(zipFile: string, dest: string, options?: UnzipOptions): Promise<void>;
    /**
     * @中文
     *
     * 打开一个zip文件，返回{@link ZipFile}对象，可对该对象进行进一步的zip操作。
     *
     * @param file 压缩包文件路径
     *
     * @eng
     *
     * Open a zip file and return a `ZipFile` object. You can perform more operations on the returned object.
     *
     * @param file The path of the zip file.
     */
    export function open(file: string): ZipFile;
    /**
     * @中文
     *
     * 压缩选项。
     *
     * @eng
     *
     * Compression options.
     *
     * @example
     * ```javascript
     * const { zipDir } = require('zip');
     * zipDir('./dir', './dest.zip', {
     *    compressionLevel: 9,
     *    password: '123456',
     *    includeRootFolder: false,
     * });
     * ```
     *
     * @see {@link zipDir}
     * @see {@link zipFiles}
     * @see {@link zipFile}
     * @see {@link ZipFile.addFolder}
     * @see {@link ZipFile.addFile}
     * @see {@link ZipFile.addFiles}
     */
    export interface ZipOptions {
        /**
         * @中文
         *
         * AES加密强度，包括`AES_STRENGTH_128`，`AES_STRENGTH_192`，`AES_STRENGTH_256`
         *
         * @eng
         *
         * AES encryption strength, including `AES_STRENGTH_128`, `AES_STRENGTH_192`, `AES_STRENGTH_256`
         */
        aesKeyStrength?: "AES_STRENGTH_128" | "AES_STRENGTH_192" | "AES_STRENGTH_256";
        /**
         * @中文
         *
         * 压缩级别，0~9，0为不压缩，9为最好压缩（速度较慢）。默认为5（正常压缩）。
         *
         * @eng
         *
         * Compression level, 0~9, 0 means no compression, 9 is the smallest size (slow). Default is 5 (normal compression).
         */
        compressionLevel?: number;
        /**
         * @中文
         *
         * 压缩方式，`COMP_STORE`为仅打包不压缩, `COMP_DEFLATE`为压缩（默认）
         *
         * @eng
         *
         * Compression method, `COMP_STORE` means store the file without compression, `COMP_DEFLATE` means compress (default)
         */
        compressionMethod?: "COMP_STORE" | "COMP_DEFLATE";
        /**
         * @中文
         *
         * 压缩或添加文件时，指定文件在压缩包的默认文件夹位置。
         *
         * @eng
         *
         * Specify the default folder path when compressing or adding files.
         */
        defaultFolderPath?: string;
        /**
         * @中文
         *
         * 加密方法，`ENC_NO_ENCRYPTION`为不加密(默认)，`ENC_METHOD_STANDARD`为标准机密, `ENC_METHOD_AES`为AES加密
         *
         * @eng
         *
         * Encryption method, `ENC_NO_ENCRYPTION` means no encryption (default), `ENC_METHOD_STANDARD` means standard encryption, `ENC_METHOD_AES` means AES encryption
         */
        encryptionMethod?: "ENC_NO_ENCRYPTION" | "ENC_METHOD_STANDARD" | "ENC_METHOD_AES";
        /**
         * @中文
         *
         * 压缩或添加文件时，指定文件在压缩包中的路径、名称。
         *
         * @eng
         *
         * Specify the path and name of the file when compressing or adding file.
         *
         * @see {@link ZipFile.addFile}
         * @see {@link ZipFile.addFolder}
         */
        fileNameInZip?: string;
        /**
         * @中文
         *
         * 设置标志以指示添加文件的父文件夹是否将包含在ZIP中。如果为true，则添加文件的父文件夹将包含在ZIP中。默认为true。
         *
         * @eng
         *
         * Set the flag to indicate whether the root folder will be included in the ZIP. Default is true.
         *
         * @see {@link ZipFile.addFolder}
         * @see {@link zipDir}
         */
        includeRootFolder?: boolean;
        /**
         * @中文
         *
         * 加密压缩的密码。如果设置密码但不设置加密方法，则加密方法默认为AES。
         *
         * @eng
         *
         * Password for encryption. If set password but not set encryption method, the encryption method will be AES.
         */
        password?: string;
        /**
         * @中文
         *
         * 压缩文件夹时是否包含隐藏文件。如果为true，则在将文件夹添加到zip时将包含隐藏文件。默认为true。
         *
         * @eng
         *
         * Whether to include hidden files when compressing folder. If true, hidden files will be included when compressing folder. Default is true.
         */
        readHiddenFiles?: boolean;
        /**
         * @中文
         *
         * 设置压缩包首目录的文件夹名称，如果没有首目录，则创建这个首目录。
         *
         * @eng
         *
         * Set the name of the root folder in the ZIP.
         *
         * @see {@link ZipFile.addFolder}
         * @see {@link zipDir}
         */
        rootFolderInZip?: string;
    }
    /**
     * @中文
     *
     * * alls 所有属性
     * * archive 压缩包属性
     * * dateTime 时间
     * * hidden 是否隐藏
     * * readOnly 是否只读
     * * system 是否为系统文件
     *
     * @eng
     *
     * @see {@link UnzipOptions.ignoreAttributes}
     */
    export type ZipFileAttribute = "all" | "archive" | "dateTime" | "hidden" | "system" | "readOnly";
    /**
     * @中文
     *
     * 解压选项。
     *
     * @eng
     *
     * Unzip options.
     *
     * @see {@link unzip}
     * @see {@link ZipFile.extractFile}
     * @see {@link ZipFile.extractAll}
     */
    export interface UnzipOptions {
        /**
         * @中文
         *
         * 解压文件写入磁盘时，要忽略的文件属性。默认为空。
         *
         * @eng
         *
         * File attributes to ignore when writing files to disk. Default is empty.
         *
         * @example
         *
         * ```javascript
         * const { unzip } = require("zip");
         * unzip("test.zip", "./dest", { ignoreAttributes: ["hidden", "system"] })
         *   .then(() => console.log("unzip success"));
         * ```
         */
        ignoreAttributes?: Array<ZipFileAttribute>;
        /**
         * @中文
         *
         * 解压时用于加密文件的密码。
         *
         * @eng
         *
         * Password for decrypting files.
         */
        password?: string;
    }
    /**
     *
     * @中文
     *
     *
     * {@link open}返回的对象，用于在压缩包中增删文件、获取文件头信息、解压等。
     */
    export interface ZipFile {
        /**
         * @中文
         *
         * 获取当前压缩包的路径。
         *
         * @eng
         *
         * Get the path of the current ZIP file.
         */
        getPath(): string;
        /**
         * @中文
         *
         * 获取当前压缩包是否是一个有效的压缩包。
         * 如果选择的路径不是一个压缩包或该文件不存在，均返回`false`。
         *
         * @returns 是否是有效压缩包
         *
         * @eng
         *
         * Get whether the current ZIP file is a valid ZIP file.
         * If the path is not a ZIP file or the file does not exist, return `false`.
         *
         * @returns Whether the current ZIP file is a valid ZIP file.
         */
        isValidZipFile(): boolean;
        /**
         * @中文
         *
         * 如果文件是一个加密的压缩包，必须用此函数设置正确的解压密码，才能解压出加密的文件。
         * 未设置密码尝试解压加密的压缩包将抛出异常，选择的压缩包文件不存在使用本函数将抛出`ZipException`。
         *
         * @param password 密码
         *
         * @eng
         *
         * If the ZIP file is encrypted, you must use this function to set the correct password to decrypt the encrypted file.
         * If you do not set the password, an exception will be thrown when you try to decrypt the encrypted ZIP file.
         *
         * @param password Password
         */
        setPassword(password: string): void;
        /**
         * @中文
         *
         * 获取当前压缩包是否是加密压缩包。
         *
         * @returns 是否压缩包加密
         *
         * @eng
         *
         * Get whether the current ZIP file is an encrypted ZIP file.
         *
         * @returns Whether the current ZIP file is an encrypted ZIP file.
         *
         */
        isEncrypted(): boolean;
        /**
         * @中文
         *
         * 在压缩包中添加指定文件。
         *
         * @param file 本地文件路径
         * @param options 压缩选项
         *
         * @eng
         *
         * Add a file to the ZIP file.
         *
         * @param file Local file path
         * @param options Compress options
         *
         * @example
         * ```javascript
         * const zip = require('zip);
         * async function main() {
         *     const zipFile = await zip.open('test.zip');
         *     await zipFile.addFile('test.txt');
         * }
         * main();
         * ```
         */
        addFile(file: string, options?: ZipOptions): Promise<void>;
        /**
         * @中文
         *
         * 在压缩包中添加多个文件。
         *
         * @param fileList 要添加的本地文件路径的数组
         * @param options 压缩选项，可选
         *
         * @eng
         *
         * Add multiple files to the ZIP file.
         *
         * @param fileList Array of local file paths
         * @param options Compress options
         */
        addFiles(fileList: Array<string>, options?: ZipOptions): Promise<void>;
        /**
         * @中文
         *
         * 在压缩包中添加指定文件夹。
         *
         * @param folder 文件夹路径
         * @param options 压缩选项
         *
         * @eng
         *
         * Add a folder to the ZIP file.
         *
         * @param folder Folder path
         * @param options Compress options
         */
        addFolder(folder: string, options?: ZipOptions): Promise<void>;
        /**
         * @中文
         *
         * 删除zip文件内的指定文件。此方法首先找到文件头，然后删除文件；如果文件不存在，则此方法引发异常。
         *
         * 如果zip文件是分割后的zip文件，则此方法会抛出异常，zip规范不允许更新拆分的zip档案。
         *
         * @param file 要删除的文件
         *
         * @eng
         *
         * Delete a file from the ZIP file. If the file does not exist, this method will throw an exception.
         *
         * If the ZIP file is a segmented ZIP file, this method will throw an exception, because the zip specification does not allow updating a segmented ZIP file.
         *
         * @param file File to delete
         *
         */
        removeFile(file: string): Promise<void>;
        /**
         * @中文
         *
         * 从压缩包文件中提取特定文件到目标路径。如果目标路径无效，则此方法将引发异常。
         *
         * @param file 要解压的文件
         * @param dest 解压文件的目标路径
         * @param options 解压选项
         * @param newFileName 解压后文件的新名字，可选
         *
         * @eng
         *
         * Extract a file from the ZIP file. If the target path is invalid, this method will throw an exception.
         *
         * @param file File to extract
         * @param dest Destination path
         * @param options Extract options
         * @param newFileName New file name, optional
         */
        extractFile(file: string, dest: string, options?: UnzipOptions, newFileName?: string): Promise<void>;
        /**
         * @中文
         *
         * 解压所有文件到目标路径`dest`。
         * @param dest 解压路径
         * @param options 解压选项
         *
         * @eng
         *
         * Extract all files from the ZIP file to the target path `dest`.
         *
         * @param dest Extract path
         * @param options Extract options
         */
        extractAll(dest: string, options?: UnzipOptions): Promise<void>;
        /**
         * @中文
         *
         * 获取压缩包内指定文件的文件头信息。文件头信息包括校验值，是否加密，注释等。
         * @param file 压缩包内指定文件路径
         * @returns [FileHeader](https://javadoc.io/doc/net.lingala.zip4j/zip4j/1.3.2/net/lingala/zip4j/model/FileHeader.html)
         *
         * @eng
         *
         * Get the file header information of the specified file in the ZIP file. The file header information includes the checksum, whether the file is encrypted, comments, etc.
         * @param file File path in the ZIP file
         * @returns [FileHeader](https://javadoc.io/doc/net.lingala.zip4j/zip4j/1.3.2/net/lingala/zip4j/model/FileHeader.html)
         */
        getFileHeader(file: string): JavaObject;
        /**
         * @中文
         *
         * 获取压缩包内所有文件的文件头信息。文件头信息包括校验值，是否加密，注释等。
         * @returns [FileHeader](https://javadoc.io/doc/net.lingala.zip4j/zip4j/1.3.2/net/lingala/zip4j/model/FileHeader.html)的数组
         *
         * @eng
         *
         * Get the file header information of all files in the ZIP file. The file header information includes the checksum, whether the file is encrypted, comments, etc.
         * @returns Array of [FileHeader](https://javadoc.io/doc/net.lingala.zip4j/zip4j/1.3.2/net/lingala/zip4j/model/FileHeader.html)
         */
        getFileHeaders(): Array<JavaObject>;
    }
}
declare module "@autojs/opencv" {
    /**
     * @中文
     *
     * Auto.js Pro 9将[opencv4nodejs](https://www.npmjs.com/package/opencv4nodejs)迁移到了内置模块[@autojs/opencv](https://www.npmjs.com/package/@autojs/opencv?activeTab=readme)。你可以像使用opencv4nodejs模块一样使用它而无需用`npm i`安装。
     *
     * 本模块比较重要的类有{@link Mat}，{@link Rect}, {@link Point}等。
     *
     * 有关opencv4nodejs的更多文档参见：
     * 1. [OpenCV 4.5.1文档](https://docs.opencv.org/4.5.1/index.html)，[OpenCV Mat](https://docs.opencv.org/4.5.1/d3/d63/classcv_1_1Mat.html)
     * 1. [opencv4nodejs Quick Start](https://www.npmjs.com/package/@autojs/opencv?activeTab=readme#quick-start)。
     * 2. [opencv4nodejs docs](https://justadudewhohacks.github.io/opencv4nodejs/docs/Mat)
     *
     * 由于OpenCV本身的内容比较庞大，不太可能将OpenCV的文档翻译并迁移到这里，因此OpenCV部分需要自行阅读和理解上述英文文档。以下的文档由.d.ts文件内容生成，仅标注了所有函数、常量、类的名称、类型等信息，没有详细注释。
     *
     * @eng
     *
     * Auto.js Pro 9 migrates [opencv4nodejs](https://www.npmjs.com/package/opencv4nodejs) to built-in module [@autojs/opencv](https://www.npmjs.com/package/@autojs/opencv?activeTab=readme).  You can use it like opencv4nodejs without npm installation.
     *
     * The documentation of opencv4nodejs can be found:
     * 1. [OpenCV 4.5.1 Docs](https://docs.opencv.org/4.5.1/index.html)，[OpenCV Mat](https://docs.opencv.org/4.5.1/d3/d63/classcv_1_1Mat.html)
     * 1. [opencv4nodejs Quick Start](https://www.npmjs.com/package/@autojs/opencv?activeTab=readme#quick-start)。
     * 2. [opencv4nodejs docs](https://justadudewhohacks.github.io/opencv4nodejs/docs/Mat)
     *
     * Since the content of OpenCV itself is relatively large, it is unlikely that the documents of OpenCV will be translated and migrated here, so the OpenCV part needs to read and understand the above English documents by yourself. The following documents are generated from the content of the .d.ts file, only marking all functions, constants, class names, types and other information, without detailed comments.
     *
     * @example
     *
     * ```javascript
     * "nodejs";
     *
     * const cv = require("@autojs/opencv");
     * const rows = 100; // height
     * const cols = 100; // width
     * const emptyMat = new cv.Mat(rows, cols, cv.CV_8UC3);
     * // fill the Mat with default value
     * const whiteMat = new cv.Mat(rows, cols, cv.CV_8UC1, 255);
     * const blueMat = new cv.Mat(rows, cols, cv.CV_8UC3, [255, 0, 0]);
     * ```
     * @packageDocumentation
     */
    export * from '@autojs/opencv';
}


/// <reference types="node" />
declare module "@autojs/opencv" {
    export class Size {
        readonly width: number;
        readonly height: number;
        constructor();
        constructor(width: number, height: number);
    }
}
declare module "@autojs/opencv" {
    export class TermCriteria {
        readonly type: number;
        readonly maxCount: number;
        readonly epsilon: number;
        constructor();
        constructor(type: number, maxCount: number, epsilon: number);
    }
}
declare module "@autojs/opencv" {
    import { Size } from "@autojs/opencv";
    export class Rect {
        readonly x: number;
        readonly y: number;
        readonly width: number;
        readonly height: number;
        constructor();
        constructor(x: number, y: number, width: number, height: number);
        and(rect2: Rect): Rect;
        or(rect2: Rect): Rect;
        pad(factor: number): Rect;
        pad(size: Size): Rect;
        padAsync(factor: number): Promise<Rect>;
        padAsync(size: Size): Promise<Rect>;
        rescale(factor: number): Rect;
        rescaleAsync(factor: number): Promise<Rect>;
        toSquare(): Rect;
        toSquareAsync(): Promise<Rect>;
    }
}
declare module "@autojs/opencv" {
    export class Point {
        add(otherPoint: Point): Point;
        at(index: number): number;
        div(s: number): Point;
        mul(s: number): Point;
        norm(): number;
        sub(otherPoint: Point): Point;
    }
}
declare module "@autojs/opencv" {
    import { Point } from "@autojs/opencv";
    export class Point2 extends Point {
        readonly x: number;
        readonly y: number;
        constructor(x: number, y: number);
    }
}
declare module "@autojs/opencv" {
    import { Size } from "@autojs/opencv";
    import { Rect } from "@autojs/opencv";
    import { Point2 } from "@autojs/opencv";
    export class RotatedRect {
        readonly center: Point2;
        readonly size: Size;
        readonly angle: number;
        constructor();
        constructor(center: Point2, size: Size, angle: number);
        boundingRect(): Rect;
    }
}
declare module "@autojs/opencv" {
    export class Moments {
        readonly m00: number;
        readonly m10: number;
        readonly m01: number;
        readonly m20: number;
        readonly m11: number;
        readonly m02: number;
        readonly m30: number;
        readonly m21: number;
        readonly m12: number;
        readonly m03: number;
        readonly mu20: number;
        readonly mu11: number;
        readonly mu02: number;
        readonly mu30: number;
        readonly mu21: number;
        readonly mu12: number;
        readonly mu03: number;
        readonly nu20: number;
        readonly nu11: number;
        readonly nu02: number;
        readonly nu30: number;
        readonly nu21: number;
        readonly nu12: number;
        readonly nu03: number;
        huMoments(): number[];
    }
}
declare module "@autojs/opencv" {
    import { Vec } from "@autojs/opencv";
    export class Vec3 extends Vec {
        readonly x: number;
        readonly y: number;
        readonly z: number;
        constructor(x: number, y: number, z: number);
    }
}
declare module "@autojs/opencv" {
    import { Vec3 } from "@autojs/opencv";
    export class Vec {
        absdiff(otherVec: Vec): Vec;
        add(otherVec: Vec): Vec;
        at(index: number): number;
        cross(): Vec3;
        div(s: number): Vec;
        exp(): Vec;
        hDiv(otherVec: Vec): Vec;
        hMul(otherVec: Vec): Vec;
        mean(): Vec;
        mul(s: number): Vec;
        norm(): number;
        sqrt(): Vec;
        sub(otherVec: Vec): Vec;
    }
}
declare module "@autojs/opencv" {
    import { Vec } from "@autojs/opencv";
    export class Vec4 extends Vec {
        readonly w: number;
        readonly x: number;
        readonly y: number;
        readonly z: number;
        constructor(w: number, x: number, y: number, z: number);
    }
}
declare module "@autojs/opencv" {
    import { Rect } from "@autojs/opencv";
    import { RotatedRect } from "@autojs/opencv";
    import { Moments } from "@autojs/opencv";
    import { Point2 } from "@autojs/opencv";
    import { Vec4 } from "@autojs/opencv";
    export class Contour {
        readonly numPoints: number;
        readonly area: number;
        readonly isConvex: boolean;
        readonly hierarchy: Vec4;
        constructor();
        constructor(pts: Point2[]);
        constructor(pts: number[][]);
        approxPolyDP(epsilon: number, closed: boolean): Point2[];
        approxPolyDPContour(epsilon: number, closed: boolean): Contour;
        arcLength(closed?: boolean): number;
        boundingRect(): Rect;
        convexHull(clockwise?: boolean): Contour;
        convexHullIndices(clockwise?: boolean): number[];
        convexityDefects(hullIndices: number[]): Vec4[];
        fitEllipse(): RotatedRect;
        getPoints(): Point2[];
        matchShapes(contour2: Contour, method: number): number;
        minAreaRect(): RotatedRect;
        minEnclosingCircle(): {
            center: Point2;
            radius: number;
        };
        minEnclosingTriangle(): Point2[];
        moments(): Moments;
        pointPolygonTest(pt: Point2): number;
    }
}
declare module "@autojs/opencv" {
    import { Point } from "@autojs/opencv";
    export class Point3 extends Point {
        readonly x: number;
        readonly y: number;
        readonly z: number;
        constructor(x: number, y: number, z: number);
    }
}
declare module "@autojs/opencv" {
    import { Vec } from "@autojs/opencv";
    export class Vec2 extends Vec {
        readonly x: number;
        readonly y: number;
        constructor(x: number, y: number);
    }
}
declare module "@autojs/opencv" {
    import { Size } from "@autojs/opencv";
    import { TermCriteria } from "@autojs/opencv";
    import { RotatedRect } from "@autojs/opencv";
    import { Rect } from "@autojs/opencv";
    import { Moments } from "@autojs/opencv";
    import { Contour } from "@autojs/opencv";
    import { Point2 } from "@autojs/opencv";
    import { Vec2 } from "@autojs/opencv";
    import { Vec3 } from "@autojs/opencv";
    import { Vec4 } from "@autojs/opencv";
    export class Mat {
        readonly rows: number;
        readonly cols: number;
        readonly type: number;
        readonly channels: number;
        readonly depth: number;
        readonly dims: number;
        readonly empty: boolean;
        readonly step: number;
        readonly elemSize: number;
        readonly sizes: number[];
        constructor();
        constructor(channels: Mat[]);
        constructor(rows: number, cols: number, type: number);
        constructor(rows: number, cols: number, type: number, fillValue: number);
        constructor(rows: number, cols: number, type: number, fillValue: number[]);
        constructor(rows: number, cols: number, type: number, fillValue: number[]);
        constructor(rows: number, cols: number, type: number, fillValue: number[]);
        constructor(dataArray: number[][], type: number);
        constructor(dataArray: number[][][], type: number);
        constructor(dataArray: number[][][], type: number);
        constructor(dataArray: number[][][], type: number);
        constructor(data: Buffer, rows: number, cols: number, type?: number);
        abs(): Mat;
        absdiff(otherMat: Mat): Mat;
        accumulate(src: Mat, mask?: Mat): Mat;
        accumulateAsync(src: Mat, mask?: Mat): Promise<Mat>;
        accumulateProduct(src1: Mat, src2: Mat, mask?: Mat): Mat;
        accumulateProductAsync(src1: Mat, src2: Mat, mask?: Mat): Promise<Mat>;
        accumulateSquare(src: Mat, mask?: Mat): Mat;
        accumulateSquareAsync(src: Mat, mask?: Mat): Promise<Mat>;
        accumulateWeighted(src: Mat, alpha: number, mask?: Mat): Mat;
        accumulateWeightedAsync(src: Mat, alpha: number, mask?: Mat): Promise<Mat>;
        adaptiveThreshold(maxVal: number, adaptiveMethod: number, thresholdType: number, blockSize: number, C: number): Mat;
        adaptiveThresholdAsync(maxVal: number, adaptiveMethod: number, thresholdType: number, blockSize: number, C: number): Promise<Mat>;
        add(otherMat: Mat): Mat;
        addWeighted(alpha: number, mat2: Mat, beta: number, gamma: number, dtype?: number): Mat;
        addWeightedAsync(alpha: number, mat2: Mat, beta: number, gamma: number, dtype?: number): Promise<Mat>;
        and(otherMat: Mat): Mat;
        at(row: number, col: number): number;
        at(row: number, col: number): Vec2;
        at(row: number, col: number): Vec3;
        at(row: number, col: number): Vec4;
        at(idx: number[]): number;
        at(idx: number[]): Vec2;
        at(idx: number[]): Vec3;
        at(idx: number[]): Vec4;
        atRaw(row: number, col: number): number;
        atRaw(row: number, col: number): number[];
        atRaw(row: number, col: number): number[];
        atRaw(row: number, col: number): number[];
        bgrToGray(): Mat;
        bgrToGrayAsync(): Promise<Mat>;
        bilateralFilter(d: number, sigmaColor: number, sigmaSpace: number, borderType?: number): Mat;
        bilateralFilterAsync(d: number, sigmaColor: number, sigmaSpace: number, borderType?: number): Promise<Mat>;
        bitwiseAnd(otherMat: Mat): Mat;
        bitwiseNot(): Mat;
        bitwiseOr(otherMat: Mat): Mat;
        bitwiseXor(otherMat: Mat): Mat;
        blur(kSize: Size, anchor?: Point2, borderType?: number): Mat;
        blurAsync(kSize: Size, anchor?: Point2, borderType?: number): Promise<Mat>;
        boxFilter(ddepth: number, ksize: Size, anchor?: Point2, normalize?: boolean, borderType?: number): Mat;
        boxFilterAsync(ddepth: number, ksize: Size, anchor?: Point2, normalize?: boolean, borderType?: number): Promise<Mat>;
        buildPyramid(maxLevel: number, borderType?: number): Mat[];
        buildPyramidAsync(maxLevel: number, borderType?: number): Promise<Mat[]>;
        calibrationMatrixValues(imageSize: Size, apertureWidth: number, apertureHeight: number): {
            fovx: number;
            fovy: number;
            focalLength: number;
            principalPoint: Point2;
            aspectRatio: number;
        };
        calibrationMatrixValuesAsync(imageSize: Size, apertureWidth: number, apertureHeight: number): Promise<{
            fovx: number;
            fovy: number;
            focalLength: number;
            principalPoint: Point2;
            aspectRatio: number;
        }>;
        canny(threshold1: number, threshold2: number, apertureSize?: number, L2gradient?: boolean): Mat;
        cannyAsync(threshold1: number, threshold2: number, apertureSize?: number, L2gradient?: boolean): Promise<Mat>;
        compareHist(H2: Mat, method: number): number;
        compareHistAsync(H2: Mat, method: number): Promise<number>;
        connectedComponents(connectivity?: number, ltype?: number): Mat;
        connectedComponentsAsync(connectivity?: number, ltype?: number): Promise<Mat>;
        connectedComponentsWithStats(connectivity?: number, ltype?: number): {
            labels: Mat;
            stats: Mat;
            centroids: Mat;
        };
        connectedComponentsWithStatsAsync(connectivity?: number, ltype?: number): Promise<{
            labels: Mat;
            stats: Mat;
            centroids: Mat;
        }>;
        convertScaleAbs(alpha: number, beta: number): Mat;
        convertScaleAbsAsync(alpha: number, beta: number): Promise<Mat>;
        convertTo(type: number, alpha?: number, beta?: number): Mat;
        convertToAsync(type: number, alpha?: number, beta?: number): Promise<Mat>;
        copy(mask?: Mat): Mat;
        copyAsync(mask?: Mat): Promise<Mat>;
        copyMakeBorder(top: number, bottom: number, left: number, right: number, borderType?: number, value?: number | Vec2 | Vec3 | Vec4): Mat;
        copyMakeBorderAsync(top: number, bottom: number, left: number, right: number, borderType?: number, value?: number | Vec2 | Vec3 | Vec4): Promise<Mat>;
        copyTo(dst: Mat, mask?: Mat): Mat;
        copyToAsync(dst: Mat, mask?: Mat): Promise<Mat>;
        cornerEigenValsAndVecs(blockSize: number, ksize?: number, borderType?: number): Mat;
        cornerEigenValsAndVecsAsync(blockSize: number, ksize?: number, borderType?: number): Promise<Mat>;
        cornerHarris(blockSize: number, ksize: number, k: number, borderType?: number): Mat;
        cornerHarrisAsync(blockSize: number, ksize: number, k: number, borderType?: number): Promise<Mat>;
        cornerMinEigenVal(blockSize: number, ksize?: number, borderType?: number): Mat;
        cornerMinEigenValAsync(blockSize: number, ksize?: number, borderType?: number): Promise<Mat>;
        cornerSubPix(corners: Point2[], winSize: Size, zeroZone: Size, criteria: TermCriteria): Point2[];
        cornerSubPixAsync(corners: Point2[], winSize: Size, zeroZone: Size, criteria: TermCriteria): Promise<Point2[]>;
        correctMatches(points1: Point2[], points2: Point2[]): {
            newPoints1: Point2[];
            newPoints2: Point2[];
        };
        correctMatchesAsync(points1: Point2[], points2: Point2[]): Promise<{
            newPoints1: Point2[];
            newPoints2: Point2[];
        }>;
        countNonZero(): number;
        countNonZeroAsync(): Promise<number>;
        cvtColor(code: number, dstCn?: number): Mat;
        cvtColorAsync(code: number, dstCn?: number): Promise<Mat>;
        dct(flags?: number): Mat;
        dctAsync(flags?: number): Promise<Mat>;
        decomposeEssentialMat(): {
            R1: Mat;
            R2: Mat;
            T: Vec3;
        };
        decomposeEssentialMatAsync(): Promise<{
            R1: Mat;
            R2: Mat;
            T: Vec3;
        }>;
        decomposeHomographyMat(K: Mat): {
            returnValue: number;
            rotations: Mat[];
            translations: Mat[];
            normals: Mat[];
        };
        decomposeHomographyMatAsync(K: Mat): Promise<{
            returnValue: number;
            rotations: Mat[];
            translations: Mat[];
            normals: Mat[];
        }>;
        decomposeProjectionMatrix(): {
            cameraMatrix: Mat;
            rotMatrix: Mat;
            transVect: Vec4;
            rotMatrixX: Mat;
            rotMatrixY: Mat;
            rotMatrixZ: Mat;
            eulerAngles: Mat;
        };
        decomposeProjectionMatrixAsync(): Promise<{
            cameraMatrix: Mat;
            rotMatrix: Mat;
            transVect: Vec4;
            rotMatrixX: Mat;
            rotMatrixY: Mat;
            rotMatrixZ: Mat;
            eulerAngles: Mat;
        }>;
        determinant(): number;
        dft(flags?: number, nonzeroRows?: number): Mat;
        dftAsync(flags?: number, nonzeroRows?: number): Promise<Mat>;
        dilate(kernel: Mat, anchor?: Point2, iterations?: number, borderType?: number): Mat;
        dilateAsync(kernel: Mat, anchor?: Point2, iterations?: number, borderType?: number): Promise<Mat>;
        distanceTransform(distanceType: number, maskSize: number, dstType?: number): Mat;
        distanceTransformAsync(distanceType: number, maskSize: number, dstType?: number): Promise<Mat>;
        distanceTransformWithLabels(distanceType: number, maskSize: number, labelType?: number): {
            labels: Mat;
            dist: Mat;
        };
        distanceTransformWithLabelsAsync(distanceType: number, maskSize: number, labelType?: number): Promise<{
            labels: Mat;
            dist: Mat;
        }>;
        div(s: number): Mat;
        dot(): Mat;
        drawArrowedLine(pt0: Point2, pt1: Point2, color?: Vec3, thickness?: number, lineType?: number, shift?: number, tipLength?: number): void;
        drawChessboardCorners(patternSize: Size, corners: Point2[], patternWasFound: boolean): void;
        drawChessboardCornersAsync(patternSize: Size, corners: Point2[], patternWasFound: boolean): Promise<void>;
        drawCircle(center: Point2, radius: number, color?: Vec3, thickness?: number, lineType?: number, shift?: number): void;
        drawContours(contours: Contour[], color: Vec3, contourIdx?: number, maxLevel?: number, offset?: Point2, lineType?: number, thickness?: number, shift?: number): void;
        drawEllipse(box: RotatedRect, color?: Vec3, thickness?: number, lineType?: number): void;
        drawEllipse(center: Point2, axes: Size, angle: number, startAngle: number, endAngle: number, color?: Vec3, thickness?: number, lineType?: number, shift?: number): void;
        drawFillConvexPoly(pts: Point2[], color?: Vec3, lineType?: number, shift?: number): void;
        drawFillPoly(pts: Point2[][], color?: Vec3, lineType?: number, shift?: number, offset?: Point2): void;
        drawLine(pt0: Point2, pt1: Point2, color?: Vec3, thickness?: number, lineType?: number, shift?: number): void;
        drawPolylines(pts: Point2[][], isClosed: boolean, color?: Vec3, thickness?: number, lineType?: number, shift?: number): void;
        drawRectangle(pt0: Point2, pt1: Point2, color?: Vec3, thickness?: number, lineType?: number, shift?: number): void;
        drawRectangle(rect: Rect, color?: Vec3, thickness?: number, lineType?: number, shift?: number): void;
        eigen(): Mat;
        eigenAsync(): Promise<Mat>;
        equalizeHist(): Mat;
        equalizeHistAsync(): Promise<Mat>;
        erode(kernel: Mat, anchor?: Point2, iterations?: number, borderType?: number): Mat;
        erodeAsync(kernel: Mat, anchor?: Point2, iterations?: number, borderType?: number): Promise<Mat>;
        exp(): Mat;
        log(): Mat;
        filter2D(ddepth: number, kernel: Mat, anchor?: Point2, delta?: number, borderType?: number): Mat;
        filter2DAsync(ddepth: number, kernel: Mat, anchor?: Point2, delta?: number, borderType?: number): Promise<Mat>;
        filterSpeckles(newVal: number, maxSpeckleSize: number, maxDiff: number): {
            newPoints1: Point2[];
            newPoints2: Point2[];
        };
        filterSpecklesAsync(newVal: number, maxSpeckleSize: number, maxDiff: number): Promise<{
            newPoints1: Point2[];
            newPoints2: Point2[];
        }>;
        find4QuadCornerSubpix(corners: Point2[], regionSize: Size): boolean;
        find4QuadCornerSubpixAsync(corners: Point2[], regionSize: Size): Promise<boolean>;
        findChessboardCorners(patternSize: Size, flags?: number): {
            returnValue: boolean;
            corners: Point2[];
        };
        findChessboardCornersAsync(patternSize: Size, flags?: number): Promise<{
            returnValue: boolean;
            corners: Point2[];
        }>;
        findContours(mode: number, method: number, offset?: Point2): Contour[];
        findContoursAsync(mode: number, method: number, offset?: Point2): Promise<Contour[]>;
        findEssentialMat(points1: Point2[], points2: Point2[], method?: number, prob?: number, threshold?: number): {
            E: Mat;
            mask: Mat;
        };
        findEssentialMatAsync(points1: Point2[], points2: Point2[], method?: number, prob?: number, threshold?: number): Promise<{
            E: Mat;
            mask: Mat;
        }>;
        findNonZero(): Point2[];
        findNonZeroAsync(): Promise<Point2[]>;
        flattenFloat(rows: number, cols: number): Mat;
        flip(flipCode: number): Mat;
        flipAsync(flipCode: number): Promise<Mat>;
        floodFill(seedPoint: Point2, newVal: number, mask?: Mat, loDiff?: number, upDiff?: number, flags?: number): {
            returnValue: number;
            rect: Rect;
        };
        floodFill(seedPoint: Point2, newVal: Vec3, mask?: Mat, loDiff?: Vec3, upDiff?: Vec3, flags?: number): {
            returnValue: number;
            rect: Rect;
        };
        floodFillAsync(seedPoint: Point2, newVal: number, mask?: Mat, loDiff?: number, upDiff?: number, flags?: number): Promise<{
            returnValue: number;
            rect: Rect;
        }>;
        floodFillAsync(seedPoint: Point2, newVal: Vec3, mask?: Mat, loDiff?: Vec3, upDiff?: Vec3, flags?: number): Promise<{
            returnValue: number;
            rect: Rect;
        }>;
        gaussianBlur(kSize: Size, sigmaX: number, sigmaY?: number, borderType?: number): Mat;
        gaussianBlurAsync(kSize: Size, sigmaX: number, sigmaY?: number, borderType?: number): Promise<Mat>;
        getData(): Buffer;
        getDataAsync(): Promise<Buffer>;
        getDataAsArray(): number[][];
        getDataAsArray(): number[][][];
        getDataAsArray(): number[][][];
        getDataAsArray(): number[][][];
        getOptimalNewCameraMatrix(distCoeffs: number[], imageSize: Size, alpha: number, newImageSize?: Size, centerPrincipalPoint?: boolean): {
            out: Mat;
            validPixROI: Rect;
        };
        getOptimalNewCameraMatrixAsync(distCoeffs: number[], imageSize: Size, alpha: number, newImageSize?: Size, centerPrincipalPoint?: boolean): Promise<{
            out: Mat;
            validPixROI: Rect;
        }>;
        getRegion(region: Rect): Mat;
        goodFeaturesToTrack(maxCorners: number, qualityLevel: number, minDistance: number, mask?: Mat, blockSize?: number, gradientSize?: number, useHarrisDetector?: boolean, harrisK?: number): Point2[];
        goodFeaturesToTrackAsync(maxCorners: number, qualityLevel: number, minDistance: number, mask?: Mat, blockSize?: number, gradientSize?: number, useHarrisDetector?: boolean, harrisK?: number): Promise<Point2[]>;
        grabCut(mask: Mat, rect: Rect, bgdModel: Mat, fgdModel: Mat, iterCount: number, mode: number): void;
        grabCutAsync(mask: Mat, rect: Rect, bgdModel: Mat, fgdModel: Mat, iterCount: number, mode: number): Promise<void>;
        guidedFilter(guide: Mat, radius: number, eps: number, ddepth?: number): Mat;
        guidedFilterAsync(guide: Mat, radius: number, eps: number, ddepth?: number): Promise<Mat>;
        hDiv(otherMat: Mat): Mat;
        hMul(otherMat: Mat): Mat;
        houghCircles(method: number, dp: number, minDist: number, param1?: number, param2?: number, minRadius?: number, maxRadius?: number): Vec3[];
        houghCirclesAsync(method: number, dp: number, minDist: number, param1?: number, param2?: number, minRadius?: number, maxRadius?: number): Promise<Vec3[]>;
        houghLines(rho: number, theta: number, threshold: number, srn?: number, stn?: number, min_theta?: number, max_theta?: number): Vec2[];
        houghLinesAsync(rho: number, theta: number, threshold: number, srn?: number, stn?: number, min_theta?: number, max_theta?: number): Promise<Vec2[]>;
        houghLinesP(rho: number, theta: number, threshold: number, minLineLength?: number, maxLineGap?: number): Vec4[];
        houghLinesPAsync(rho: number, theta: number, threshold: number, minLineLength?: number, maxLineGap?: number): Promise<Vec4[]>;
        idct(flags?: number): Mat;
        idctAsync(flags?: number): Promise<Mat>;
        idft(flags?: number, nonzeroRows?: number): Mat;
        idftAsync(flags?: number, nonzeroRows?: number): Promise<Mat>;
        inRange(lower: number, upper: number): Mat;
        inRange(lower: Vec3, upper: Vec3): Mat;
        inRangeAsync(lower: number, upper: number): Promise<Mat>;
        inRangeAsync(lower: Vec3, upper: Vec3): Promise<Mat>;
        integral(sdepth?: number, sqdepth?: number): {
            sum: Mat;
            sqsum: Mat;
            tilted: Mat;
        };
        integralAsync(sdepth?: number, sqdepth?: number): Promise<{
            sum: Mat;
            sqsum: Mat;
            tilted: Mat;
        }>;
        inv(): Mat;
        laplacian(ddepth: number, ksize?: number, scale?: number, delta?: number, borderType?: number): Mat;
        laplacianAsync(ddepth: number, ksize?: number, scale?: number, delta?: number, borderType?: number): Promise<Mat>;
        matMul(B: Mat): Mat;
        matMulDeriv(B: Mat): {
            dABdA: Mat;
            dABdB: Mat;
        };
        matMulDerivAsync(B: Mat): Promise<{
            dABdA: Mat;
            dABdB: Mat;
        }>;
        matchTemplate(template: Mat, method: number, mask?: Mat): Mat;
        matchTemplateAsync(template: Mat, method: number, mask?: Mat): Promise<Mat>;
        mean(): Vec4;
        meanAsync(): Promise<Vec4>;
        meanStdDev(mask?: Mat): {
            mean: Mat;
            stddev: Mat;
        };
        meanStdDevAsync(mask?: Mat): Promise<{
            mean: Mat;
            stddev: Mat;
        }>;
        medianBlur(kSize: number): Mat;
        medianBlurAsync(kSize: number): Promise<Mat>;
        minMaxLoc(mask?: Mat): {
            minVal: number;
            maxVal: number;
            minLoc: Point2;
            maxLoc: Point2;
        };
        minMaxLocAsync(mask?: Mat): Promise<{
            minVal: number;
            maxVal: number;
            minLoc: Point2;
            maxLoc: Point2;
        }>;
        moments(): Moments;
        momentsAsync(): Promise<Moments>;
        morphologyEx(kernel: Mat, morphType: number, anchor?: Point2, iterations?: number, borderType?: number): Mat;
        morphologyExAsync(kernel: Mat, morphType: number, anchor?: Point2, iterations?: number, borderType?: number): Promise<Mat>;
        mul(s: number): Mat;
        mulSpectrums(mat2: Mat, dftRows?: boolean, conjB?: boolean): Mat;
        mulSpectrumsAsync(mat2: Mat, dftRows?: boolean, conjB?: boolean): Promise<Mat>;
        norm(src2: Mat, normType?: number, mask?: Mat): number;
        norm(normType?: number, mask?: Mat): number;
        normalize(alpha?: number, beta?: number, normType?: number, dtype?: number, mask?: Mat): Mat;
        normalizeAsync(alpha?: number, beta?: number, normType?: number, dtype?: number, mask?: Mat): Promise<Mat>;
        or(otherMat: Mat): Mat;
        padToSquare(color: Vec3): Mat;
        perspectiveTransform(m: Mat): Mat;
        perspectiveTransformAsync(m: Mat): Promise<Mat>;
        pop_back(numRows?: number): Mat;
        pop_backAsync(numRows?: number): Promise<Mat>;
        popBack(numRows?: number): Mat;
        popBackAsync(numRows?: number): Promise<Mat>;
        push_back(mat: Mat): Mat;
        push_backAsync(mat: Mat): Promise<Mat>;
        pushBack(mat: Mat): Mat;
        pushBackAsync(mat: Mat): Promise<Mat>;
        putText(text: string, origin: Point2, fontFace: number, fontScale: number, color?: Vec3, thickness?: number, lineType?: number, bottomLeftOrigin?: boolean): void;
        putTextAsync(text: string, origin: Point2, fontFace: number, fontScale: number, color?: Vec3, thickness?: number, lineType?: number, bottomLeftOrigin?: boolean): Promise<void>;
        pyrDown(size?: Size, borderType?: number): Mat;
        pyrDownAsync(size?: Size, borderType?: number): Promise<Mat>;
        pyrUp(size?: Size, borderType?: number): Mat;
        pyrUpAsync(size?: Size, borderType?: number): Promise<Mat>;
        recoverPose(E: Mat, points1: Point2[], points2: Point2[], mask?: Mat): {
            returnValue: number;
            R: Mat;
            T: Vec3;
        };
        recoverPoseAsync(E: Mat, points1: Point2[], points2: Point2[], mask?: Mat): Promise<{
            returnValue: number;
            R: Mat;
            T: Vec3;
        }>;
        rectify3Collinear(distCoeffs1: number[], cameraMatrix2: Mat, distCoeffs2: number[], cameraMatrix3: Mat, distCoeffs3: number[], imageSize: Size, R12: Mat, T12: Vec3, R13: Mat, T13: Vec3, alpha: number, newImageSize: Size, flags: number): {
            returnValue: number;
            R1: Mat;
            R2: Mat;
            R3: Mat;
            P1: Mat;
            P2: Mat;
            P3: Mat;
            Q: Mat;
            roi1: Rect;
            roi2: Rect;
        };
        rectify3CollinearAsync(distCoeffs1: number[], cameraMatrix2: Mat, distCoeffs2: number[], cameraMatrix3: Mat, distCoeffs3: number[], imageSize: Size, R12: Mat, T12: Vec3, R13: Mat, T13: Vec3, alpha: number, newImageSize: Size, flags: number): Promise<{
            returnValue: number;
            R1: Mat;
            R2: Mat;
            R3: Mat;
            P1: Mat;
            P2: Mat;
            P3: Mat;
            Q: Mat;
            roi1: Rect;
            roi2: Rect;
        }>;
        reduce(dim: number, rtype: number, dtype?: number): Mat;
        reduceAsync(dim: number, rtype: number, dtype?: number): Promise<Mat>;
        reprojectImageTo3D(Q: Mat, handleMissingValues?: boolean, ddepth?: number): Mat;
        reprojectImageTo3DAsync(Q: Mat, handleMissingValues?: boolean, ddepth?: number): Promise<Mat>;
        rescale(factor: number): Mat;
        rescaleAsync(factor: number): Promise<Mat>;
        resize(rows: number, cols: number, fx?: number, fy?: number, interpolation?: number): Mat;
        resize(dsize: Size, fx?: number, fy?: number, interpolation?: number): Mat;
        resizeAsync(rows: number, cols: number, fx?: number, fy?: number, interpolation?: number): Promise<Mat>;
        resizeAsync(dsize: Size, fx?: number, fy?: number, interpolation?: number): Promise<Mat>;
        resizeToMax(maxRowsOrCols: number): Mat;
        resizeToMaxAsync(maxRowsOrCols: number): Promise<Mat>;
        rodrigues(): {
            dst: Mat;
            jacobian: Mat;
        };
        rodriguesAsync(): Promise<{
            dst: Mat;
            jacobian: Mat;
        }>;
        rotate(rotateCode: number): Mat;
        rotateAsync(rotateCode: number): Promise<Mat>;
        rqDecomp3x3(): {
            returnValue: Vec3;
            mtxR: Mat;
            mtxQ: Mat;
            Qx: Mat;
            Qy: Mat;
            Qz: Mat;
        };
        rqDecomp3x3Async(): Promise<{
            returnValue: Vec3;
            mtxR: Mat;
            mtxQ: Mat;
            Qx: Mat;
            Qy: Mat;
            Qz: Mat;
        }>;
        scharr(ddepth: number, dx: number, dy: number, scale?: number, delta?: number, borderType?: number): Mat;
        scharrAsync(ddepth: number, dx: number, dy: number, scale?: number, delta?: number, borderType?: number): Promise<Mat>;
        seamlessClone(dst: Mat, mask: Mat, p: Point2, flags: number): Mat;
        seamlessCloneAsync(dst: Mat, mask: Mat, p: Point2, flags: number): Promise<Mat>;
        sepFilter2D(ddepth: number, kernelX: Mat, kernelY: Mat, anchor?: Point2, delta?: number, borderType?: number): Mat;
        sepFilter2DAsync(ddepth: number, kernelX: Mat, kernelY: Mat, anchor?: Point2, delta?: number, borderType?: number): Promise<Mat>;
        set(row: number, col: number, value: number): void;
        set(row: number, col: number, value: number[]): void;
        set(row: number, col: number, value: number[]): void;
        set(row: number, col: number, value: number[]): void;
        set(row: number, col: number, value: Vec2): void;
        set(row: number, col: number, value: Vec3): void;
        set(row: number, col: number, value: Vec4): void;
        setTo(value: number, mask?: Mat): Mat;
        setTo(value: Vec2, mask?: Mat): Mat;
        setTo(value: Vec3, mask?: Mat): Mat;
        setTo(value: Vec4, mask?: Mat): Mat;
        setToAsync(value: number, mask?: Mat): Promise<Mat>;
        setToAsync(value: Vec2, mask?: Mat): Promise<Mat>;
        setToAsync(value: Vec3, mask?: Mat): Promise<Mat>;
        setToAsync(value: Vec4, mask?: Mat): Promise<Mat>;
        sobel(ddepth: number, dx: number, dy: number, ksize?: number, scale?: number, delta?: number, borderType?: number): Mat;
        sobelAsync(ddepth: number, dx: number, dy: number, ksize?: number, scale?: number, delta?: number, borderType?: number): Promise<Mat>;
        solve(mat2: Mat, flags?: number): Mat;
        solveAsync(mat2: Mat, flags?: number): Promise<Mat>;
        split(): Mat[];
        splitAsync(): Promise<Mat[]>;
        splitChannels(): Mat[];
        splitChannelsAsync(): Promise<Mat[]>;
        sqrBoxFilter(ddepth: number, ksize: Size, anchor?: Point2, normalize?: boolean, borderType?: number): Mat;
        sqrBoxFilterAsync(ddepth: number, ksize: Size, anchor?: Point2, normalize?: boolean, borderType?: number): Promise<Mat>;
        sqrt(): Mat;
        stereoRectify(distCoeffs1: number[], cameraMatrix2: Mat, distCoeffs2: number[], imageSize: Size, R: Mat, T: Vec3, flags?: number, alpha?: number, newImageSize?: Size): {
            R1: Mat;
            R2: Mat;
            P1: Mat;
            P2: Mat;
            Q: Mat;
            roi1: Rect;
            roi2: Rect;
        };
        stereoRectifyAsync(distCoeffs1: number[], cameraMatrix2: Mat, distCoeffs2: number[], imageSize: Size, R: Mat, T: Vec3, flags?: number, alpha?: number, newImageSize?: Size): Promise<{
            R1: Mat;
            R2: Mat;
            P1: Mat;
            P2: Mat;
            Q: Mat;
            roi1: Rect;
            roi2: Rect;
        }>;
        sub(otherMat: Mat): Mat;
        sum(): number;
        sum(): Vec2;
        sum(): Vec3;
        sum(): Vec4;
        sumAsync(): Promise<number>;
        sumAsync(): Promise<Vec2>;
        sumAsync(): Promise<Vec3>;
        sumAsync(): Promise<Vec4>;
        threshold(thresh: number, maxVal: number, type: number): Mat;
        thresholdAsync(thresh: number, maxVal: number, type: number): Promise<Mat>;
        transform(m: Mat): Mat;
        transformAsync(m: Mat): Promise<Mat>;
        transpose(): Mat;
        triangulatePoints(projPoints1: Point2[], projPoints2: Point2[]): Mat;
        triangulatePointsAsync(projPoints1: Point2[], projPoints2: Point2[]): Promise<Mat>;
        undistort(cameraMatrix: Mat, distCoeffs: Mat): Mat;
        undistortAsync(cameraMatrix: Mat, distCoeffs: Mat): Promise<Mat>;
        validateDisparity(cost: Mat, minDisparity: number, numberOfDisparities: number, disp12MaxDisp?: number): void;
        validateDisparityAsync(cost: Mat, minDisparity: number, numberOfDisparities: number, disp12MaxDisp?: number): Promise<void>;
        warpAffine(transforMationMatrix: Mat, size?: Size, flags?: number, borderMode?: number, borderValue?: Vec3): Mat;
        warpAffineAsync(transforMationMatrix: Mat, size?: Size, flags?: number, borderMode?: number, borderValue?: Vec3): Promise<Mat>;
        warpPerspective(transforMationMatrix: Mat, size?: Size, flags?: number, borderMode?: number, borderValue?: Vec3): Mat;
        warpPerspectiveAsync(transforMationMatrix: Mat, size?: Size, flags?: number, borderMode?: number, borderValue?: Vec3): Promise<Mat>;
        watershed(markers: Mat): Mat;
        watershedAsync(markers: Mat): Promise<Mat>;
        release(): void;
        static eye(rows: number, cols: number, type: number): Mat;
    }
}
declare module "@autojs/opencv" {
    import { Vec } from "@autojs/opencv";
    export class Vec6 extends Vec {
        readonly u: number;
        readonly v: number;
        readonly w: number;
        readonly x: number;
        readonly y: number;
        readonly z: number;
        constructor(u: number, v: number, w: number, x: number, y: number, z: number);
    }
}
declare module "@autojs/opencv" {
    import { Point2 } from "@autojs/opencv";
    export class KeyPoint {
        readonly pt: Point2;
        readonly size: number;
        readonly angle: number;
        readonly response: number;
        readonly octave: number;
        readonly class_id: number;
        readonly localId: number;
        constructor(point: Point2, size: number, angle: number, response: number, octave: number, class_id: number);
    }
}
declare module "@autojs/opencv" {
    export class DescriptorMatch {
        readonly queryIdx: number;
        readonly trainIdx: number;
        readonly distance: number;
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    export class OCRHMMClassifier {
        constructor(classifier: OCRHMMClassifier, vocabulary: string, transitionPropabilitiesTable: Mat, emissionPropabilitiesTable: Mat, mode?: number);
        eval(img: Mat): {
            classes: number[];
            confidences: number[];
        };
        evalAsync(img: Mat): Promise<{
            classes: number[];
            confidences: number[];
        }>;
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    export class Net {
        forward(inputName?: string): Mat;
        forward(outBlobNames?: string[]): Mat[];
        forwardAsync(inputName?: string): Promise<Mat>;
        forwardAsync(outBlobNames?: string[]): Promise<Mat[]>;
        setInput(blob: Mat, inputName?: string): void;
        setInputAsync(blob: Mat, inputName?: string): Promise<void>;
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    import { Size } from "@autojs/opencv";
    import { Vec2 } from "@autojs/opencv";
    import { Vec3 } from "@autojs/opencv";
    import { Vec4 } from "@autojs/opencv";
    import { Vec6 } from "@autojs/opencv";
    import { Point2 } from "@autojs/opencv";
    import { Point3 } from "@autojs/opencv";
    import { KeyPoint } from "@autojs/opencv";
    import { DescriptorMatch } from "@autojs/opencv";
    import { Rect } from "@autojs/opencv";
    import { TermCriteria } from "@autojs/opencv";
    import { OCRHMMClassifier } from "@autojs/opencv";
    import { Net } from "@autojs/opencv";
    export class HistAxes {
        channel: number;
        bins: number;
        ranges: number[];
        constructor(opts: {
            channel: number;
            bins: number;
            ranges: [number, number];
        });
    }
    export function accumulate(src: Mat, dst: Mat, mask?: Mat): void;
    export function accumulateAsync(src: Mat, dst: Mat, mask?: Mat): Promise<void>;
    export function accumulateProduct(src1: Mat, src2: Mat, dst: Mat, mask?: Mat): void;
    export function accumulateProductAsync(src1: Mat, src2: Mat, dst: Mat, mask?: Mat): Promise<void>;
    export function accumulateSquare(src: Mat, dst: Mat, mask?: Mat): void;
    export function accumulateSquareAsync(src: Mat, dst: Mat, mask?: Mat): Promise<void>;
    export function accumulateWeighted(src: Mat, dst: Mat, alpha: number, mask?: Mat): void;
    export function accumulateWeightedAsync(src: Mat, dst: Mat, alpha: number, mask?: Mat): Promise<void>;
    export function addWeighted(mat: Mat, alpha: number, mat2: Mat, beta: number, gamma: number, dtype?: number): Mat;
    export function addWeightedAsync(mat: Mat, alpha: number, mat2: Mat, beta: number, gamma: number, dtype?: number): Promise<Mat>;
    export function applyColorMap(src: Mat, colormap: number | Mat): Mat;
    export function blobFromImage(image: Mat, scaleFactor?: number, size?: Size, mean?: Vec3, swapRB?: boolean, crop?: boolean, ddepth?: number): Mat;
    export function blobFromImageAsync(image: Mat, scaleFactor?: number, size?: Size, mean?: Vec3, swapRB?: boolean, crop?: boolean, ddepth?: number): Promise<Mat>;
    export function blobFromImages(image: Mat[], scaleFactor?: number, size?: Size, mean?: Vec3, swapRB?: boolean, crop?: boolean, ddepth?: number): Mat;
    export function blobFromImagesAsync(image: Mat[], scaleFactor?: number, size?: Size, mean?: Vec3, swapRB?: boolean, crop?: boolean, ddepth?: number): Promise<Mat>;
    export function blur(mat: Mat, kSize: Size, anchor?: Point2, borderType?: number): Mat;
    export function blurAsync(mat: Mat, kSize: Size, anchor?: Point2, borderType?: number): Promise<Mat>;
    export function NMSBoxes(bboxes: Rect[], scores: number[], scoreThreshold: number, nmsThreshold: number): number[];
    /** @deprecated */
    export function calcHist(img: Mat, histAxes: {
        channel: number;
        bins: number;
        ranges: [number, number];
    }[], mask?: Mat): Mat;
    export function calcHist(img: Mat, histAxes: HistAxes[], mask?: Mat): Mat;
    export function calcHistAsync(img: Mat, histAxes: HistAxes[], mask?: Mat): Promise<Mat>;
    export function calibrateCamera(objectPoints: Point3[], imagePoints: Point2[], imageSize: Size, cameraMatrix: Mat, distCoeffs: number[], flags?: number, criteria?: TermCriteria): {
        returnValue: number;
        rvecs: Vec3[];
        tvecs: Vec3[];
        distCoeffs: number[];
    };
    export function calibrateCameraAsync(objectPoints: Point3[], imagePoints: Point2[], imageSize: Size, cameraMatrix: Mat, distCoeffs: number[], flags?: number, criteria?: TermCriteria): Promise<{
        returnValue: number;
        rvecs: Vec3[];
        tvecs: Vec3[];
        distCoeffs: number[];
    }>;
    export function calibrateCameraExtended(objectPoints: Point3[], imagePoints: Point2[], imageSize: Size, cameraMatrix: Mat, distCoeffs: number[], flags?: number, criteria?: TermCriteria): {
        returnValue: number;
        rvecs: Vec3[];
        tvecs: Vec3[];
        distCoeffs: number[];
        stdDeviationsIntrinsics: Mat;
        stdDeviationsExtrinsics: Mat;
        perViewErrors: number[];
    };
    export function calibrateCameraExtendedAsync(objectPoints: Point3[], imagePoints: Point2[], imageSize: Size, cameraMatrix: Mat, distCoeffs: number[], flags?: number, criteria?: TermCriteria): Promise<{
        returnValue: number;
        rvecs: Vec3[];
        tvecs: Vec3[];
        distCoeffs: number[];
        stdDeviationsIntrinsics: Mat;
        stdDeviationsExtrinsics: Mat;
        perViewErrors: number[];
    }>;
    export function canny(dx: Mat, dy: Mat, threshold1: number, threshold2: number, L2gradient?: boolean): Mat;
    export function cartToPolar(x: Mat, y: Mat, angleInDegrees?: boolean): {
        magnitude: Mat;
        angle: Mat;
    };
    export function cartToPolarAsync(x: Mat, y: Mat, angleInDegrees?: boolean): Promise<{
        magnitude: Mat;
        angle: Mat;
    }>;
    export function composeRT(rvec1: Vec3, tvec1: Vec3, rvec2: Vec3, tvec2: Vec3): {
        rvec3: Vec3;
        tvec3: Vec3;
        dr3dr1: Mat;
        dr3dt1: Mat;
        dr3dr2: Mat;
        dr3dt2: Mat;
        dt3dr1: Mat;
        dt3dt1: Mat;
        dt3dr2: Mat;
        dt3dt2: Mat;
    };
    export function composeRTAsync(rvec1: Vec3, tvec1: Vec3, rvec2: Vec3, tvec2: Vec3): Promise<{
        rvec3: Vec3;
        tvec3: Vec3;
        dr3dr1: Mat;
        dr3dt1: Mat;
        dr3dr2: Mat;
        dr3dt2: Mat;
        dt3dr1: Mat;
        dt3dt1: Mat;
        dt3dr2: Mat;
        dt3dt2: Mat;
    }>;
    export function computeCorrespondEpilines(points: Point2[], whichImage: number, F: Mat): Vec3[];
    export function computeCorrespondEpilinesAsync(points: Point2[], whichImage: number, F: Mat): Promise<Vec3[]>;
    export function convertScaleAbs(mat: Mat, alpha: number, beta: number): Mat;
    export function convertScaleAbsAsync(mat: Mat, alpha: number, beta: number): Promise<Mat>;
    export function countNonZero(mat: Mat): number;
    export function countNonZeroAsync(mat: Mat): Promise<number>;
    export function createOCRHMMTransitionsTable(vocabulary: string, lexicon: string[]): Mat;
    export function createOCRHMMTransitionsTableAsync(vocabulary: string, lexicon: string[]): Promise<Mat>;
    export function destroyAllWindows(): void;
    export function destroyWindow(winName: string): void;
    export function drawKeyPoints(img: Mat, keyPoints: KeyPoint[]): Mat;
    export function drawMatches(img1: Mat, img2: Mat, keyPoints1: KeyPoint[], keyPoints2: KeyPoint[], matches: DescriptorMatch[]): Mat;
    export function eigen(mat: Mat): Mat;
    export function eigenAsync(mat: Mat): Promise<Mat>;
    export function estimateAffine2D(from: Point2[], to: Point2[], method?: number, ransacReprojThreshold?: number, maxIters?: number, confidence?: number, refineIters?: number): {
        out: Mat;
        inliers: Mat;
    };
    export function estimateAffine2DAsync(from: Point2[], to: Point2[], method?: number, ransacReprojThreshold?: number, maxIters?: number, confidence?: number, refineIters?: number): Promise<{
        out: Mat;
        inliers: Mat;
    }>;
    export function estimateAffine3D(src: Point3[], dst: Point3[], ransacThreshold?: number, confidence?: number): {
        returnValue: number;
        out: Mat;
        inliers: Mat;
    };
    export function estimateAffine3D(from: Point2[], to: Point2[], method?: number, ransacReprojThreshold?: number, maxIters?: number, confidence?: number, refineIters?: number): {
        out: Mat;
        inliers: Mat;
    };
    export function estimateAffine3DAsync(src: Point3[], dst: Point3[], ransacThreshold?: number, confidence?: number): Promise<{
        returnValue: number;
        out: Mat;
        inliers: Mat;
    }>;
    export function estimateAffine3DAsync(from: Point2[], to: Point2[], method?: number, ransacReprojThreshold?: number, maxIters?: number, confidence?: number, refineIters?: number): Promise<{
        out: Mat;
        inliers: Mat;
    }>;
    export function estimateAffinePartial2D(from: Point2[], to: Point2[], method?: number, ransacReprojThreshold?: number, maxIters?: number, confidence?: number, refineIters?: number): {
        out: Mat;
        inliers: Mat;
    };
    export function estimateAffinePartial2DAsync(from: Point2[], to: Point2[], method?: number, ransacReprojThreshold?: number, maxIters?: number, confidence?: number, refineIters?: number): Promise<{
        out: Mat;
        inliers: Mat;
    }>;
    export function fastNlMeansDenoisingColored(src: Mat, h?: number, hColor?: number, templateWindowSize?: number, searchWindowSize?: number): Mat;
    export function inpaint(src: Mat, mask: Mat, inpaintRadius: number, flags: number): Mat;
    export function inpaintAsync(src: Mat, mask: Mat, inpaintRadius: number, flags: number): Promise<Mat>;
    export function findEssentialMat(points1: Point2[], points2: Point2[], focal?: number, pp?: Point2, method?: number, prob?: number, threshold?: number): {
        E: Mat;
        mask: Mat;
    };
    export function findEssentialMatAsync(points1: Point2[], points2: Point2[], focal?: number, pp?: Point2, method?: number, prob?: number, threshold?: number): Promise<{
        E: Mat;
        mask: Mat;
    }>;
    export function findFundamentalMat(points1: Point2[], points2: Point2[], method?: number, param1?: number, param2?: number): {
        F: Mat;
        mask: Mat;
    };
    export function findFundamentalMatAsync(points1: Point2[], points2: Point2[], method?: number, param1?: number, param2?: number): Promise<{
        F: Mat;
        mask: Mat;
    }>;
    export function findHomography(srcPoints: Point2[], dstPoints: Point2[], method?: number, ransacReprojThreshold?: number, maxIters?: number, confidence?: number): {
        homography: Mat;
        mask: Mat;
    };
    export function findNonZero(mat: Mat): Point2[];
    export function findNonZeroAsync(mat: Mat): Promise<Point2[]>;
    export function fitLine(points: Point2[], distType: number, param: number, reps: number, aeps: number): number[];
    export function fitLine(points: Point3[], distType: number, param: number, reps: number, aeps: number): number[];
    export function gaussianBlur(mat: Mat, kSize: Size, sigmaX: number, sigmaY?: number, borderType?: number): Mat;
    export function gaussianBlurAsync(mat: Mat, kSize: Size, sigmaX: number, sigmaY?: number, borderType?: number): Promise<Mat>;
    export function getAffineTransform(srcPoints: Point2[], dstPoints: Point2[]): Mat;
    export function getBuildInformation(): string;
    export function getPerspectiveTransform(srcPoints: Point2[], dstPoints: Point2[]): Mat;
    export function getRotationMatrix2D(center: Point2, angle: number, scale?: number): Mat;
    export function getStructuringElement(shape: number, kernelSize: Size, anchor?: Point2): Mat;
    export function getTextSize(text: string, fontFace: number, fontScale: number, thickness: number): {
        size: Size;
        baseLine: number;
    };
    export function getTextSizeAsync(text: string, fontFace: number, fontScale: number, thickness: number): Promise<{
        size: Size;
        baseLine: number;
    }>;
    export function getValidDisparityROI(roi1: Rect[], roi2: Rect[], minDisparity: number, numberOfDisparities: number, SADWindowSize: number): Rect;
    export function getValidDisparityROIAsync(roi1: Rect[], roi2: Rect[], minDisparity: number, numberOfDisparities: number, SADWindowSize: number): Promise<Rect>;
    export function goodFeaturesToTrack(mat: Mat, maxCorners: number, qualityLevel: number, minDistance: number, mask?: Mat, blockSize?: number, gradientSize?: number, useHarrisDetector?: boolean, harrisK?: number): Point2[];
    export function goodFeaturesToTrackAsync(mat: Mat, maxCorners: number, qualityLevel: number, minDistance: number, mask?: Mat, blockSize?: number, gradientSize?: number, useHarrisDetector?: boolean, harrisK?: number): Promise<Point2[]>;
    export function imdecode(buffer: Buffer, flags?: number): Mat;
    export function imdecodeAsync(buffer: Buffer, flags?: number): Promise<Mat>;
    export function imencode(fileExt: string, img: Mat, flags?: number[]): Buffer;
    export function imencodeAsync(fileExt: string, img: Mat, flags?: number[]): Promise<Buffer>;
    export function imread(filePath: string, flags?: number): Mat;
    export function imreadAsync(filePath: string, flags?: number): Promise<Mat>;
    export function imshow(winName: string, img: Mat): void;
    export function imshowWait(winName: string, img: Mat): void;
    export function imwrite(filePath: string, img: Mat, flags?: number[]): void;
    export function imwriteAsync(filePath: string, img: Mat, flags?: number[]): Promise<void>;
    export function initCameraMatrix2D(objectPoints: Point3[], imagePoints: Point2[], imageSize: Size, aspectRatio?: number): Mat;
    export function initCameraMatrix2DAsync(objectPoints: Point3[], imagePoints: Point2[], imageSize: Size, aspectRatio?: number): Promise<Mat>;
    export function kmeans(data: Point2[], k: number, attempts: number, termCriteria: TermCriteria, flags: number): {
        labels: number[];
        centers: Point2[];
    };
    export function kmeans(data: Point3[], k: number, attempts: number, termCriteria: TermCriteria, flags: number): {
        labels: number[];
        centers: Point3[];
    };
    export function loadOCRHMMClassifierCNN(file: string): OCRHMMClassifier;
    export function loadOCRHMMClassifierCNNAsync(file: string): Promise<OCRHMMClassifier>;
    export function loadOCRHMMClassifierNM(file: string): OCRHMMClassifier;
    export function loadOCRHMMClassifierNMAsync(file: string): Promise<OCRHMMClassifier>;
    export function matchBruteForce(descriptors1: Mat, descriptors2: Mat): DescriptorMatch[];
    export function matchBruteForceAsync(descriptors1: Mat, descriptors2: Mat): Promise<DescriptorMatch[]>;
    export function matchBruteForceHamming(descriptors1: Mat, descriptors2: Mat): DescriptorMatch[];
    export function matchBruteForceHammingAsync(descriptors1: Mat, descriptors2: Mat): Promise<DescriptorMatch[]>;
    export function matchBruteForceHammingLut(descriptors1: Mat, descriptors2: Mat): DescriptorMatch[];
    export function matchBruteForceHammingLutAsync(descriptors1: Mat, descriptors2: Mat): Promise<DescriptorMatch[]>;
    export function matchBruteForceL1(descriptors1: Mat, descriptors2: Mat): DescriptorMatch[];
    export function matchBruteForceL1Async(descriptors1: Mat, descriptors2: Mat): Promise<DescriptorMatch[]>;
    export function matchBruteForceSL2(descriptors1: Mat, descriptors2: Mat): DescriptorMatch[];
    export function matchBruteForceSL2Async(descriptors1: Mat, descriptors2: Mat): Promise<DescriptorMatch[]>;
    export function matchFlannBased(descriptors1: Mat, descriptors2: Mat): DescriptorMatch[];
    export function matchFlannBasedAsync(descriptors1: Mat, descriptors2: Mat): Promise<DescriptorMatch[]>;
    export function matchKnnBruteForce(descriptors1: Mat, descriptors2: Mat, k: number): DescriptorMatch[][];
    export function matchKnnBruteForceAsync(descriptors1: Mat, descriptors2: Mat, k: number): Promise<DescriptorMatch[][]>;
    export function matchKnnBruteForceHamming(descriptors1: Mat, descriptors2: Mat, k: number): DescriptorMatch[][];
    export function matchKnnBruteForceHammingAsync(descriptors1: Mat, descriptors2: Mat, k: number): Promise<DescriptorMatch[][]>;
    export function matchKnnBruteForceHammingLut(descriptors1: Mat, descriptors2: Mat, k: number): DescriptorMatch[][];
    export function matchKnnBruteForceHammingLutAsync(descriptors1: Mat, descriptors2: Mat, k: number): Promise<DescriptorMatch[][]>;
    export function matchKnnBruteForceL1(descriptors1: Mat, descriptors2: Mat, k: number): DescriptorMatch[][];
    export function matchKnnBruteForceL1Async(descriptors1: Mat, descriptors2: Mat, k: number): Promise<DescriptorMatch[][]>;
    export function matchKnnBruteForceSL2(descriptors1: Mat, descriptors2: Mat, k: number): DescriptorMatch[][];
    export function matchKnnBruteForceSL2Async(descriptors1: Mat, descriptors2: Mat, k: number): Promise<DescriptorMatch[][]>;
    export function matchKnnFlannBased(descriptors1: Mat, descriptors2: Mat, k: number): DescriptorMatch[][];
    export function matchKnnFlannBasedAsync(descriptors1: Mat, descriptors2: Mat, k: number): Promise<DescriptorMatch[][]>;
    export function mean(mat: Mat): Vec4;
    export function meanAsync(mat: Mat): Promise<Vec4>;
    export function meanStdDev(mat: Mat, mask?: Mat): {
        mean: Mat;
        stddev: Mat;
    };
    export function meanStdDevAsync(mat: Mat, mask?: Mat): Promise<{
        mean: Mat;
        stddev: Mat;
    }>;
    export function medianBlur(mat: Mat, kSize: number): Mat;
    export function medianBlurAsync(mat: Mat, kSize: number): Promise<Mat>;
    export function minMaxLoc(mat: Mat, mask?: Mat): {
        minVal: number;
        maxVal: number;
        minLoc: Point2;
        maxLoc: Point2;
    };
    export function minMaxLocAsync(mat: Mat, mask?: Mat): Promise<{
        minVal: number;
        maxVal: number;
        minLoc: Point2;
        maxLoc: Point2;
    }>;
    export function moveWindow(winName: string, x: number, y: number): void;
    export function mulSpectrums(mat: Mat, mat2: Mat, dftRows?: boolean, conjB?: boolean): Mat;
    export function mulSpectrumsAsync(mat: Mat, mat2: Mat, dftRows?: boolean, conjB?: boolean): Promise<Mat>;
    export function partition(data: Point2[], predicate: (pt1: Point2, pt2: Point2) => boolean): {
        labels: number[];
        numLabels: number;
    };
    export function partition(data: Point3[], predicate: (pt1: Point3, pt2: Point3) => boolean): {
        labels: number[];
        numLabels: number;
    };
    export function partition(data: Vec2[], predicate: (vec1: Vec2, vec2: Vec2) => boolean): {
        labels: number[];
        numLabels: number;
    };
    export function partition(data: Vec3[], predicate: (vec1: Vec3, vec2: Vec3) => boolean): {
        labels: number[];
        numLabels: number;
    };
    export function partition(data: Vec4[], predicate: (vec1: Vec4, vec2: Vec4) => boolean): {
        labels: number[];
        numLabels: number;
    };
    export function partition(data: Vec6[], predicate: (vec1: Vec6, vec2: Vec6) => boolean): {
        labels: number[];
        numLabels: number;
    };
    export function partition(data: Mat[], predicate: (mat1: Mat, mat2: Mat) => boolean): {
        labels: number[];
        numLabels: number;
    };
    export function perspectiveTransform(mat: Mat, m: Mat): Mat;
    export function perspectiveTransformAsync(mat: Mat, m: Mat): Promise<Mat>;
    export function plot1DHist(hist: Mat, plotImg: Mat, color: Vec3, lineType?: number, thickness?: number, shift?: number): Mat;
    export function polarToCart(magnitude: Mat, angle: Mat, angleInDegrees?: boolean): {
        x: Mat;
        y: Mat;
    };
    export function polarToCartAsync(magnitude: Mat, angle: Mat, angleInDegrees?: boolean): Promise<{
        x: Mat;
        y: Mat;
    }>;
    export function getNumThreads(): number;
    export function setNumThreads(nthreads: number): void;
    export function getThreadNum(): number;
    export function projectPoints(objectPoints: Point3[], imagePoints: Point2[], rvec: Vec3, tvec: Vec3, cameraMatrix: Mat, distCoeffs: number[], aspectRatio?: number): {
        imagePoints: Point2[];
        jacobian: Mat;
    };
    export function projectPointsAsync(objectPoints: Point3[], imagePoints: Point2[], rvec: Vec3, tvec: Vec3, cameraMatrix: Mat, distCoeffs: number[], aspectRatio?: number): Promise<{
        imagePoints: Point2[];
        jacobian: Mat;
    }>;
    export function readNetFromCaffe(prototxt: string, modelPath?: string): Net;
    export function readNetFromCaffeAsync(prototxt: string, modelPath?: string): Promise<Net>;
    export function readNetFromTensorflow(modelPath: string): Net;
    export function readNetFromTensorflowAsync(modelPath: string): Promise<Net>;
    export function recoverPose(E: Mat, points1: Point2[], points2: Point2[], focal?: number, pp?: Point2, mask?: Mat): {
        returnValue: number;
        R: Mat;
        T: Vec3;
    };
    export function recoverPoseAsync(E: Mat, points1: Point2[], points2: Point2[], focal?: number, pp?: Point2, mask?: Mat): Promise<{
        returnValue: number;
        R: Mat;
        T: Vec3;
    }>;
    export function reduce(mat: Mat, dim: number, rtype: number, dtype?: number): Mat;
    export function reduceAsync(mat: Mat, dim: number, rtype: number, dtype?: number): Promise<Mat>;
    export function sampsonDistance(pt1: Vec2, pt2: Vec2, F: Mat): number;
    export function sampsonDistanceAsync(pt1: Vec2, pt2: Vec2, F: Mat): Promise<number>;
    export function seamlessClone(src: Mat, dst: Mat, mask: Mat, p: Point2, flags: number): Mat;
    export function seamlessCloneAsync(src: Mat, dst: Mat, mask: Mat, p: Point2, flags: number): Promise<Mat>;
    export function solve(mat: Mat, mat2: Mat, flags?: number): Mat;
    export function solveAsync(mat: Mat, mat2: Mat, flags?: number): Promise<Mat>;
    export function solveP3P(objectPoints: Point3[], imagePoints: Point2[], cameraMatrix: Mat, distCoeffs: number[], flags?: number): {
        returnValue: boolean;
        rvecs: Mat[];
        tvecs: Mat[];
    };
    export function solveP3PAsync(objectPoints: Point3[], imagePoints: Point2[], cameraMatrix: Mat, distCoeffs: number[], flags?: number): Promise<{
        returnValue: boolean;
        rvecs: Mat[];
        tvecs: Mat[];
    }>;
    export function solvePnP(objectPoints: Point3[], imagePoints: Point2[], cameraMatrix: Mat, distCoeffs: number[], useExtrinsicGuess?: boolean, flags?: number): {
        returnValue: boolean;
        rvec: Vec3;
        tvec: Vec3;
    };
    export function solvePnP(objectPoints: Point3[], imagePoints: Point2[], cameraMatrix: Mat, distCoeffs: number[], useExtrinsicGuess?: boolean, iterationsCount?: number, reprojectionError?: number, confidence?: number, flags?: number): {
        returnValue: boolean;
        rvec: Vec3;
        tvec: Vec3;
        inliers: number[];
    };
    export function solvePnPAsync(objectPoints: Point3[], imagePoints: Point2[], cameraMatrix: Mat, distCoeffs: number[], useExtrinsicGuess?: boolean, flags?: number): Promise<{
        returnValue: boolean;
        rvec: Vec3;
        tvec: Vec3;
    }>;
    export function solvePnPAsync(objectPoints: Point3[], imagePoints: Point2[], cameraMatrix: Mat, distCoeffs: number[], useExtrinsicGuess?: boolean, iterationsCount?: number, reprojectionError?: number, confidence?: number, flags?: number): Promise<{
        returnValue: boolean;
        rvec: Vec3;
        tvec: Vec3;
        inliers: number[];
    }>;
    export function split(mat: Mat): Mat[];
    export function splitAsync(mat: Mat): Promise<Mat[]>;
    export function stereoCalibrate(objectPoints: Point3[], imagePoints1: Point2[], imagePoints2: Point2[], cameraMatrix1: Mat, distCoeffs1: number[], cameraMatrix2: Mat, distCoeffs2: number[], imageSize: Size, flags?: number, criteria?: TermCriteria): {
        returnValue: number;
        R: Mat;
        T: Vec3[];
        E: Mat;
        F: Mat;
        distCoeffs1: number[];
        distCoeffs2: number[];
    };
    export function stereoCalibrateAsync(objectPoints: Point3[], imagePoints1: Point2[], imagePoints2: Point2[], cameraMatrix1: Mat, distCoeffs1: number[], cameraMatrix2: Mat, distCoeffs2: number[], imageSize: Size, flags?: number, criteria?: TermCriteria): Promise<{
        returnValue: number;
        R: Mat;
        T: Vec3[];
        E: Mat;
        F: Mat;
        distCoeffs1: number[];
        distCoeffs2: number[];
    }>;
    export function stereoRectifyUncalibrated(points1: Point2[], points2: Point2[], F: Mat, imageSize: Size, threshold?: number): {
        returnValue: boolean;
        H1: Mat;
        H2: Mat;
    };
    export function stereoRectifyUncalibratedAsync(points1: Point2[], points2: Point2[], F: Mat, imageSize: Size, threshold?: number): Promise<{
        returnValue: boolean;
        H1: Mat;
        H2: Mat;
    }>;
    export function sum(mat: Mat): number;
    export function sum(mat: Mat): Vec2;
    export function sum(mat: Mat): Vec3;
    export function sum(mat: Mat): Vec4;
    export function sumAsync(mat: Mat): Promise<number>;
    export function sumAsync(mat: Mat): Promise<Vec2>;
    export function sumAsync(mat: Mat): Promise<Vec3>;
    export function sumAsync(mat: Mat): Promise<Vec4>;
    export function transform(mat: Mat, m: Mat): Mat;
    export function transformAsync(mat: Mat, m: Mat): Promise<Mat>;
    export function undistortPoints(srcPoints: Point2[], cameraMatrix: Mat, distCoeffs: Mat): Point2[];
    export function undistortPointsAsync(srcPoints: Point2[], cameraMatrix: Mat, distCoeffs: Mat): Promise<Point2[]>;
    export function waitKey(delay?: number): number;
    export function waitKeyEx(delay?: number): number;
    export type DrawParams = {
        thickness?: number;
        lineType?: number;
        color?: Vec3;
    };
    export interface DrawDetectionParams extends DrawParams {
        segmentFraction?: number;
    }
    export interface FontParams extends DrawParams {
        fontType?: number;
        fontSize?: number;
    }
    export interface TextLine extends FontParams {
        text: string;
    }
    export function drawDetection(img: Mat, inputRect: Rect, opts?: DrawDetectionParams): Rect;
    export function drawTextBox(img: Mat, upperLeft: {
        x: number;
        y: number;
    }, textLines: TextLine[], alpha: number): Mat;
    export function isCustomMatAllocatorEnabled(): boolean;
    export function dangerousEnableCustomMatAllocator(): boolean;
    export function dangerousDisableCustomMatAllocator(): boolean;
    export function getMemMetrics(): {
        TotalAlloc: number;
        TotalKnownByJS: number;
        NumAllocations: number;
        NumDeAllocations: number;
    };
}
declare module "@autojs/opencv" {
    export const CV_8U: number;
    export const CV_8S: number;
    export const CV_16U: number;
    export const CV_16S: number;
    export const CV_32S: number;
    export const CV_32F: number;
    export const CV_64F: number;
    export const CV_8UC1: number;
    export const CV_8UC2: number;
    export const CV_8UC3: number;
    export const CV_8UC4: number;
    export const CV_8SC1: number;
    export const CV_8SC2: number;
    export const CV_8SC3: number;
    export const CV_8SC4: number;
    export const CV_16UC1: number;
    export const CV_16UC2: number;
    export const CV_16UC3: number;
    export const CV_16UC4: number;
    export const CV_16SC1: number;
    export const CV_16SC2: number;
    export const CV_16SC3: number;
    export const CV_16SC4: number;
    export const CV_32SC1: number;
    export const CV_32SC2: number;
    export const CV_32SC3: number;
    export const CV_32SC4: number;
    export const CV_32FC1: number;
    export const CV_32FC2: number;
    export const CV_32FC3: number;
    export const CV_32FC4: number;
    export const CV_64FC1: number;
    export const CV_64FC2: number;
    export const CV_64FC3: number;
    export const CV_64FC4: number;
    export const ADAPTIVE_THRESH_GAUSSIAN_C: number;
    export const ADAPTIVE_THRESH_MEAN_C: number;
    export const BORDER_CONSTANT: number;
    export const BORDER_DEFAULT: number;
    export const BORDER_ISOLATED: number;
    export const BORDER_REFLECT: number;
    export const BORDER_REFLECT_101: number;
    export const BORDER_REPLICATE: number;
    export const BORDER_TRANSPARENT: number;
    export const BORDER_WRAP: number;
    export const CALIB_CB_ADAPTIVE_THRESH: number;
    export const CALIB_CB_ASYMMETRIC_GRID: number;
    export const CALIB_CB_CLUSTERING: number;
    export const CALIB_CB_FAST_CHECK: number;
    export const CALIB_CB_FILTER_QUADS: number;
    export const CALIB_CB_NORMALIZE_IMAGE: number;
    export const CALIB_CB_SYMMETRIC_GRID: number;
    export const CALIB_FIX_ASPECT_RATIO: number;
    export const CALIB_FIX_FOCAL_LENGTH: number;
    export const CALIB_FIX_INTRINSIC: number;
    export const CALIB_FIX_K1: number;
    export const CALIB_FIX_K2: number;
    export const CALIB_FIX_K3: number;
    export const CALIB_FIX_K4: number;
    export const CALIB_FIX_K5: number;
    export const CALIB_FIX_K6: number;
    export const CALIB_FIX_PRINCIPAL_POINT: number;
    export const CALIB_FIX_S1_S2_S3_S4: number;
    export const CALIB_FIX_TANGENT_DIST: number;
    export const CALIB_FIX_TAUX_TAUY: number;
    export const CALIB_RATIONAL_MODEL: number;
    export const CALIB_SAME_FOCAL_LENGTH: number;
    export const CALIB_THIN_PRISM_MODEL: number;
    export const CALIB_TILTED_MODEL: number;
    export const CALIB_USE_INTRINSIC_GUESS: number;
    export const CALIB_USE_LU: number;
    export const CALIB_USE_QR: number;
    export const CALIB_ZERO_DISPARITY: number;
    export const CALIB_ZERO_TANGENT_DIST: number;
    export const CAP_ANDROID: number;
    export const CAP_ANY: number;
    export const CAP_ARAVIS: number;
    export const CAP_AVFOUNDATION: number;
    export const CAP_CMU1394: number;
    export const CAP_DC1394: number;
    export const CAP_DSHOW: number;
    export const CAP_FFMPEG: number;
    export const CAP_FIREWIRE: number;
    export const CAP_GIGANETIX: number;
    export const CAP_GPHOTO2: number;
    export const CAP_GSTREAMER: number;
    export const CAP_IEEE1394: number;
    export const CAP_IMAGES: number;
    export const CAP_INTELPERC: number;
    export const CAP_MODE_BGR: number;
    export const CAP_MODE_GRAY: number;
    export const CAP_MODE_RGB: number;
    export const CAP_MODE_YUYV: number;
    export const CAP_MSMF: number;
    export const CAP_OPENNI: number;
    export const CAP_OPENNI2: number;
    export const CAP_OPENNI2_ASUS: number;
    export const CAP_OPENNI_ASUS: number;
    export const CAP_PROP_AUTOFOCUS: number;
    export const CAP_PROP_AUTO_EXPOSURE: number;
    export const CAP_PROP_BACKLIGHT: number;
    export const CAP_PROP_BRIGHTNESS: number;
    export const CAP_PROP_BUFFERSIZE: number;
    export const CAP_PROP_CONTRAST: number;
    export const CAP_PROP_CONVERT_RGB: number;
    export const CAP_PROP_EXPOSURE: number;
    export const CAP_PROP_FOCUS: number;
    export const CAP_PROP_FORMAT: number;
    export const CAP_PROP_FOURCC: number;
    export const CAP_PROP_FPS: number;
    export const CAP_PROP_FRAME_COUNT: number;
    export const CAP_PROP_FRAME_HEIGHT: number;
    export const CAP_PROP_FRAME_WIDTH: number;
    export const CAP_PROP_GAIN: number;
    export const CAP_PROP_GAMMA: number;
    export const CAP_PROP_GUID: number;
    export const CAP_PROP_HUE: number;
    export const CAP_PROP_IRIS: number;
    export const CAP_PROP_ISO_SPEED: number;
    export const CAP_PROP_MODE: number;
    export const CAP_PROP_MONOCHROME: number;
    export const CAP_PROP_PAN: number;
    export const CAP_PROP_POS_AVI_RATIO: number;
    export const CAP_PROP_POS_FRAMES: number;
    export const CAP_PROP_POS_MSEC: number;
    export const CAP_PROP_RECTIFICATION: number;
    export const CAP_PROP_ROLL: number;
    export const CAP_PROP_SATURATION: number;
    export const CAP_PROP_SETTINGS: number;
    export const CAP_PROP_SHARPNESS: number;
    export const CAP_PROP_TEMPERATURE: number;
    export const CAP_PROP_TILT: number;
    export const CAP_PROP_TRIGGER: number;
    export const CAP_PROP_TRIGGER_DELAY: number;
    export const CAP_PROP_WHITE_BALANCE_BLUE_U: number;
    export const CAP_PROP_WHITE_BALANCE_RED_V: number;
    export const CAP_PROP_ZOOM: number;
    export const CAP_PVAPI: number;
    export const CAP_QT: number;
    export const CAP_UNICAP: number;
    export const CAP_V4L: number;
    export const CAP_V4L2: number;
    export const CAP_VFW: number;
    export const CAP_WINRT: number;
    export const CAP_XIAPI: number;
    export const CC_STAT_AREA: number;
    export const CC_STAT_HEIGHT: number;
    export const CC_STAT_LEFT: number;
    export const CC_STAT_MAX: number;
    export const CC_STAT_TOP: number;
    export const CC_STAT_WIDTH: number;
    export const CHAIN_APPROX_NONE: number;
    export const CHAIN_APPROX_SIMPLE: number;
    export const CHAIN_APPROX_TC89_KCOS: number;
    export const CHAIN_APPROX_TC89_L1: number;
    export const COLOR_BGR2BGR555: number;
    export const COLOR_BGR2BGR565: number;
    export const COLOR_BGR2BGRA: number;
    export const COLOR_BGR2GRAY: number;
    export const COLOR_BGR2HLS: number;
    export const COLOR_BGR2HLS_FULL: number;
    export const COLOR_BGR2HSV: number;
    export const COLOR_BGR2HSV_FULL: number;
    export const COLOR_BGR2Lab: number;
    export const COLOR_BGR2Luv: number;
    export const COLOR_BGR2RGB: number;
    export const COLOR_BGR2RGBA: number;
    export const COLOR_BGR2XYZ: number;
    export const COLOR_BGR2YCrCb: number;
    export const COLOR_BGR2YUV: number;
    export const COLOR_BGR2YUV_I420: number;
    export const COLOR_BGR2YUV_IYUV: number;
    export const COLOR_BGR2YUV_YV12: number;
    export const COLOR_BGR5552BGR: number;
    export const COLOR_BGR5552BGRA: number;
    export const COLOR_BGR5552GRAY: number;
    export const COLOR_BGR5552RGB: number;
    export const COLOR_BGR5552RGBA: number;
    export const COLOR_BGR5652BGR: number;
    export const COLOR_BGR5652BGRA: number;
    export const COLOR_BGR5652GRAY: number;
    export const COLOR_BGR5652RGB: number;
    export const COLOR_BGR5652RGBA: number;
    export const COLOR_BGRA2BGR: number;
    export const COLOR_BGRA2BGR555: number;
    export const COLOR_BGRA2BGR565: number;
    export const COLOR_BGRA2GRAY: number;
    export const COLOR_BGRA2RGB: number;
    export const COLOR_BGRA2RGBA: number;
    export const COLOR_BGRA2YUV_I420: number;
    export const COLOR_BGRA2YUV_IYUV: number;
    export const COLOR_BGRA2YUV_YV12: number;
    export const COLOR_BayerBG2BGR: number;
    export const COLOR_BayerBG2BGR_EA: number;
    export const COLOR_BayerBG2BGR_VNG: number;
    export const COLOR_BayerBG2GRAY: number;
    export const COLOR_BayerBG2RGB: number;
    export const COLOR_BayerBG2RGB_EA: number;
    export const COLOR_BayerBG2RGB_VNG: number;
    export const COLOR_BayerGB2BGR: number;
    export const COLOR_BayerGB2BGR_EA: number;
    export const COLOR_BayerGB2BGR_VNG: number;
    export const COLOR_BayerGB2GRAY: number;
    export const COLOR_BayerGB2RGB: number;
    export const COLOR_BayerGB2RGB_EA: number;
    export const COLOR_BayerGB2RGB_VNG: number;
    export const COLOR_BayerGR2BGR: number;
    export const COLOR_BayerGR2BGR_EA: number;
    export const COLOR_BayerGR2BGR_VNG: number;
    export const COLOR_BayerGR2GRAY: number;
    export const COLOR_BayerGR2RGB: number;
    export const COLOR_BayerGR2RGB_EA: number;
    export const COLOR_BayerGR2RGB_VNG: number;
    export const COLOR_BayerRG2BGR: number;
    export const COLOR_BayerRG2BGR_EA: number;
    export const COLOR_BayerRG2BGR_VNG: number;
    export const COLOR_BayerRG2GRAY: number;
    export const COLOR_BayerRG2RGB: number;
    export const COLOR_BayerRG2RGB_EA: number;
    export const COLOR_BayerRG2RGB_VNG: number;
    export const COLOR_COLORCVT_MAX: number;
    export const COLOR_GRAY2BGR: number;
    export const COLOR_GRAY2BGR555: number;
    export const COLOR_GRAY2BGR565: number;
    export const COLOR_GRAY2BGRA: number;
    export const COLOR_GRAY2RGB: number;
    export const COLOR_GRAY2RGBA: number;
    export const COLOR_HLS2BGR: number;
    export const COLOR_HLS2BGR_FULL: number;
    export const COLOR_HLS2RGB: number;
    export const COLOR_HLS2RGB_FULL: number;
    export const COLOR_HSV2BGR: number;
    export const COLOR_HSV2BGR_FULL: number;
    export const COLOR_HSV2RGB: number;
    export const COLOR_HSV2RGB_FULL: number;
    export const COLOR_LBGR2Lab: number;
    export const COLOR_LBGR2Luv: number;
    export const COLOR_LRGB2Lab: number;
    export const COLOR_LRGB2Luv: number;
    export const COLOR_Lab2BGR: number;
    export const COLOR_Lab2LBGR: number;
    export const COLOR_Lab2LRGB: number;
    export const COLOR_Lab2RGB: number;
    export const COLOR_Luv2BGR: number;
    export const COLOR_Luv2LBGR: number;
    export const COLOR_Luv2LRGB: number;
    export const COLOR_Luv2RGB: number;
    export const COLOR_RGB2BGR: number;
    export const COLOR_RGB2BGR555: number;
    export const COLOR_RGB2BGR565: number;
    export const COLOR_RGB2BGRA: number;
    export const COLOR_RGB2GRAY: number;
    export const COLOR_RGB2HLS: number;
    export const COLOR_RGB2HLS_FULL: number;
    export const COLOR_RGB2HSV: number;
    export const COLOR_RGB2HSV_FULL: number;
    export const COLOR_RGB2Lab: number;
    export const COLOR_RGB2Luv: number;
    export const COLOR_RGB2RGBA: number;
    export const COLOR_RGB2XYZ: number;
    export const COLOR_RGB2YCrCb: number;
    export const COLOR_RGB2YUV: number;
    export const COLOR_RGB2YUV_I420: number;
    export const COLOR_RGB2YUV_IYUV: number;
    export const COLOR_RGB2YUV_YV12: number;
    export const COLOR_RGBA2BGR: number;
    export const COLOR_RGBA2BGR555: number;
    export const COLOR_RGBA2BGR565: number;
    export const COLOR_RGBA2BGRA: number;
    export const COLOR_RGBA2GRAY: number;
    export const COLOR_RGBA2RGB: number;
    export const COLOR_RGBA2YUV_I420: number;
    export const COLOR_RGBA2YUV_IYUV: number;
    export const COLOR_RGBA2YUV_YV12: number;
    export const COLOR_RGBA2mRGBA: number;
    export const COLOR_XYZ2BGR: number;
    export const COLOR_XYZ2RGB: number;
    export const COLOR_YCrCb2BGR: number;
    export const COLOR_YCrCb2RGB: number;
    export const COLOR_YUV2BGR: number;
    export const COLOR_YUV2BGRA_I420: number;
    export const COLOR_YUV2BGRA_IYUV: number;
    export const COLOR_YUV2BGRA_NV12: number;
    export const COLOR_YUV2BGRA_NV21: number;
    export const COLOR_YUV2BGRA_UYNV: number;
    export const COLOR_YUV2BGRA_UYVY: number;
    export const COLOR_YUV2BGRA_Y422: number;
    export const COLOR_YUV2BGRA_YUNV: number;
    export const COLOR_YUV2BGRA_YUY2: number;
    export const COLOR_YUV2BGRA_YUYV: number;
    export const COLOR_YUV2BGRA_YV12: number;
    export const COLOR_YUV2BGRA_YVYU: number;
    export const COLOR_YUV2BGR_I420: number;
    export const COLOR_YUV2BGR_IYUV: number;
    export const COLOR_YUV2BGR_NV12: number;
    export const COLOR_YUV2BGR_NV21: number;
    export const COLOR_YUV2BGR_UYNV: number;
    export const COLOR_YUV2BGR_UYVY: number;
    export const COLOR_YUV2BGR_Y422: number;
    export const COLOR_YUV2BGR_YUNV: number;
    export const COLOR_YUV2BGR_YUY2: number;
    export const COLOR_YUV2BGR_YUYV: number;
    export const COLOR_YUV2BGR_YV12: number;
    export const COLOR_YUV2BGR_YVYU: number;
    export const COLOR_YUV2GRAY_420: number;
    export const COLOR_YUV2GRAY_I420: number;
    export const COLOR_YUV2GRAY_IYUV: number;
    export const COLOR_YUV2GRAY_NV12: number;
    export const COLOR_YUV2GRAY_NV21: number;
    export const COLOR_YUV2GRAY_UYNV: number;
    export const COLOR_YUV2GRAY_UYVY: number;
    export const COLOR_YUV2GRAY_Y422: number;
    export const COLOR_YUV2GRAY_YUNV: number;
    export const COLOR_YUV2GRAY_YUY2: number;
    export const COLOR_YUV2GRAY_YUYV: number;
    export const COLOR_YUV2GRAY_YV12: number;
    export const COLOR_YUV2GRAY_YVYU: number;
    export const COLOR_YUV2RGB: number;
    export const COLOR_YUV2RGBA_I420: number;
    export const COLOR_YUV2RGBA_IYUV: number;
    export const COLOR_YUV2RGBA_NV12: number;
    export const COLOR_YUV2RGBA_NV21: number;
    export const COLOR_YUV2RGBA_UYNV: number;
    export const COLOR_YUV2RGBA_UYVY: number;
    export const COLOR_YUV2RGBA_Y422: number;
    export const COLOR_YUV2RGBA_YUNV: number;
    export const COLOR_YUV2RGBA_YUY2: number;
    export const COLOR_YUV2RGBA_YUYV: number;
    export const COLOR_YUV2RGBA_YV12: number;
    export const COLOR_YUV2RGBA_YVYU: number;
    export const COLOR_YUV2RGB_I420: number;
    export const COLOR_YUV2RGB_IYUV: number;
    export const COLOR_YUV2RGB_NV12: number;
    export const COLOR_YUV2RGB_NV21: number;
    export const COLOR_YUV2RGB_UYNV: number;
    export const COLOR_YUV2RGB_UYVY: number;
    export const COLOR_YUV2RGB_Y422: number;
    export const COLOR_YUV2RGB_YUNV: number;
    export const COLOR_YUV2RGB_YUY2: number;
    export const COLOR_YUV2RGB_YUYV: number;
    export const COLOR_YUV2RGB_YV12: number;
    export const COLOR_YUV2RGB_YVYU: number;
    export const COLOR_YUV420p2BGR: number;
    export const COLOR_YUV420p2BGRA: number;
    export const COLOR_YUV420p2GRAY: number;
    export const COLOR_YUV420p2RGB: number;
    export const COLOR_YUV420p2RGBA: number;
    export const COLOR_YUV420sp2BGR: number;
    export const COLOR_YUV420sp2BGRA: number;
    export const COLOR_YUV420sp2GRAY: number;
    export const COLOR_YUV420sp2RGB: number;
    export const COLOR_YUV420sp2RGBA: number;
    export const COLOR_mRGBA2RGBA: number;
    export const COLORMAP_AUTUMN: number;
    export const COLORMAP_BONE: number;
    export const COLORMAP_JET: number;
    export const COLORMAP_WINTER: number;
    export const COLORMAP_RAINBOW: number;
    export const COLORMAP_OCEAN: number;
    export const COLORMAP_SUMMER: number;
    export const COLORMAP_SPRING: number;
    export const COLORMAP_COOL: number;
    export const COLORMAP_HSV: number;
    export const COLORMAP_PINK: number;
    export const COLORMAP_HOT: number;
    export const COLORMAP_PARULA: number;
    export const CV_CONTOURS_MATCH_I1: number;
    export const CV_CONTOURS_MATCH_I2: number;
    export const CV_CONTOURS_MATCH_I3: number;
    export const DCT_INVERSE: number;
    export const DCT_ROWS: number;
    export const DFT_COMPLEX_OUTPUT: number;
    export const DFT_INVERSE: number;
    export const DFT_REAL_OUTPUT: number;
    export const DFT_ROWS: number;
    export const DFT_SCALE: number;
    export const DIST_C: number;
    export const DIST_FAIR: number;
    export const DIST_HUBER: number;
    export const DIST_L1: number;
    export const DIST_L12: number;
    export const DIST_L2: number;
    export const DIST_LABEL_CCOMP: number;
    export const DIST_LABEL_PIXEL: number;
    export const DIST_MASK_3: number;
    export const DIST_MASK_5: number;
    export const DIST_MASK_PRECISE: number;
    export const DIST_USER: number;
    export const DIST_WELSCH: number;
    export const FILLED: number;
    export const FLOODFILL_FIXED_RANGE: number;
    export const FLOODFILL_MASK_ONLY: number;
    export const FM_7POINT: number;
    export const FM_8POINT: number;
    export const FM_LMEDS: number;
    export const FM_RANSAC: number;
    export const FONT_HERSHEY_COMPLEX: number;
    export const FONT_HERSHEY_COMPLEX_SMALL: number;
    export const FONT_HERSHEY_DUPLEX: number;
    export const FONT_HERSHEY_PLAIN: number;
    export const FONT_HERSHEY_SCRIPT_COMPLEX: number;
    export const FONT_HERSHEY_SCRIPT_SIMPLEX: number;
    export const FONT_HERSHEY_SIMPLEX: number;
    export const FONT_HERSHEY_TRIPLEX: number;
    export const FONT_ITALIC: number;
    export const GC_BGD: number;
    export const GC_EVAL: number;
    export const GC_FGD: number;
    export const GC_INIT_WITH_MASK: number;
    export const GC_INIT_WITH_RECT: number;
    export const GC_PR_BGD: number;
    export const GC_PR_FGD: number;
    export const HISTCMP_BHATTACHARYYA: number;
    export const HISTCMP_CHISQR: number;
    export const HISTCMP_CHISQR_ALT: number;
    export const HISTCMP_CORREL: number;
    export const HISTCMP_HELLINGER: number;
    export const HISTCMP_INTERSECT: number;
    export const HISTCMP_KL_DIV: number;
    export const HOUGH_GRADIENT: number;
    export const HOUGH_MULTI_SCALE: number;
    export const HOUGH_PROBABILISTIC: number;
    export const HOUGH_STANDARD: number;
    export const INTER_AREA: number;
    export const INTER_CUBIC: number;
    export const INTER_LANCZOS4: number;
    export const INTER_LINEAR: number;
    export const INTER_MAX: number;
    export const INTER_NEAREST: number;
    export const KMEANS_PP_CENTERS: number;
    export const KMEANS_RANDOM_CENTERS: number;
    export const KMEANS_USE_INITIAL_LABELS: number;
    export const LINE_4: number;
    export const LINE_8: number;
    export const LINE_AA: number;
    export const LMEDS: number;
    export const MIXED_CLONE: number;
    export const MONOCHROME_TRANSFER: number;
    export const MORPH_BLACKHAT: number;
    export const MORPH_CLOSE: number;
    export const MORPH_CROSS: number;
    export const MORPH_DILATE: number;
    export const MORPH_ELLIPSE: number;
    export const MORPH_ERODE: number;
    export const MORPH_GRADIENT: number;
    export const MORPH_HITMISS: number;
    export const MORPH_OPEN: number;
    export const MORPH_RECT: number;
    export const MORPH_TOPHAT: number;
    export const NORM_HAMMING: number;
    export const NORM_HAMMING2: number;
    export const NORM_INF: number;
    export const NORM_L1: number;
    export const NORM_L2: number;
    export const NORM_L2SQR: number;
    export const NORM_MINMAX: number;
    export const NORM_RELATIVE: number;
    export const NORM_const_MASK: number;
    export const NORMAL_CLONE: number;
    export const RANSAC: number;
    export const REGULAR: number;
    export const RETR_CCOMP: number;
    export const RETR_EXTERNAL: number;
    export const RETR_FLOODFILL: number;
    export const RETR_LIST: number;
    export const RETR_TREE: number;
    export const RHO: number;
    export const ROTATE_180: number;
    export const ROTATE_90_CLOCKWISE: number;
    export const ROTATE_90_COUNTERCLOCKWISE: number;
    export const SOLVEPNP_AP3P: number;
    export const SOLVEPNP_DLS: number;
    export const SOLVEPNP_EPNP: number;
    export const SOLVEPNP_ITERATIVE: number;
    export const SOLVEPNP_MAX_COUNT: number;
    export const SOLVEPNP_P3P: number;
    export const SOLVEPNP_UPNP: number;
    export const THRESH_BINARY: number;
    export const THRESH_BINARY_INV: number;
    export const THRESH_MASK: number;
    export const THRESH_OTSU: number;
    export const THRESH_TOZERO: number;
    export const THRESH_TOZERO_INV: number;
    export const THRESH_TRIANGLE: number;
    export const THRESH_TRUNC: number;
    export const TM_CCOEFF: number;
    export const TM_CCOEFF_NORMED: number;
    export const TM_CCORR: number;
    export const TM_CCORR_NORMED: number;
    export const TM_SQDIFF: number;
    export const TM_SQDIFF_NORMED: number;
    export const VIDEOWRITER_PROP_FRAMEBYTES: number;
    export const VIDEOWRITER_PROP_NSTRIPES: number;
    export const VIDEOWRITER_PROP_QUALITY: number;
    export const WARP_FILL_OUTLIERS: number;
    export const WARP_INVERSE_MAP: number;
    export const INPAINT_NS: number;
    export const INPAINT_TELEA: number;
    export const IMREAD_UNCHANGED: number;
    export const IMREAD_GRAYSCALE: number;
    export const IMREAD_COLOR: number;
    export const IMREAD_ANYDEPTH: number;
    export const IMREAD_ANYCOLOR: number;
    export const IMREAD_LOAD_GDAL: number;
    export const IMWRITE_JPEG_QUALITY: number;
    export const IMWRITE_JPEG_PROGRESSIVE: number;
    export const IMWRITE_JPEG_OPTIMIZE: number;
    export const IMWRITE_JPEG_RST_INTERVAL: number;
    export const IMWRITE_JPEG_LUMA_QUALITY: number;
    export const IMWRITE_JPEG_CHROMA_QUALITY: number;
    export const IMWRITE_PNG_COMPRESSION: number;
    export const IMWRITE_PNG_STRATEGY: number;
    export const IMWRITE_PNG_BILEVEL: number;
    export const IMWRITE_PXM_BINARY: number;
    export const IMWRITE_WEBP_QUALITY: number;
    export const IMWRITE_PNG_STRATEGY_DEFAULT: number;
    export const IMWRITE_PNG_STRATEGY_FILTERED: number;
    export const IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY: number;
    export const IMWRITE_PNG_STRATEGY_RLE: number;
    export const IMWRITE_PNG_STRATEGY_FIXED: number;
    export const IMREAD_REDUCED_GRAYSCALE_2: number;
    export const IMREAD_REDUCED_COLOR_2: number;
    export const IMREAD_REDUCED_GRAYSCALE_4: number;
    export const IMREAD_REDUCED_COLOR_4: number;
    export const IMREAD_REDUCED_GRAYSCALE_8: number;
    export const IMREAD_REDUCED_COLOR_8: number;
    export const IMREAD_IGNORE_ORIENTATION: number;
    export const IMWRITE_PAM_TUPLETYPE: number;
    export const IMWRITE_PAM_FORMAT_NULL: number;
    export const IMWRITE_PAM_FORMAT_BLACKANDWHITE: number;
    export const IMWRITE_PAM_FORMAT_GRAYSCALE: number;
    export const IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA: number;
    export const IMWRITE_PAM_FORMAT_RGB: number;
    export const IMWRITE_PAM_FORMAT_RGB_ALPHA: number;
    export const HAAR_EYE: string;
    export const HAAR_EYE_TREE_EYEGLASSES: string;
    export const HAAR_FRONTALCATFACE: string;
    export const HAAR_FRONTALCATFACE_EXTENDED: string;
    export const HAAR_FRONTALFACE_ALT: string;
    export const HAAR_FRONTALFACE_ALT2: string;
    export const HAAR_FRONTALFACE_ALT_TREE: string;
    export const HAAR_FRONTALFACE_DEFAULT: string;
    export const HAAR_FULLBODY: string;
    export const HAAR_LEFTEYE_2SPLITS: string;
    export const HAAR_LICENCE_PLATE_RUS_16STAGES: string;
    export const HAAR_LOWERBODY: string;
    export const HAAR_PROFILEFACE: string;
    export const HAAR_RIGHTEYE_2SPLITS: string;
    export const HAAR_RUSSIAN_PLATE_NUMBER: string;
    export const HAAR_SMILE: string;
    export const HAAR_UPPERBODY: string;
    export const LBP_FRONTALCATFACE: string;
    export const LBP_FRONTALFACE: string;
    export const LBP_FRONTALFACE_IMPROVED: string;
    export const LBP_PROFILEFACE: string;
    export const LBP_SILVERWARE: string;
    export const termCriteria: {
        COUNT: number;
        MAX_ITER: number;
        EPS: number;
    };
    export const ml: {
        COL_SAMPLE: number;
        ROW_SAMPLE: number;
        VAR_CATEGORICAL: number;
        VAR_NUMERICAL: number;
        VAR_ORDERED: number;
        SVM: {
            CUSTOM: number;
            LINEAR: number;
            POLY: number;
            RBF: number;
            SIGMOID: number;
            CHI2: number;
            INTER: number;
            C: number;
            COEF: number;
            DEGREE: number;
            GAMMA: number;
            NU: number;
            P: number;
        };
    };
    export const statModel: {
        COMPRESSED_INPUT: number;
        PREPROCESSED_INPUT: number;
        RAW_OUTPUT: number;
        UPDATE_MODEL: number;
    };
}
declare module "@autojs/opencv" {
    export const xmodules: {
        dnn: boolean;
        face: boolean;
        text: boolean;
        tracking: boolean;
        xfeatures2d: boolean;
        ximgproc: boolean;
    };
    export const version: {
        major: number;
        minor: number;
    };
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    export class FaceRecognizer {
        load(file: string): void;
        predict(img: Mat): {
            label: number;
            confidence: number;
        };
        predictAsync(img: Mat): Promise<{
            label: number;
            confidence: number;
        }>;
        save(file: string): void;
        train(trainImages: Mat[], labels: number[]): void;
        trainAsync(trainImages: Mat[], labels: number[]): Promise<void>;
    }
}
declare module "@autojs/opencv" {
    import { FaceRecognizer } from "@autojs/opencv";
    export class EigenFaceRecognizer extends FaceRecognizer {
        constructor(num_components?: number, threshold?: number);
    }
}
declare module "@autojs/opencv" {
    import { FaceRecognizer } from "@autojs/opencv";
    export class LBPHFaceRecognizer extends FaceRecognizer {
        constructor(radius?: number, neighbors?: number, grid_x?: number, grid_y?: number, threshold?: number);
    }
}
declare module "@autojs/opencv" {
    import { FaceRecognizer } from "@autojs/opencv";
    export class FisherFaceRecognizer extends FaceRecognizer {
        constructor(num_components?: number, threshold?: number);
    }
}
declare module "@autojs/opencv" {
    import { KeyPoint } from "@autojs/opencv";
    import { Mat } from "@autojs/opencv";
    export class KeyPointDetector {
        detect(image: Mat): KeyPoint[];
        detectAsync(image: Mat): Promise<KeyPoint[]>;
    }
}
declare module "@autojs/opencv" {
    import { KeyPointDetector } from "@autojs/opencv";
    import { KeyPoint } from "@autojs/opencv";
    import { Mat } from "@autojs/opencv";
    export class FeatureDetector extends KeyPointDetector {
        compute(image: Mat, keypoints: KeyPoint[]): Mat;
        computeAsync(image: Mat, keypoints: KeyPoint[]): Promise<Mat>;
    }
}
declare module "@autojs/opencv" {
    import { KeyPointDetector } from "@autojs/opencv";
    export class AGASTDetector extends KeyPointDetector {
        readonly threshold: number;
        readonly type: number;
        readonly nonmaxSuppression: boolean;
        constructor(threshold?: number, nonmaxSuppression?: boolean, type?: number);
        constructor(params: {
            threshold?: number;
            nonmaxSuppression?: boolean;
            type?: number;
        });
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    import { DescriptorMatch } from "@autojs/opencv";
    export class BFMatcher {
        constructor(normType: number, crossCheck?: boolean);
        constructor(params: {
            normType: number;
            crossCheck?: boolean;
        });
        match(descriptors1: Mat, descriptors2: Mat): DescriptorMatch[];
        matchAsync(descriptors1: Mat, descriptors2: Mat): Promise<DescriptorMatch[]>;
        knnMatch(descriptors1: Mat, descriptors2: Mat, k: number): Array<[DescriptorMatch] | [any]>;
        knnMatchAsync(descriptors1: Mat, descriptors2: Mat, k: number): Promise<Array<[DescriptorMatch] | [any]>>;
    }
}
declare module "@autojs/opencv" {
    import { FeatureDetector } from "@autojs/opencv";
    export class AKAZEDetector extends FeatureDetector {
        readonly descriptorType: number;
        readonly descriptorSize: number;
        readonly descriptorChannels: number;
        readonly nOctaves: number;
        readonly nOctaveLayers: number;
        readonly diffusivity: number;
        readonly threshold: number;
        constructor(descriptorType?: number, descriptorSize?: number, descriptorChannels?: number, threshold?: number, nOctaves?: number, nOctaveLayers?: number, diffusivity?: number);
        constructor(params: {
            descriptorType?: number;
            descriptorSize?: number;
            descriptorChannels?: number;
            threshold?: number;
            nOctaves?: number;
            nOctaveLayers?: number;
            diffusivity?: number;
        });
    }
}
declare module "@autojs/opencv" {
    import { FeatureDetector } from "@autojs/opencv";
    export class BRISKDetector extends FeatureDetector {
        readonly thresh: number;
        readonly octaves: number;
        readonly patternScale: number;
        constructor(thresh?: number, octaves?: number, patternScale?: number);
        constructor(params: {
            thresh?: number;
            octaves?: number;
            patternScale?: number;
        });
    }
}
declare module "@autojs/opencv" {
    import { KeyPointDetector } from "@autojs/opencv";
    export class FASTDetector extends KeyPointDetector {
        readonly threshold: number;
        readonly type: number;
        readonly nonmaxSuppression: boolean;
        constructor(threshold?: number, nonmaxSuppression?: boolean, type?: number);
        constructor(params: {
            threshold?: number;
            nonmaxSuppression?: boolean;
            type?: number;
        });
    }
}
declare module "@autojs/opencv" {
    import { KeyPointDetector } from "@autojs/opencv";
    export class GFTTDetector extends KeyPointDetector {
        readonly maxFeatures: number;
        readonly blockSize: number;
        readonly qualityLevel: number;
        readonly minDistance: number;
        readonly k: number;
        readonly harrisDetector: boolean;
        constructor(maxFeatures?: number, qualityLevel?: number, minDistance?: number, blockSize?: number, harrisDetector?: boolean, k?: number);
        constructor(params: {
            maxFeatures?: number;
            qualityLevel?: number;
            minDistance?: number;
            blockSize?: number;
            harrisDetector?: boolean;
            k?: number;
        });
    }
}
declare module "@autojs/opencv" {
    import { FeatureDetector } from "@autojs/opencv";
    export class KAZEDetector extends FeatureDetector {
        readonly extended: boolean;
        readonly upright: boolean;
        readonly nOctaves: number;
        readonly nOctaveLayers: number;
        readonly diffusivity: number;
        readonly threshold: number;
        constructor(extended?: boolean, upright?: boolean, threshold?: number, nOctaves?: number, nOctaveLayers?: number, diffusivity?: number);
        constructor(params: {
            extended?: boolean;
            upright?: boolean;
            threshold?: number;
            nOctaves?: number;
            nOctaveLayers?: number;
            diffusivity?: number;
        });
    }
}
declare module "@autojs/opencv" {
    import { KeyPointDetector } from "@autojs/opencv";
    import { Point2 } from "@autojs/opencv";
    import { Rect } from "@autojs/opencv";
    import { Mat } from "@autojs/opencv";
    export class MSERDetector extends KeyPointDetector {
        readonly delta: number;
        readonly minArea: number;
        readonly maxArea: number;
        readonly maxEvolution: number;
        readonly edgeBlurSize: number;
        readonly maxVariation: number;
        readonly minDiversity: number;
        readonly areaThreshold: number;
        readonly minMargin: number;
        constructor(delta?: number, minArea?: number, maxArea?: number, maxVariation?: number, minDiversity?: number, maxEvolution?: number, areaThreshold?: number, minMargin?: number, edgeBlurSize?: number);
        constructor(params: {
            delta?: number;
            minArea?: number;
            maxArea?: number;
            maxVariation?: number;
            minDiversity?: number;
            maxEvolution?: number;
            areaThreshold?: number;
            minMargin?: number;
            edgeBlurSize?: number;
        });
        detectRegions(image: Mat): {
            msers: Point2[][];
            bboxes: Rect[];
        };
        detectRegionsAsync(image: Mat): Promise<{
            msers: Point2[][];
            bboxes: Rect[];
        }>;
    }
}
declare module "@autojs/opencv" {
    import { FeatureDetector } from "@autojs/opencv";
    export class ORBDetector extends FeatureDetector {
        readonly maxFeatures: number;
        readonly nLevels: number;
        readonly edgeThreshold: number;
        readonly firstLevel: number;
        readonly WTA_K: number;
        readonly scoreType: number;
        readonly patchSize: number;
        readonly fastThreshold: number;
        readonly scaleFactor: number;
        constructor(maxFeatures?: number, scaleFactor?: number, nLevels?: number, edgeThreshold?: number, firstLevel?: number, WTA_K?: number, scoreType?: number, patchSize?: number, fastThreshold?: number);
        constructor(params: {
            maxFeatures?: number;
            scaleFactor?: number;
            nLevels?: number;
            edgeThreshold?: number;
            firstLevel?: number;
            WTA_K?: number;
            scoreType?: number;
            patchSize?: number;
            fastThreshold?: number;
        });
    }
}
declare module "@autojs/opencv" {
    export class SimpleBlobDetectorParams {
        blobColor: number;
        filterByArea: boolean;
        filterByCircularity: boolean;
        filterByColor: boolean;
        filterByConvexity: boolean;
        filterByInertia: boolean;
        maxArea: number;
        maxCircularity: number;
        maxConvexity: number;
        maxInertiaRatio: number;
        maxThreshold: number;
        minArea: number;
        minCircularity: number;
        minConvexity: number;
        minDistBetweenBlobs: number;
        minInertiaRatio: number;
        minRepeatability: number;
        minThreshold: number;
        thresholdStep: number;
        constructor();
    }
}
declare module "@autojs/opencv" {
    import { FeatureDetector } from "@autojs/opencv";
    import { SimpleBlobDetectorParams } from "@autojs/opencv";
    export class SimpleBlobDetector extends FeatureDetector {
        constructor(params: SimpleBlobDetectorParams);
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    export class VideoCapture {
        constructor(filePath: string);
        constructor(devicePort: number);
        get(property: number): number;
        read(): Mat;
        readAsync(): Promise<Mat>;
        release(): void;
        reset(): void;
        set(property: number, value: number): boolean;
        setAsync(property: number, value: number): Promise<boolean>;
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    import { Size } from "@autojs/opencv";
    export class VideoWriter {
        constructor(filePath: string, fourccCode: number, fps: number, frameSize: Size, isColor?: boolean);
        static fourcc(fourcc: string): number;
        get(property: number): void;
        release(): void;
        set(property: number, value: number): void;
        write(img: Mat): void;
        writeAsync(img: Mat): Promise<void>;
    }
}
declare module "@autojs/opencv" {
    export class ParamGrid {
        readonly minVal: number;
        readonly maxVal: number;
        readonly logStep: number;
        constructor(paramId: number);
        constructor(minVal: number, maxVal: number, logStep: number);
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    export class TrainData {
        readonly samples: Mat;
        readonly layout: number;
        readonly responses: Mat;
        readonly varType: number[];
        constructor(samples: Mat, layout: number, responses: Mat, varIdx?: number[], sampleIdx?: number[], sampleWeights?: number[], varType?: number[]);
    }
}
declare module "@autojs/opencv" {
    import { Size } from "@autojs/opencv";
    import { Mat } from "@autojs/opencv";
    import { Rect } from "@autojs/opencv";
    export class CascadeClassifier {
        constructor(xmlFilePath: string);
        detectMultiScale(img: Mat, scaleFactor?: number, minNeighbors?: number, flags?: number, minSize?: Size, maxSize?: Size): {
            objects: Rect[];
            numDetections: number[];
        };
        detectMultiScaleAsync(img: Mat, scaleFactor?: number, minNeighbors?: number, flags?: number, minSize?: Size, maxSize?: Size): Promise<{
            objects: Rect[];
            numDetections: number[];
        }>;
        detectMultiScaleGpu(img: Mat, scaleFactor?: number, minNeighbors?: number, flags?: number, minSize?: Size, maxSize?: Size): Rect[];
        detectMultiScaleWithRejectLevels(img: Mat, scaleFactor?: number, minNeighbors?: number, flags?: number, minSize?: Size, maxSize?: Size): {
            objects: Rect[];
            rejectLevels: number[];
            levelWeights: number[];
        };
        detectMultiScaleWithRejectLevelsAsync(img: Mat, scaleFactor?: number, minNeighbors?: number, flags?: number, minSize?: Size, maxSize?: Size): Promise<{
            objects: Rect[];
            rejectLevels: number[];
            levelWeights: number[];
        }>;
    }
}
declare module "@autojs/opencv" {
    import { Point2 } from "@autojs/opencv";
    export class DetectionROI {
        readonly scale: number;
        readonly locations: Point2[];
        readonly confidences: number[];
        constructor();
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    import { Size } from "@autojs/opencv";
    import { Rect } from "@autojs/opencv";
    import { Point2 } from "@autojs/opencv";
    export class HOGDescriptor {
        readonly winSize: Size;
        readonly blockSize: Size;
        readonly blockStride: Size;
        readonly cellSize: Size;
        readonly nbins: number;
        readonly derivAperture: number;
        readonly histogramNormType: number;
        readonly nlevels: number;
        readonly winSigma: number;
        readonly L2HysThreshold: number;
        readonly gammaCorrection: boolean;
        readonly signedGradient: boolean;
        constructor(winSize?: Size, blockSize?: Size, blockStride?: Size, cellSize?: Size, nbins?: number, derivAperture?: number, winSigma?: number, histogramNormType?: number, L2HysThreshold?: number, gammaCorrection?: boolean, nlevels?: number, signedGradient?: boolean);
        constructor(params: {
            winSize?: Size;
            blockSize?: Size;
            blockStride?: Size;
            cellSize?: Size;
            nbins?: number;
            derivAperture?: number;
            winSigma?: number;
            histogramNormType?: number;
            L2HysThreshold?: number;
            gammaCorrection?: boolean;
            nlevels?: number;
            signedGradient?: boolean;
        });
        checkDetectorSize(): boolean;
        compute(img: Mat, winStride?: Size, padding?: Size, locations?: Point2[]): number[];
        computeAsync(img: Mat, winStride?: Size, padding?: Size, locations?: Point2[]): Promise<number[]>;
        computeGradient(img: Mat, paddingTL?: Size, paddingBR?: Size): {
            grad: Mat;
            angleOfs: Mat;
        };
        computeGradientAsync(img: Mat, paddingTL?: Size, paddingBR?: Size): Promise<{
            grad: Mat;
            angleOfs: Mat;
        }>;
        detect(img: Mat, hitThreshold?: number, winStride?: Size, padding?: Size, searchLocations?: Point2[]): {
            foundLocations: Point2[];
            weights: number[];
        };
        detectAsync(img: Mat, hitThreshold?: number, winStride?: Size, padding?: Size, searchLocations?: Point2[]): Promise<{
            foundLocations: Point2[];
            weights: number[];
        }>;
        detectMultiScale(img: Mat, hitThreshold?: number, winStride?: Size, padding?: Size, scale?: number, finalThreshold?: number, useMeanshiftGrouping?: boolean): {
            foundLocations: Rect[];
            foundWeights: number[];
        };
        detectMultiScaleAsync(img: Mat, hitThreshold?: number, winStride?: Size, padding?: Size, scale?: number, finalThreshold?: number, useMeanshiftGrouping?: boolean): Promise<{
            foundLocations: Rect[];
            foundWeights: number[];
        }>;
        detectMultiScaleROI(img: Mat, hitThreshold?: number, groupThreshold?: number): Rect[];
        detectMultiScaleROIAsync(img: Mat, hitThreshold?: number, groupThreshold?: number): Promise<Rect[]>;
        detectROI(img: Mat, locations: Point2[], hitThreshold?: number, winStride?: Size, padding?: Size): {
            foundLocations: Point2[];
            confidences: number[];
        };
        detectROIAsync(img: Mat, locations: Point2[], hitThreshold?: number, winStride?: Size, padding?: Size): Promise<{
            foundLocations: Point2[];
            confidences: number[];
        }>;
        getDaimlerPeopleDetector(): number[];
        getDefaultPeopleDetector(): number[];
        groupRectangles(rectList: Rect[], weights: number[], groupThreshold: number, eps: number): Rect[];
        groupRectanglesAsync(rectList: Rect[], weights: number[], groupThreshold: number, eps: number): Promise<Rect[]>;
        load(path: string): void;
        save(path: string): void;
        setSVMDetector(detector: number[]): void;
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    import { Rect } from "@autojs/opencv";
    export class MultiTracker {
        constructor();
        addBOOSTING(frame: Mat, boundingBox: Rect): boolean;
        addKCF(frame: Mat, boundingBox: Rect): boolean;
        addMEDIANFLOW(frame: Mat, boundingBox: Rect): boolean;
        addMil(frame: Mat, boundingBox: Rect): boolean;
        addTLD(frame: Mat, boundingBox: Rect): boolean;
        update(frame: Mat): Rect[];
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    import { TrainData } from "@autojs/opencv";
    import { ParamGrid } from "@autojs/opencv";
    export class SVM {
        readonly c: number;
        readonly coef0: number;
        readonly degree: number;
        readonly gamma: number;
        readonly nu: number;
        readonly p: number;
        readonly kernelType: number;
        readonly classWeights: Mat;
        readonly varCount: number;
        readonly isTrained: boolean;
        constructor(c?: number, coef0?: number, degree?: number, gamma?: number, nu?: number, p?: number, kernelType?: number, classWeights?: Mat);
        constructor(params: {
            c?: number;
            coef0?: number;
            degree?: number;
            gamma?: number;
            nu?: number;
            p?: number;
            kernelType?: number;
            classWeights?: Mat;
        });
        calcError(trainData: TrainData, test: boolean): {
            error: number;
            responses: Mat;
        };
        getSupportVectors(): Mat;
        getDecisionFunction(): {
            rho: number;
            alpha: Mat;
            svidx: Mat;
        };
        load(file: string): void;
        predict(sample: number[], flags?: number): number;
        predict(samples: Mat, flags?: number): number[];
        save(file: string): void;
        setParams(c?: number, coef0?: number, degree?: number, gamma?: number, nu?: number, p?: number, kernelType?: number, classWeights?: Mat): void;
        train(trainData: TrainData, flags?: number): boolean;
        train(samples: Mat, layout: number, responses: Mat): boolean;
        trainAsync(trainData: TrainData, flags?: number): Promise<boolean>;
        trainAsync(samples: Mat, layout: number, responses: Mat): Promise<boolean>;
        trainAuto(trainData: TrainData, kFold?: number, cGrid?: ParamGrid, gammaGrid?: ParamGrid, pGrid?: ParamGrid, nuGrid?: ParamGrid, coeffGrid?: ParamGrid, degreeGrid?: ParamGrid, balanced?: boolean): Mat;
        trainAutoAsync(trainData: TrainData, kFold?: number, cGrid?: ParamGrid, gammaGrid?: ParamGrid, pGrid?: ParamGrid, nuGrid?: ParamGrid, coeffGrid?: ParamGrid, degreeGrid?: ParamGrid, balanced?: boolean): Promise<Mat>;
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    import { Rect } from "@autojs/opencv";
    import { OCRHMMClassifier } from "@autojs/opencv";
    export class OCRHMMDecoder {
        constructor(classifier: OCRHMMClassifier, vocabulary: string, transitionPropabilitiesTable: Mat, emissionPropabilitiesTable: Mat, mode?: number);
        run(img: Mat, mask?: Mat, componentLevel?: number): string;
        runAsync(img: Mat, mask?: Mat, componentLevel?: number): Promise<string>;
        runWithInfo(img: Mat, mask?: Mat, componentLevel?: number): {
            outputText: string;
            rects: Rect[];
            words: string[];
            confidences: number[];
        };
        runWithInfoAsync(img: Mat, mask?: Mat, componentLevel?: number): Promise<{
            outputText: string;
            rects: Rect[];
            words: string[];
            confidences: number[];
        }>;
    }
}
declare module "@autojs/opencv" {
    export class TrackerBoostingParams {
        readonly numClassifiers: number;
        readonly samplerOverlap: number;
        readonly samplerSearchFactor: number;
        readonly iterationInit: number;
        readonly featureSetNumFeatures: number;
        constructor();
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    import { Rect } from "@autojs/opencv";
    export class TrackerGOTURN {
        constructor();
        clear(): void;
        init(frame: Mat, boundingBox: Rect): boolean;
        update(frame: Mat): Rect;
    }
}
declare module "@autojs/opencv" {
    export class TrackerKCFParams {
        readonly sigma: number;
        readonly lambda: number;
        readonly interp_factor: number;
        readonly output_sigma_factor: number;
        readonly pca_learning_rate: number;
        readonly resize: boolean;
        readonly split_coeff: boolean;
        readonly wrap_kernel: boolean;
        readonly compress_feature: boolean;
        readonly max_patch_size: number;
        readonly compressed_size: number;
        readonly desc_pca: number;
        readonly desc_npca: number;
        readonly detect_thresh: number;
        constructor();
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    import { Rect } from "@autojs/opencv";
    export class TrackerMedianFlow {
        constructor(pointsInGrid?: number);
        clear(): void;
        init(frame: Mat, boundingBox: Rect): boolean;
        update(frame: Mat): Rect;
    }
}
declare module "@autojs/opencv" {
    export class TrackerMILParams {
        readonly samplerInitInRadius: number;
        readonly samplerSearchWinSize: number;
        readonly samplerTrackInRadius: number;
        readonly samplerInitMaxNegNum: number;
        readonly samplerTrackMaxPosNum: number;
        readonly samplerTrackMaxNegNum: number;
        readonly featureSetNumFeatures: number;
        constructor();
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    import { Rect } from "@autojs/opencv";
    export class TrackerTLD {
        constructor();
        clear(): void;
        init(frame: Mat, boundingBox: Rect): boolean;
        update(frame: Mat): Rect;
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    import { Rect } from "@autojs/opencv";
    import { TrackerMILParams } from "@autojs/opencv";
    export class TrackerMIL {
        constructor();
        constructor(params: TrackerMILParams);
        clear(): void;
        init(frame: Mat, boundingBox: Rect): boolean;
        update(frame: Mat): Rect;
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    import { Rect } from "@autojs/opencv";
    import { TrackerKCFParams } from "@autojs/opencv";
    export class TrackerKCF {
        constructor();
        constructor(params: TrackerKCFParams);
        clear(): void;
        init(frame: Mat, boundingBox: Rect): boolean;
        update(frame: Mat): Rect;
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    import { Rect } from "@autojs/opencv";
    import { TrackerBoostingParams } from "@autojs/opencv";
    export class TrackerBoosting {
        constructor();
        constructor(params: TrackerBoostingParams);
        clear(): void;
        init(frame: Mat, boundingBox: Rect): boolean;
        update(frame: Mat): Rect;
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    export class BackgroundSubtractorKNN {
        readonly history: number;
        readonly dist2Threshold: number;
        readonly detectShadows: boolean;
        constructor(history?: number, varThreshold?: number, detectShadows?: boolean);
        apply(frame: Mat, learningRate?: number): Mat;
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    export class BackgroundSubtractorMOG2 {
        readonly history: number;
        readonly varThreshold: number;
        readonly detectShadows: boolean;
        constructor(history?: number, varThreshold?: number, detectShadows?: boolean);
        apply(frame: Mat, learningRate?: number): Mat;
    }
}
declare module "@autojs/opencv" {
    import { FeatureDetector } from "@autojs/opencv";
    export class SIFTDetector extends FeatureDetector {
        readonly nfeatures: number;
        readonly nOctaveLayers: number;
        readonly contrastThreshold: number;
        readonly edgeThreshold: number;
        readonly sigma: number;
        constructor(nFeatures?: number, nOctaveLayers?: number, contrastThreshold?: number, edgeThreshold?: number, sigma?: number);
        constructor(params: {
            nFeatures?: number;
            nOctaveLayers?: number;
            contrastThreshold?: number;
            edgeThreshold?: number;
            sigma?: number;
        });
    }
}
declare module "@autojs/opencv" {
    import { FeatureDetector } from "@autojs/opencv";
    export class SURFDetector extends FeatureDetector {
        readonly nOctaves: number;
        readonly nOctaveLayers: number;
        readonly hessianThreshold: number;
        readonly extended: boolean;
        readonly upright: boolean;
        constructor(hessianThreshold?: number, nOctaves?: number, nOctaveLayers?: number, extended?: boolean, upright?: boolean);
        constructor(params: {
            hessianThreshold?: number;
            nOctaves?: number;
            nOctaveLayers?: number;
            extended?: boolean;
            upright?: boolean;
        });
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    export class SuperpixelLSC {
        readonly image: Mat;
        readonly labels: Mat;
        readonly labelContourMask: Mat;
        readonly regionSize: number;
        readonly ratio: number;
        readonly numCalculatedSuperpixels: number;
        constructor(img: Mat, regionSize?: number, ratio?: number);
        iterate(iterations?: number): void;
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    export class SuperpixelSLIC {
        readonly image: Mat;
        readonly labels: Mat;
        readonly labelContourMask: Mat;
        readonly algorithm: number;
        readonly regionSize: number;
        readonly ruler: number;
        readonly numCalculatedSuperpixels: number;
        constructor(img: Mat, algorithm?: number, regionSize?: number, ruler?: number);
        iterate(iterations?: number): void;
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    export class SuperpixelSEEDS {
        readonly image: Mat;
        readonly labels: Mat;
        readonly labelContourMask: Mat;
        readonly num_superpixels: number;
        readonly num_levels: number;
        readonly prior: number;
        readonly histogramBins: number;
        readonly numCalculatedSuperpixels: number;
        readonly doubleStep: boolean;
        constructor(img: Mat, num_superpixels: number, num_levels: number, prior?: number, histogramBins?: number, doubleStep?: boolean);
        iterate(iterations?: number): void;
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    import { Rect } from "@autojs/opencv";
    import { Point2 } from "@autojs/opencv";
    export class Facemark {
        addTrainingSample(image: Mat, landmarks: number[][]): boolean;
        addTrainingSampleAsync(image: Mat, landmarks: number[][]): Promise<boolean>;
        loadModel(model: string): void;
        loadModelAsync(model: string): Promise<void>;
        getFaces(image: Mat): Rect[];
        getFacesAsync(image: Mat): Promise<Rect[]>;
        setFaceDetector(callback: Function): boolean;
        training(): void;
        trainingAsync(): Promise<void>;
        fit(image: Mat, faces: Rect[]): Point2[][];
        fitAsync(image: Mat, faces: Rect[]): Promise<Point2[][]>;
        save(file: string): void;
        load(file: string): void;
    }
}
declare module "@autojs/opencv" {
    export class FacemarkAAMParams {
        readonly m: number;
        readonly maxM: number;
        readonly maxN: number;
        readonly modelFilename: string;
        readonly n: number;
        readonly nIter: number;
        readonly saveModel: boolean;
        readonly scales: number[];
        readonly textureMaxM: number;
        readonly verbose: boolean;
        constructor();
    }
}
declare module "@autojs/opencv" {
    import { Facemark } from "@autojs/opencv";
    export class FacemarkLBF extends Facemark {
    }
}
declare module "@autojs/opencv" {
    import { Rect } from "@autojs/opencv";
    export class FacemarkLBFParams {
        readonly baggingOverlap: number;
        readonly cascadeFace: string;
        readonly detectROI: Rect;
        readonly featsM: number[];
        readonly initShapeN: number;
        readonly modelFilename: string;
        readonly nLandmarks: number;
        readonly pupils: number[];
        readonly radiusM: number[];
        readonly saveModel: boolean;
        readonly seed: number;
        readonly shapeOffset: number;
        readonly stagesN: number;
        readonly treeDepth: number;
        readonly treeN: number;
        readonly verbose: boolean;
        constructor();
    }
}
declare module "@autojs/opencv" {
    import { Facemark } from "@autojs/opencv";
    export class FacemarkAAM extends Facemark {
    }
}
declare module "@autojs/opencv" {
    export class TrackerCSRTParams {
        constructor();
        readonly admm_iterations: number;
        readonly background_ratio: number;
        readonly cheb_attenuation: number;
        readonly filter_lr: number;
        readonly gsl_sigma: number;
        readonly histogram_bins: number;
        readonly histogram_lr: number;
        readonly hog_clip: number;
        readonly hog_orientations: number;
        readonly kaiser_alpha: number;
        readonly num_hog_channels_used: number;
        readonly number_of_scales: number;
        readonly padding: number;
        readonly scale_lr: number;
        readonly scale_model_max_area: number;
        readonly scale_sigma_factor: number;
        readonly scale_step: number;
        readonly template_size: number;
        readonly use_channel_weights: boolean;
        readonly use_color_names: boolean;
        readonly use_gray: boolean;
        readonly use_hog: boolean;
        readonly use_rgb: boolean;
        readonly use_segmentation: boolean;
        readonly weights_lr: number;
        readonly window_function: string;
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    import { Rect } from "@autojs/opencv";
    import { TrackerCSRTParams } from "@autojs/opencv";
    export class TrackerCSRT {
        constructor();
        constructor(params: TrackerCSRTParams);
        clear(): void;
        init(frame: Mat, boundingBox: Rect): boolean;
        update(frame: Mat): Rect;
    }
}
declare module "@autojs/opencv" {
    import { Mat } from "@autojs/opencv";
    import { Rect } from "@autojs/opencv";
    export class TrackerKCF {
        constructor();
        clear(): void;
        init(frame: Mat, boundingBox: Rect): boolean;
        update(frame: Mat): Rect;
    }
}
